{"ast":null,"code":"/**\r\n * DevExtreme (ui/widget/ui.widget.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\"),\n  eventsEngine = require(\"../../events/core/events_engine\"),\n  Action = require(\"../../core/action\"),\n  extend = require(\"../../core/utils/extend\").extend,\n  inArray = require(\"../../core/utils/array\").inArray,\n  each = require(\"../../core/utils/iterator\").each,\n  commonUtils = require(\"../../core/utils/common\"),\n  typeUtils = require(\"../../core/utils/type\"),\n  domAdapter = require(\"../../core/dom_adapter\"),\n  DOMComponentWithTemplate = require(\"../../core/dom_component_with_template\"),\n  KeyboardProcessor = require(\"./ui.keyboard_processor\"),\n  selectors = require(\"./selectors\"),\n  eventUtils = require(\"../../events/utils\"),\n  hoverEvents = require(\"../../events/hover\"),\n  feedbackEvents = require(\"../../events/core/emitter.feedback\"),\n  clickEvent = require(\"../../events/click\");\nvar UI_FEEDBACK = \"UIFeedback\",\n  WIDGET_CLASS = \"dx-widget\",\n  ACTIVE_STATE_CLASS = \"dx-state-active\",\n  DISABLED_STATE_CLASS = \"dx-state-disabled\",\n  INVISIBLE_STATE_CLASS = \"dx-state-invisible\",\n  HOVER_STATE_CLASS = \"dx-state-hover\",\n  FOCUSED_STATE_CLASS = \"dx-state-focused\",\n  FEEDBACK_SHOW_TIMEOUT = 30,\n  FEEDBACK_HIDE_TIMEOUT = 400,\n  FOCUS_NAMESPACE = \"Focus\";\nvar Widget = DOMComponentWithTemplate.inherit({\n  _supportedKeys: function _supportedKeys() {\n    return {};\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      disabled: false,\n      visible: true,\n      hint: void 0,\n      activeStateEnabled: false,\n      onContentReady: null,\n      hoverStateEnabled: false,\n      focusStateEnabled: false,\n      tabIndex: 0,\n      accessKey: null,\n      onFocusIn: null,\n      onFocusOut: null,\n      _keyboardProcessor: void 0\n    });\n  },\n  _feedbackShowTimeout: FEEDBACK_SHOW_TIMEOUT,\n  _feedbackHideTimeout: FEEDBACK_HIDE_TIMEOUT,\n  _init: function _init() {\n    this.callBase();\n    this._initContentReadyAction();\n  },\n  _clearInnerOptionCache: function _clearInnerOptionCache(optionContainer) {\n    this[optionContainer + \"Cache\"] = {};\n  },\n  _cacheInnerOptions: function _cacheInnerOptions(optionContainer, optionValue) {\n    var cacheName = optionContainer + \"Cache\";\n    this[cacheName] = extend(this[cacheName], optionValue);\n  },\n  _getOptionsFromContainer: function _getOptionsFromContainer(_ref) {\n    var name = _ref.name,\n      fullName = _ref.fullName,\n      value = _ref.value;\n    var options = {};\n    if (name === fullName) {\n      options = value;\n    } else {\n      var option = fullName.split(\".\").pop();\n      options[option] = value;\n    }\n    return options;\n  },\n  _innerOptionChanged: function _innerOptionChanged(innerWidget, args) {\n    var options = this._getOptionsFromContainer(args);\n    innerWidget && innerWidget.option(options);\n    this._cacheInnerOptions(args.name, options);\n  },\n  _getInnerOptionsCache: function _getInnerOptionsCache(optionContainer) {\n    return this[optionContainer + \"Cache\"];\n  },\n  _initInnerOptionCache: function _initInnerOptionCache(optionContainer) {\n    this._clearInnerOptionCache(optionContainer);\n    this._cacheInnerOptions(optionContainer, this.option(optionContainer));\n  },\n  _bindInnerWidgetOptions: function _bindInnerWidgetOptions(innerWidget, optionsContainer) {\n    this._options[optionsContainer] = extend({}, innerWidget.option());\n    innerWidget.on(\"optionChanged\", function (e) {\n      this._options[optionsContainer] = extend({}, e.component.option());\n    }.bind(this));\n  },\n  _getAriaTarget: function _getAriaTarget() {\n    return this._focusTarget();\n  },\n  _initContentReadyAction: function _initContentReadyAction() {\n    this._contentReadyAction = this._createActionByOption(\"onContentReady\", {\n      excludeValidators: [\"disabled\", \"readOnly\"]\n    });\n  },\n  _initMarkup: function _initMarkup() {\n    this.$element().addClass(WIDGET_CLASS);\n    this._toggleDisabledState(this.option(\"disabled\"));\n    this._toggleVisibility(this.option(\"visible\"));\n    this._renderHint();\n    if (this._isFocusable()) {\n      this._renderFocusTarget();\n    }\n    this.callBase();\n  },\n  _render: function _render() {\n    this.callBase();\n    this._renderContent();\n    this._renderFocusState();\n    this._attachFeedbackEvents();\n    this._attachHoverEvents();\n  },\n  _renderHint: function _renderHint() {\n    var hint = this.option(\"hint\");\n    this.$element().attr(\"title\", hint ? hint : null);\n  },\n  _renderContent: function _renderContent() {\n    var _this = this;\n    commonUtils.deferRender(function () {\n      if (_this._disposed) {\n        return;\n      }\n      return _this._renderContentImpl();\n    }).done(function () {\n      if (_this._disposed) {\n        return;\n      }\n      _this._fireContentReadyAction();\n    });\n  },\n  _renderContentImpl: commonUtils.noop,\n  _fireContentReadyAction: commonUtils.deferRenderer(function () {\n    this._contentReadyAction();\n  }),\n  _dispose: function _dispose() {\n    this._contentReadyAction = null;\n    this.callBase();\n  },\n  _resetActiveState: function _resetActiveState() {\n    this._toggleActiveState(this._eventBindingTarget(), false);\n  },\n  _clean: function _clean() {\n    this._cleanFocusState();\n    this._resetActiveState();\n    this.callBase();\n    this.$element().empty();\n  },\n  _toggleVisibility: function _toggleVisibility(visible) {\n    this.$element().toggleClass(INVISIBLE_STATE_CLASS, !visible);\n    this.setAria(\"hidden\", !visible || void 0);\n  },\n  _renderFocusState: function _renderFocusState() {\n    this._attachKeyboardEvents();\n    if (!this._isFocusable()) {\n      return;\n    }\n    this._renderFocusTarget();\n    this._attachFocusEvents();\n    this._renderAccessKey();\n  },\n  _renderAccessKey: function _renderAccessKey() {\n    var focusTarget = this._focusTarget();\n    focusTarget.attr(\"accesskey\", this.option(\"accessKey\"));\n    var clickNamespace = eventUtils.addNamespace(clickEvent.name, UI_FEEDBACK);\n    eventsEngine.off(focusTarget, clickNamespace);\n    this.option(\"accessKey\") && eventsEngine.on(focusTarget, clickNamespace, function (e) {\n      if (eventUtils.isFakeClickEvent(e)) {\n        e.stopImmediatePropagation();\n        this.focus();\n      }\n    }.bind(this));\n  },\n  _isFocusable: function _isFocusable() {\n    return this.option(\"focusStateEnabled\") && !this.option(\"disabled\");\n  },\n  _eventBindingTarget: function _eventBindingTarget() {\n    return this.$element();\n  },\n  _focusTarget: function _focusTarget() {\n    return this._getActiveElement();\n  },\n  _getActiveElement: function _getActiveElement() {\n    var activeElement = this._eventBindingTarget();\n    if (this._activeStateUnit) {\n      activeElement = activeElement.find(this._activeStateUnit).not(\".\" + DISABLED_STATE_CLASS);\n    }\n    return activeElement;\n  },\n  _renderFocusTarget: function _renderFocusTarget() {\n    this._focusTarget().attr(\"tabIndex\", this.option(\"tabIndex\"));\n  },\n  _keyboardEventBindingTarget: function _keyboardEventBindingTarget() {\n    return this._eventBindingTarget();\n  },\n  _detachFocusEvents: function _detachFocusEvents() {\n    var $element = this._focusEventTarget(),\n      namespace = this.NAME + FOCUS_NAMESPACE,\n      focusEvents = eventUtils.addNamespace(\"focusin\", namespace);\n    focusEvents = focusEvents + \" \" + eventUtils.addNamespace(\"focusout\", namespace);\n    if (domAdapter.hasDocumentProperty(\"onbeforeactivate\")) {\n      focusEvents = focusEvents + \" \" + eventUtils.addNamespace(\"beforeactivate\", namespace);\n    }\n    eventsEngine.off($element, focusEvents);\n  },\n  _attachFocusEvents: function _attachFocusEvents() {\n    var namespace = this.NAME + FOCUS_NAMESPACE,\n      focusInEvent = eventUtils.addNamespace(\"focusin\", namespace),\n      focusOutEvent = eventUtils.addNamespace(\"focusout\", namespace);\n    var $focusTarget = this._focusEventTarget();\n    eventsEngine.on($focusTarget, focusInEvent, this._focusInHandler.bind(this));\n    eventsEngine.on($focusTarget, focusOutEvent, this._focusOutHandler.bind(this));\n    if (domAdapter.hasDocumentProperty(\"onbeforeactivate\")) {\n      var beforeActivateEvent = eventUtils.addNamespace(\"beforeactivate\", namespace);\n      eventsEngine.on(this._focusEventTarget(), beforeActivateEvent, function (e) {\n        if (!$(e.target).is(selectors.focusable)) {\n          e.preventDefault();\n        }\n      });\n    }\n  },\n  _refreshFocusEvent: function _refreshFocusEvent() {\n    this._detachFocusEvents();\n    this._attachFocusEvents();\n  },\n  _focusEventTarget: function _focusEventTarget() {\n    return this._focusTarget();\n  },\n  _focusInHandler: function _focusInHandler(e) {\n    if (e.isDefaultPrevented()) {\n      return;\n    }\n    var that = this;\n    that._createActionByOption(\"onFocusIn\", {\n      beforeExecute: function beforeExecute() {\n        that._updateFocusState(e, true);\n      },\n      excludeValidators: [\"readOnly\"]\n    })({\n      event: e\n    });\n  },\n  _focusOutHandler: function _focusOutHandler(e) {\n    if (e.isDefaultPrevented()) {\n      return;\n    }\n    var that = this;\n    that._createActionByOption(\"onFocusOut\", {\n      beforeExecute: function beforeExecute() {\n        that._updateFocusState(e, false);\n      },\n      excludeValidators: [\"readOnly\", \"disabled\"]\n    })({\n      event: e\n    });\n  },\n  _updateFocusState: function _updateFocusState(e, isFocused) {\n    var target = e.target;\n    if (inArray(target, this._focusTarget()) !== -1) {\n      this._toggleFocusClass(isFocused, $(target));\n    }\n  },\n  _toggleFocusClass: function _toggleFocusClass(isFocused, $element) {\n    var $focusTarget = $element && $element.length ? $element : this._focusTarget();\n    $focusTarget.toggleClass(FOCUSED_STATE_CLASS, isFocused);\n  },\n  _hasFocusClass: function _hasFocusClass(element) {\n    var $focusTarget = $(element || this._focusTarget());\n    return $focusTarget.hasClass(FOCUSED_STATE_CLASS);\n  },\n  _isFocused: function _isFocused() {\n    return this._hasFocusClass();\n  },\n  _attachKeyboardEvents: function _attachKeyboardEvents() {\n    var processor = this.option(\"_keyboardProcessor\");\n    if (processor) {\n      this._keyboardProcessor = processor.reinitialize(this._keyboardHandler, this);\n    } else {\n      if (this.option(\"focusStateEnabled\")) {\n        this._disposeKeyboardProcessor();\n        this._keyboardProcessor = new KeyboardProcessor({\n          element: this._keyboardEventBindingTarget(),\n          handler: this._keyboardHandler,\n          focusTarget: this._focusTarget(),\n          context: this\n        });\n      }\n    }\n  },\n  _keyboardHandler: function _keyboardHandler(options) {\n    var e = options.originalEvent;\n    var keyName = options.keyName;\n    var keyCode = options.which;\n    var keys = this._supportedKeys(e),\n      func = keys[keyName] || keys[keyCode];\n    if (void 0 !== func) {\n      var handler = func.bind(this);\n      return handler(e) || false;\n    } else {\n      return true;\n    }\n  },\n  _refreshFocusState: function _refreshFocusState() {\n    this._cleanFocusState();\n    this._renderFocusState();\n  },\n  _cleanFocusState: function _cleanFocusState() {\n    var $element = this._focusTarget();\n    this._detachFocusEvents();\n    this._toggleFocusClass(false);\n    $element.removeAttr(\"tabIndex\");\n    this._disposeKeyboardProcessor();\n  },\n  _disposeKeyboardProcessor: function _disposeKeyboardProcessor() {\n    if (this._keyboardProcessor) {\n      this._keyboardProcessor.dispose();\n      delete this._keyboardProcessor;\n    }\n  },\n  _attachHoverEvents: function _attachHoverEvents() {\n    var that = this,\n      hoverableSelector = that._activeStateUnit,\n      nameStart = eventUtils.addNamespace(hoverEvents.start, UI_FEEDBACK),\n      nameEnd = eventUtils.addNamespace(hoverEvents.end, UI_FEEDBACK);\n    eventsEngine.off(that._eventBindingTarget(), nameStart, hoverableSelector);\n    eventsEngine.off(that._eventBindingTarget(), nameEnd, hoverableSelector);\n    if (that.option(\"hoverStateEnabled\")) {\n      var startAction = new Action(function (args) {\n        that._hoverStartHandler(args.event);\n        that._refreshHoveredElement($(args.element));\n      }, {\n        excludeValidators: [\"readOnly\"]\n      });\n      var $eventBindingTarget = that._eventBindingTarget();\n      eventsEngine.on($eventBindingTarget, nameStart, hoverableSelector, function (e) {\n        startAction.execute({\n          element: $(e.target),\n          event: e\n        });\n      });\n      eventsEngine.on($eventBindingTarget, nameEnd, hoverableSelector, function (e) {\n        that._hoverEndHandler(e);\n        that._forgetHoveredElement();\n      });\n    } else {\n      that._toggleHoverClass(false);\n    }\n  },\n  _hoverStartHandler: commonUtils.noop,\n  _hoverEndHandler: commonUtils.noop,\n  _attachFeedbackEvents: function _attachFeedbackEvents() {\n    var feedbackAction,\n      feedbackActionDisabled,\n      that = this,\n      feedbackSelector = that._activeStateUnit,\n      activeEventName = eventUtils.addNamespace(feedbackEvents.active, UI_FEEDBACK),\n      inactiveEventName = eventUtils.addNamespace(feedbackEvents.inactive, UI_FEEDBACK);\n    eventsEngine.off(that._eventBindingTarget(), activeEventName, feedbackSelector);\n    eventsEngine.off(that._eventBindingTarget(), inactiveEventName, feedbackSelector);\n    if (that.option(\"activeStateEnabled\")) {\n      var feedbackActionHandler = function feedbackActionHandler(args) {\n        var $element = $(args.element),\n          value = args.value,\n          dxEvent = args.event;\n        that._toggleActiveState($element, value, dxEvent);\n      };\n      eventsEngine.on(that._eventBindingTarget(), activeEventName, feedbackSelector, {\n        timeout: that._feedbackShowTimeout\n      }, function (e) {\n        feedbackAction = feedbackAction || new Action(feedbackActionHandler);\n        feedbackAction.execute({\n          element: $(e.currentTarget),\n          value: true,\n          event: e\n        });\n      });\n      eventsEngine.on(that._eventBindingTarget(), inactiveEventName, feedbackSelector, {\n        timeout: that._feedbackHideTimeout\n      }, function (e) {\n        feedbackActionDisabled = feedbackActionDisabled || new Action(feedbackActionHandler, {\n          excludeValidators: [\"disabled\", \"readOnly\"]\n        });\n        feedbackActionDisabled.execute({\n          element: $(e.currentTarget),\n          value: false,\n          event: e\n        });\n      });\n    }\n  },\n  _toggleActiveState: function _toggleActiveState($element, value) {\n    this._toggleHoverClass(!value);\n    $element.toggleClass(ACTIVE_STATE_CLASS, value);\n  },\n  _refreshHoveredElement: function _refreshHoveredElement(hoveredElement) {\n    var selector = this._activeStateUnit || this._eventBindingTarget();\n    this._forgetHoveredElement();\n    this._hoveredElement = hoveredElement.closest(selector);\n    this._toggleHoverClass(true);\n  },\n  _forgetHoveredElement: function _forgetHoveredElement() {\n    this._toggleHoverClass(false);\n    delete this._hoveredElement;\n  },\n  _toggleHoverClass: function _toggleHoverClass(value) {\n    if (this._hoveredElement) {\n      this._hoveredElement.toggleClass(HOVER_STATE_CLASS, value && this.option(\"hoverStateEnabled\"));\n    }\n  },\n  _toggleDisabledState: function _toggleDisabledState(value) {\n    this.$element().toggleClass(DISABLED_STATE_CLASS, Boolean(value));\n    this._toggleHoverClass(!value);\n    this.setAria(\"disabled\", value || void 0);\n  },\n  _setWidgetOption: function _setWidgetOption(widgetName, args) {\n    if (!this[widgetName]) {\n      return;\n    }\n    if (typeUtils.isPlainObject(args[0])) {\n      each(args[0], function (option, value) {\n        this._setWidgetOption(widgetName, [option, value]);\n      }.bind(this));\n      return;\n    }\n    var optionName = args[0];\n    var value = args[1];\n    if (1 === args.length) {\n      value = this.option(optionName);\n    }\n    var widgetOptionMap = this[widgetName + \"OptionMap\"];\n    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value);\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"disabled\":\n        this._toggleDisabledState(args.value);\n        this._refreshFocusState();\n        break;\n      case \"hint\":\n        this._renderHint();\n        break;\n      case \"activeStateEnabled\":\n        this._attachFeedbackEvents();\n        break;\n      case \"hoverStateEnabled\":\n        this._attachHoverEvents();\n        break;\n      case \"tabIndex\":\n      case \"_keyboardProcessor\":\n      case \"focusStateEnabled\":\n        this._refreshFocusState();\n        break;\n      case \"onFocusIn\":\n      case \"onFocusOut\":\n        break;\n      case \"accessKey\":\n        this._renderAccessKey();\n        break;\n      case \"visible\":\n        var visible = args.value;\n        this._toggleVisibility(visible);\n        if (this._isVisibilityChangeSupported()) {\n          this._checkVisibilityChanged(args.value ? \"shown\" : \"hiding\");\n        }\n        break;\n      case \"onContentReady\":\n        this._initContentReadyAction();\n        break;\n      default:\n        this.callBase(args);\n    }\n  },\n  _isVisible: function _isVisible() {\n    return this.callBase() && this.option(\"visible\");\n  },\n  beginUpdate: function beginUpdate() {\n    this._ready(false);\n    this.callBase();\n  },\n  endUpdate: function endUpdate() {\n    this.callBase();\n    if (this._initialized) {\n      this._ready(true);\n    }\n  },\n  _ready: function _ready(value) {\n    if (0 === arguments.length) {\n      return this._isReady;\n    }\n    this._isReady = value;\n  },\n  setAria: function setAria() {\n    var setAttribute = function setAttribute(option) {\n      var attrName = \"role\" === option.name || \"id\" === option.name ? option.name : \"aria-\" + option.name,\n        attrValue = option.value;\n      if (typeUtils.isDefined(attrValue)) {\n        attrValue = attrValue.toString();\n      } else {\n        attrValue = null;\n      }\n      option.target.attr(attrName, attrValue);\n    };\n    if (!typeUtils.isPlainObject(arguments[0])) {\n      setAttribute({\n        name: arguments[0],\n        value: arguments[1],\n        target: arguments[2] || this._getAriaTarget()\n      });\n    } else {\n      var $target = arguments[1] || this._getAriaTarget();\n      each(arguments[0], function (key, value) {\n        setAttribute({\n          name: key,\n          value: value,\n          target: $target\n        });\n      });\n    }\n  },\n  isReady: function isReady() {\n    return this._ready();\n  },\n  repaint: function repaint() {\n    this._refresh();\n  },\n  focus: function focus() {\n    eventsEngine.trigger(this._focusTarget(), \"focus\");\n  },\n  registerKeyHandler: function registerKeyHandler(key, handler) {\n    var currentKeys = this._supportedKeys(),\n      addingKeys = {};\n    addingKeys[key] = handler;\n    this._supportedKeys = function () {\n      return extend(currentKeys, addingKeys);\n    };\n  }\n});\nmodule.exports = Widget;","map":null,"metadata":{},"sourceType":"script"}