{"ast":null,"code":"/**\r\n * DevExtreme (ui/data_grid/ui.data_grid.grouping.expanded.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _data = require(\"../../core/utils/data\");\nvar _utils = require(\"../../data/utils\");\nvar _iterator = require(\"../../core/utils/iterator\");\nvar _extend = require(\"../../core/utils/extend\");\nvar _store_helper = require(\"../../data/store_helper\");\nvar _uiData_grid = require(\"./ui.data_grid.core\");\nvar _uiData_gridGrouping = require(\"./ui.data_grid.grouping.core\");\nvar _uiData_grid2 = require(\"./ui.data_grid.utils\");\nvar _query = require(\"../../data/query\");\nvar _query2 = _interopRequireDefault(_query);\nvar _deferred = require(\"../../core/utils/deferred\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar loadTotalCount = function loadTotalCount(dataSource, options) {\n  var d = new _deferred.Deferred(),\n    loadOptions = (0, _extend.extend)({\n      skip: 0,\n      take: 1,\n      requireTotalCount: true\n    }, options);\n  dataSource.load(loadOptions).done(function (data, extra) {\n    d.resolve(extra && extra.totalCount);\n  }).fail(d.reject.bind(d));\n  return d;\n};\nexports.GroupingHelper = _uiData_gridGrouping.GroupingHelper.inherit(function () {\n  var foreachCollapsedGroups = function foreachCollapsedGroups(that, callback, updateOffsets) {\n    return that.foreachGroups(function (groupInfo) {\n      if (!groupInfo.isExpanded) {\n        return callback(groupInfo);\n      }\n    }, false, false, updateOffsets, true);\n  };\n  var correctSkipLoadOption = function correctSkipLoadOption(that, skip) {\n    var skipCorrection = 0,\n      resultSkip = skip || 0;\n    if (skip) {\n      foreachCollapsedGroups(that, function (groupInfo) {\n        if (groupInfo.offset - skipCorrection >= skip) {\n          return false;\n        }\n        skipCorrection += groupInfo.count - 1;\n      });\n      resultSkip += skipCorrection;\n    }\n    return resultSkip;\n  };\n  var processGroupItems = function processGroupItems(that, items, path, offset, skipFirstItem, take) {\n    var i,\n      item,\n      offsetInfo,\n      removeLastItemsCount = 0,\n      needRemoveFirstItem = false;\n    for (i = 0; i < items.length; i++) {\n      item = items[i];\n      if (void 0 !== item.items) {\n        path.push(item.key);\n        var groupInfo = that.findGroupInfo(path);\n        if (groupInfo && !groupInfo.isExpanded) {\n          item.collapsedItems = item.items;\n          item.items = null;\n          offset += groupInfo.count;\n          take--;\n          if (take < 0) {\n            removeLastItemsCount++;\n          }\n          if (skipFirstItem) {\n            needRemoveFirstItem = true;\n          }\n        } else {\n          if (item.items) {\n            offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);\n            if (skipFirstItem) {\n              if (offsetInfo.offset - offset > 1) {\n                item.isContinuation = true;\n              } else {\n                needRemoveFirstItem = true;\n              }\n            }\n            offset = offsetInfo.offset;\n            take = offsetInfo.take;\n            if (take < 0) {\n              if (item.items.length) {\n                item.isContinuationOnNextPage = true;\n              } else {\n                removeLastItemsCount++;\n              }\n            }\n          }\n        }\n        path.pop();\n      } else {\n        if (skipFirstItem) {\n          needRemoveFirstItem = true;\n        }\n        offset++;\n        take--;\n        if (take < 0) {\n          removeLastItemsCount++;\n        }\n      }\n      skipFirstItem = false;\n    }\n    if (needRemoveFirstItem) {\n      items.splice(0, 1);\n    }\n    if (removeLastItemsCount) {\n      items.splice(-removeLastItemsCount, removeLastItemsCount);\n    }\n    return {\n      offset: offset,\n      take: take\n    };\n  };\n  var pathEquals = function pathEquals(path1, path2) {\n    var i;\n    if (path1.length !== path2.length) {\n      return false;\n    }\n    for (i = 0; i < path1.length; i++) {\n      if (!(0, _utils.keysEqual)(null, path1[i], path2[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n  var updateGroupOffsets = function updateGroupOffsets(that, items, path, offset, additionalGroupInfo) {\n    var i, item;\n    if (!items) {\n      return;\n    }\n    for (i = 0; i < items.length; i++) {\n      item = items[i];\n      if (\"key\" in item && void 0 !== item.items) {\n        path.push(item.key);\n        if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {\n          additionalGroupInfo.offset = offset;\n        }\n        var groupInfo = that.findGroupInfo(path);\n        if (groupInfo && !item.isContinuation) {\n          groupInfo.offset = offset;\n        }\n        if (groupInfo && !groupInfo.isExpanded) {\n          offset += groupInfo.count;\n        } else {\n          offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);\n        }\n        path.pop();\n      } else {\n        offset++;\n      }\n    }\n    return offset;\n  };\n  var removeGroupLoadOption = function removeGroupLoadOption(storeLoadOptions, loadOptions) {\n    var groups, sorts;\n    if (loadOptions.group) {\n      groups = (0, _uiData_grid.normalizeSortingInfo)(loadOptions.group);\n      sorts = (0, _uiData_grid.normalizeSortingInfo)(storeLoadOptions.sort);\n      storeLoadOptions.sort = (0, _store_helper.arrangeSortingInfo)(groups, sorts);\n      delete loadOptions.group;\n    }\n  };\n  var createNotGroupFilter = function createNotGroupFilter(path, storeLoadOptions, group) {\n    var i,\n      j,\n      filterElement,\n      groups = (0, _uiData_grid.normalizeSortingInfo)(group || storeLoadOptions.group),\n      filter = [];\n    for (i = 0; i < path.length; i++) {\n      filterElement = [];\n      for (j = 0; j <= i; j++) {\n        filterElement.push([groups[j].selector, i === j ? \"<>\" : \"=\", path[j]]);\n      }\n      filter.push((0, _uiData_grid.combineFilters)(filterElement));\n    }\n    filter = (0, _uiData_grid.combineFilters)(filter, \"or\");\n    return (0, _uiData_grid.combineFilters)([filter, storeLoadOptions.filter]);\n  };\n  var getGroupCount = function getGroupCount(item, groupCount) {\n    var i,\n      count = item.count || item.items.length;\n    if (!item.count && groupCount > 1) {\n      count = 0;\n      for (i = 0; i < item.items.length; i++) {\n        count += getGroupCount(item.items[i], groupCount - 1);\n      }\n    }\n    return count;\n  };\n  return {\n    handleDataLoading: function handleDataLoading(options) {\n      var loadOptions,\n        take,\n        that = this,\n        storeLoadOptions = options.storeLoadOptions,\n        collapsedGroups = [],\n        collapsedItemsCount = 0,\n        skipFirstItem = false,\n        group = options.loadOptions.group,\n        skipCorrection = 0;\n      removeGroupLoadOption(storeLoadOptions, options.loadOptions);\n      options.group = options.group || group;\n      if (options.isCustomLoading) {\n        return;\n      }\n      loadOptions = (0, _extend.extend)({}, storeLoadOptions);\n      loadOptions.skip = correctSkipLoadOption(that, storeLoadOptions.skip);\n      if (loadOptions.skip && loadOptions.take && group) {\n        loadOptions.skip--;\n        loadOptions.take++;\n        skipFirstItem = true;\n      }\n      if (loadOptions.take && group) {\n        take = loadOptions.take;\n        loadOptions.take++;\n      }\n      foreachCollapsedGroups(that, function (groupInfo) {\n        if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {\n          return false;\n        } else {\n          if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {\n            skipCorrection += groupInfo.count - 1;\n            collapsedGroups.push(groupInfo);\n            collapsedItemsCount += groupInfo.count;\n          }\n        }\n      });\n      (0, _iterator.each)(collapsedGroups, function () {\n        loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group);\n      });\n      options.storeLoadOptions = loadOptions;\n      options.collapsedGroups = collapsedGroups;\n      options.collapsedItemsCount = collapsedItemsCount;\n      options.skip = loadOptions.skip || 0;\n      options.skipFirstItem = skipFirstItem;\n      options.take = take;\n    },\n    handleDataLoaded: function handleDataLoaded(options, callBase) {\n      var pathIndex,\n        query,\n        that = this,\n        data = options.data,\n        collapsedGroups = options.collapsedGroups,\n        groups = (0, _uiData_grid.normalizeSortingInfo)(options.group),\n        groupCount = groups.length;\n      function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {\n        if (!data || !path.length || !groups.length) {\n          return;\n        }\n        var i,\n          keyValue,\n          pathValue = (0, _data.toComparable)(path[0], true);\n        for (i = 0; i < data.length; i++) {\n          keyValue = (0, _data.toComparable)(data[i].key, true);\n          if (offset >= collapsedGroup.offset || pathValue === keyValue) {\n            break;\n          } else {\n            offset += getGroupCount(data[i], groups.length);\n          }\n        }\n        if (!data.length || pathValue !== keyValue) {\n          data.splice(i, 0, {\n            key: path[0],\n            items: [],\n            count: 1 === path.length ? collapsedGroup.count : void 0\n          });\n        }\n        appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset);\n      }\n      if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {\n        options.extra.totalCount += options.collapsedItemsCount;\n      }\n      callBase(options);\n      if (groupCount) {\n        query = (0, _query2.default)(data);\n        (0, _store_helper.multiLevelGroup)(query, groups).enumerate().done(function (groupedData) {\n          data = groupedData;\n        });\n        if (collapsedGroups) {\n          for (pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {\n            appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip);\n          }\n        }\n        if (!options.isCustomLoading) {\n          processGroupItems(that, data, [], options.skip, options.skipFirstItem, options.take);\n        }\n        options.data = data;\n      }\n    },\n    isGroupItemCountable: function isGroupItemCountable(item) {\n      return null === item.items;\n    },\n    updateTotalItemsCount: function updateTotalItemsCount() {\n      var itemsCountCorrection = 0;\n      foreachCollapsedGroups(this, function (groupInfo) {\n        if (groupInfo.count) {\n          itemsCountCorrection -= groupInfo.count - 1;\n        }\n      });\n      this.callBase(itemsCountCorrection);\n    },\n    changeRowExpand: function changeRowExpand(path) {\n      var groupCountQuery,\n        that = this,\n        dataSource = that._dataSource,\n        beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex(),\n        dataSourceItems = dataSource.items(),\n        offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize()),\n        groupInfo = that.findGroupInfo(path);\n      if (groupInfo && !groupInfo.isExpanded) {\n        groupCountQuery = new _deferred.Deferred().resolve(groupInfo.count);\n      } else {\n        groupCountQuery = loadTotalCount(dataSource, {\n          filter: (0, _uiData_grid2.createGroupFilter)(path, {\n            filter: dataSource.filter(),\n            group: dataSource.group()\n          })\n        });\n      }\n      return (0, _deferred.when)(groupCountQuery).done(function (count) {\n        count = parseInt(count.length ? count[0] : count);\n        if (groupInfo) {\n          updateGroupOffsets(that, dataSourceItems, [], offset);\n          groupInfo.isExpanded = !groupInfo.isExpanded;\n          groupInfo.count = count;\n        } else {\n          groupInfo = {\n            offset: -1,\n            count: count,\n            path: path,\n            isExpanded: false\n          };\n          updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);\n          if (groupInfo.offset >= 0) {\n            that.addGroupInfo(groupInfo);\n          }\n        }\n        that.updateTotalItemsCount();\n      }).fail(function () {\n        dataSource.fireEvent(\"loadError\", arguments);\n      });\n    },\n    allowCollapseAll: function allowCollapseAll() {\n      return false;\n    },\n    refresh: function refresh(options, isReload, operationTypes) {\n      var that = this,\n        storeLoadOptions = options.storeLoadOptions,\n        dataSource = that._dataSource;\n      this.callBase.apply(this, arguments);\n      if (isReload || operationTypes.reload) {\n        return foreachCollapsedGroups(that, function (groupInfo) {\n          var groupCountQuery = loadTotalCount(dataSource, {\n              filter: (0, _uiData_grid2.createGroupFilter)(groupInfo.path, storeLoadOptions)\n            }),\n            groupOffsetQuery = loadTotalCount(dataSource, {\n              filter: (0, _uiData_gridGrouping.createOffsetFilter)(groupInfo.path, storeLoadOptions)\n            });\n          return (0, _deferred.when)(groupOffsetQuery, groupCountQuery).done(function (offset, count) {\n            offset = parseInt(offset.length ? offset[0] : offset);\n            count = parseInt(count.length ? count[0] : count);\n            groupInfo.offset = offset;\n            if (groupInfo.count !== count) {\n              groupInfo.count = count;\n              that.updateTotalItemsCount();\n            }\n          });\n        }, true);\n      }\n    }\n  };\n}());","map":null,"metadata":{},"sourceType":"script"}