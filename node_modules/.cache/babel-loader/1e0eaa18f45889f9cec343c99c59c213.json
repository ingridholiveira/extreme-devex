{"ast":null,"code":"/**\r\n * DevExtreme (core/utils/array.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar isDefined = require(\"./type\").isDefined,\n  each = require(\"./iterator\").each,\n  objectUtils = require(\"./object\"),\n  config = require(\"../config\");\nvar isEmpty = function isEmpty(entity) {\n  return Array.isArray(entity) && !entity.length;\n};\nvar wrapToArray = function wrapToArray(entity) {\n  return Array.isArray(entity) ? entity : [entity];\n};\nvar intersection = function intersection(a, b) {\n  if (!Array.isArray(a) || 0 === a.length || !Array.isArray(b) || 0 === b.length) {\n    return [];\n  }\n  var result = [];\n  each(a, function (_, value) {\n    var index = inArray(value, b);\n    if (index !== -1) {\n      result.push(value);\n    }\n  });\n  return result;\n};\nvar removeDuplicates = function removeDuplicates(from, what) {\n  if (!Array.isArray(from) || 0 === from.length) {\n    return [];\n  }\n  if (!Array.isArray(what) || 0 === what.length) {\n    return from.slice();\n  }\n  var result = [];\n  each(from, function (_, value) {\n    var index = inArray(value, what);\n    if (index === -1) {\n      result.push(value);\n    }\n  });\n  return result;\n};\nvar normalizeIndexes = function normalizeIndexes(items, indexParameterName, currentItem, needIndexCallback) {\n  var indexedItems = {},\n    parameterIndex = 0,\n    useLegacyVisibleIndex = config().useLegacyVisibleIndex;\n  each(items, function (index, item) {\n    index = item[indexParameterName];\n    if (index >= 0) {\n      indexedItems[index] = indexedItems[index] || [];\n      if (item === currentItem) {\n        indexedItems[index].unshift(item);\n      } else {\n        indexedItems[index].push(item);\n      }\n    } else {\n      item[indexParameterName] = void 0;\n    }\n  });\n  if (!useLegacyVisibleIndex) {\n    each(items, function () {\n      if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {\n        while (indexedItems[parameterIndex]) {\n          parameterIndex++;\n        }\n        indexedItems[parameterIndex] = [this];\n        parameterIndex++;\n      }\n    });\n  }\n  parameterIndex = 0;\n  objectUtils.orderEach(indexedItems, function (index, items) {\n    each(items, function () {\n      if (index >= 0) {\n        this[indexParameterName] = parameterIndex++;\n      }\n    });\n  });\n  if (useLegacyVisibleIndex) {\n    each(items, function () {\n      if (!isDefined(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {\n        this[indexParameterName] = parameterIndex++;\n      }\n    });\n  }\n  return parameterIndex;\n};\nvar inArray = function inArray(value, object) {\n  if (!object) {\n    return -1;\n  }\n  var array = Array.isArray(object) ? object : object.toArray();\n  return array.indexOf(value);\n};\nvar merge = function merge(array1, array2) {\n  for (var i = 0; i < array2.length; i++) {\n    array1[array1.length] = array2[i];\n  }\n  return array1;\n};\nvar find = function find(array, condition) {\n  for (var i = 0; i < array.length; i++) {\n    if (condition(array[i])) {\n      return array[i];\n    }\n  }\n};\nexports.isEmpty = isEmpty;\nexports.wrapToArray = wrapToArray;\nexports.intersection = intersection;\nexports.removeDuplicates = removeDuplicates;\nexports.normalizeIndexes = normalizeIndexes;\nexports.inArray = inArray;\nexports.merge = merge;\nexports.find = find;","map":null,"metadata":{},"sourceType":"script"}