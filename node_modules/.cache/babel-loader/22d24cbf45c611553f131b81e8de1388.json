{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.scrollable.simulated.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\nvar _renderer2 = _interopRequireDefault(_renderer);\nvar _dom_adapter = require(\"../../core/dom_adapter\");\nvar _dom_adapter2 = _interopRequireDefault(_dom_adapter);\nvar _events_engine = require(\"../../events/core/events_engine\");\nvar _events_engine2 = _interopRequireDefault(_events_engine);\nvar _inflector = require(\"../../core/utils/inflector\");\nvar _extend = require(\"../../core/utils/extend\");\nvar _window = require(\"../../core/utils/window\");\nvar _iterator = require(\"../../core/utils/iterator\");\nvar _type = require(\"../../core/utils/type\");\nvar _translator = require(\"../../animation/translator\");\nvar _translator2 = _interopRequireDefault(_translator);\nvar _class = require(\"../../core/class\");\nvar _class2 = _interopRequireDefault(_class);\nvar _animator = require(\"./animator\");\nvar _animator2 = _interopRequireDefault(_animator);\nvar _devices = require(\"../../core/devices\");\nvar _devices2 = _interopRequireDefault(_devices);\nvar _utils = require(\"../../events/utils\");\nvar _common = require(\"../../core/utils/common\");\nvar _ui = require(\"./ui.scrollbar\");\nvar _ui2 = _interopRequireDefault(_ui);\nvar _deferred = require(\"../../core/utils/deferred\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar realDevice = _devices2.default.real;\nvar isSluggishPlatform = \"android\" === realDevice.platform;\nvar SCROLLABLE_SIMULATED = \"dxSimulatedScrollable\";\nvar SCROLLABLE_STRATEGY = \"dxScrollableStrategy\";\nvar SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + \"Cursor\";\nvar SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + \"Keyboard\";\nvar SCROLLABLE_SIMULATED_CLASS = \"dx-scrollable-simulated\";\nvar SCROLLABLE_SCROLLBARS_HIDDEN = \"dx-scrollable-scrollbars-hidden\";\nvar SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = \"dx-scrollable-scrollbars-alwaysvisible\";\nvar SCROLLABLE_SCROLLBAR_CLASS = \"dx-scrollable-scrollbar\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar ACCELERATION = isSluggishPlatform ? .95 : .92;\nvar OUT_BOUNDS_ACCELERATION = .5;\nvar MIN_VELOCITY_LIMIT = 1;\nvar FRAME_DURATION = Math.round(1e3 / 60);\nvar SCROLL_LINE_HEIGHT = 20;\nvar VALIDATE_WHEEL_TIMEOUT = 500;\nvar BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5;\nvar BOUNCE_DURATION = isSluggishPlatform ? 300 : 400;\nvar BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION;\nvar BOUNCE_ACCELERATION_SUM = (1 - Math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);\nvar KEY_CODES = {\n  PAGE_UP: \"pageUp\",\n  PAGE_DOWN: \"pageDown\",\n  END: \"end\",\n  HOME: \"home\",\n  LEFT: \"leftArrow\",\n  UP: \"upArrow\",\n  RIGHT: \"rightArrow\",\n  DOWN: \"downArrow\",\n  TAB: \"tab\"\n};\nvar InertiaAnimator = _animator2.default.inherit({\n  ctor: function ctor(scroller) {\n    this.callBase();\n    this.scroller = scroller;\n  },\n  VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,\n  _isFinished: function _isFinished() {\n    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;\n  },\n  _step: function _step() {\n    this.scroller._scrollStep(this.scroller._velocity);\n    this.scroller._velocity *= this._acceleration();\n  },\n  _acceleration: function _acceleration() {\n    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION;\n  },\n  _complete: function _complete() {\n    this.scroller._scrollComplete();\n  },\n  _stop: function _stop() {\n    this.scroller._stopComplete();\n  }\n});\nvar BounceAnimator = InertiaAnimator.inherit({\n  VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,\n  _isFinished: function _isFinished() {\n    return this.scroller._crossBoundOnNextStep() || this.callBase();\n  },\n  _acceleration: function _acceleration() {\n    return ACCELERATION;\n  },\n  _complete: function _complete() {\n    this.scroller._move(this.scroller._bounceLocation);\n    this.callBase();\n  }\n});\nvar Scroller = _class2.default.inherit({\n  ctor: function ctor(options) {\n    this._initOptions(options);\n    this._initAnimators();\n    this._initScrollbar();\n  },\n  _initOptions: function _initOptions(options) {\n    var _this = this;\n    this._location = 0;\n    this._topReached = false;\n    this._bottomReached = false;\n    this._axis = options.direction === HORIZONTAL ? \"x\" : \"y\";\n    this._prop = options.direction === HORIZONTAL ? \"left\" : \"top\";\n    this._dimension = options.direction === HORIZONTAL ? \"width\" : \"height\";\n    this._scrollProp = options.direction === HORIZONTAL ? \"scrollLeft\" : \"scrollTop\";\n    (0, _iterator.each)(options, function (optionName, optionValue) {\n      _this[\"_\" + optionName] = optionValue;\n    });\n  },\n  _initAnimators: function _initAnimators() {\n    this._inertiaAnimator = new InertiaAnimator(this);\n    this._bounceAnimator = new BounceAnimator(this);\n  },\n  _initScrollbar: function _initScrollbar() {\n    this._scrollbar = new _ui2.default((0, _renderer2.default)(\"<div>\").appendTo(this._$container), {\n      direction: this._direction,\n      visible: this._scrollByThumb,\n      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),\n      expandable: this._scrollByThumb\n    });\n    this._$scrollbar = this._scrollbar.$element();\n  },\n  _visibilityModeNormalize: function _visibilityModeNormalize(mode) {\n    return true === mode ? \"onScroll\" : false === mode ? \"never\" : mode;\n  },\n  _scrollStep: function _scrollStep(delta) {\n    var prevLocation = this._location;\n    this._location += delta;\n    this._suppressBounce();\n    this._move();\n    if (Math.abs(prevLocation - this._location) < 1) {\n      return;\n    }\n    _events_engine2.default.triggerHandler(this._$container, {\n      type: \"scroll\"\n    });\n  },\n  _suppressBounce: function _suppressBounce() {\n    if (this._bounceEnabled || this._inBounds(this._location)) {\n      return;\n    }\n    this._velocity = 0;\n    this._location = this._boundLocation();\n  },\n  _boundLocation: function _boundLocation(location) {\n    location = void 0 !== location ? location : this._location;\n    return Math.max(Math.min(location, this._maxOffset), this._minOffset);\n  },\n  _move: function _move(location) {\n    this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;\n    this._moveContent();\n    this._moveScrollbar();\n  },\n  _moveContent: function _moveContent() {\n    var location = this._location;\n    this._$container[this._scrollProp](-location / this._getScaleRatio());\n    this._moveContentByTranslator(location);\n  },\n  _getScaleRatio: function _getScaleRatio() {\n    if ((0, _window.hasWindow)() && !this._scaleRatio) {\n      var element = this._$element.get(0);\n      var realDimension = this._getRealDimension(element, this._dimension);\n      var baseDimension = this._getBaseDimension(element, this._dimension);\n      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;\n    }\n    return this._scaleRatio || 1;\n  },\n  _getRealDimension: function _getRealDimension(element, dimension) {\n    return Math.round(element.getBoundingClientRect()[dimension]);\n  },\n  _getBaseDimension: function _getBaseDimension(element, dimension) {\n    var dimensionName = \"offset\" + (0, _inflector.titleize)(dimension);\n    return element[dimensionName];\n  },\n  _moveContentByTranslator: function _moveContentByTranslator(location) {\n    var translateOffset = void 0;\n    var minOffset = -this._maxScrollPropValue;\n    if (location > 0) {\n      translateOffset = location;\n    } else {\n      if (location <= minOffset) {\n        translateOffset = location - minOffset;\n      } else {\n        translateOffset = location % 1;\n      }\n    }\n    if (this._translateOffset === translateOffset) {\n      return;\n    }\n    var targetLocation = {};\n    targetLocation[this._prop] = translateOffset;\n    this._translateOffset = translateOffset;\n    if (0 === translateOffset) {\n      _translator2.default.resetPosition(this._$content);\n      return;\n    }\n    _translator2.default.move(this._$content, targetLocation);\n  },\n  _moveScrollbar: function _moveScrollbar() {\n    this._scrollbar.moveTo(this._location);\n  },\n  _scrollComplete: function _scrollComplete() {\n    if (this._inBounds()) {\n      this._hideScrollbar();\n      if (this._completeDeferred) {\n        this._completeDeferred.resolve();\n      }\n    }\n    this._scrollToBounds();\n  },\n  _scrollToBounds: function _scrollToBounds() {\n    if (this._inBounds()) {\n      return;\n    }\n    this._bounceAction();\n    this._setupBounce();\n    this._bounceAnimator.start();\n  },\n  _setupBounce: function _setupBounce() {\n    var boundLocation = this._bounceLocation = this._boundLocation();\n    var bounceDistance = boundLocation - this._location;\n    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;\n  },\n  _inBounds: function _inBounds(location) {\n    location = void 0 !== location ? location : this._location;\n    return this._boundLocation(location) === location;\n  },\n  _crossBoundOnNextStep: function _crossBoundOnNextStep() {\n    var location = this._location;\n    var nextLocation = location + this._velocity;\n    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;\n  },\n  _initHandler: function _initHandler(e) {\n    this._stopDeferred = new _deferred.Deferred();\n    this._stopScrolling();\n    this._prepareThumbScrolling(e);\n    return this._stopDeferred.promise();\n  },\n  _stopScrolling: (0, _common.deferRenderer)(function () {\n    this._hideScrollbar();\n    this._inertiaAnimator.stop();\n    this._bounceAnimator.stop();\n  }),\n  _prepareThumbScrolling: function _prepareThumbScrolling(e) {\n    if ((0, _utils.isDxMouseWheelEvent)(e.originalEvent)) {\n      return;\n    }\n    var $target = (0, _renderer2.default)(e.originalEvent.target);\n    var scrollbarClicked = this._isScrollbar($target);\n    if (scrollbarClicked) {\n      this._moveToMouseLocation(e);\n    }\n    this._thumbScrolling = scrollbarClicked || this._isThumb($target);\n    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);\n    if (this._thumbScrolling) {\n      this._scrollbar.feedbackOn();\n    }\n  },\n  _isThumbScrollingHandler: function _isThumbScrollingHandler($target) {\n    return this._isThumb($target);\n  },\n  _moveToMouseLocation: function _moveToMouseLocation(e) {\n    var mouseLocation = e[\"page\" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];\n    var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;\n    this._scrollStep(-Math.round(location));\n  },\n  _stopComplete: function _stopComplete() {\n    if (this._stopDeferred) {\n      this._stopDeferred.resolve();\n    }\n  },\n  _startHandler: function _startHandler() {\n    this._showScrollbar();\n  },\n  _moveHandler: function _moveHandler(delta) {\n    if (this._crossThumbScrolling) {\n      return;\n    }\n    if (this._thumbScrolling) {\n      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());\n    }\n    this._scrollBy(delta);\n  },\n  _scrollBy: function _scrollBy(delta) {\n    delta = delta[this._axis];\n    if (!this._inBounds()) {\n      delta *= OUT_BOUNDS_ACCELERATION;\n    }\n    this._scrollStep(delta);\n  },\n  _scrollByHandler: function _scrollByHandler(delta) {\n    this._scrollBy(delta);\n    this._scrollComplete();\n  },\n  _containerToContentRatio: function _containerToContentRatio() {\n    return this._scrollbar.containerToContentRatio();\n  },\n  _endHandler: function _endHandler(velocity) {\n    this._completeDeferred = new _deferred.Deferred();\n    this._velocity = velocity[this._axis];\n    this._inertiaHandler();\n    this._resetThumbScrolling();\n    return this._completeDeferred.promise();\n  },\n  _inertiaHandler: function _inertiaHandler() {\n    this._suppressInertia();\n    this._inertiaAnimator.start();\n  },\n  _suppressInertia: function _suppressInertia() {\n    if (!this._inertiaEnabled || this._thumbScrolling) {\n      this._velocity = 0;\n    }\n  },\n  _resetThumbScrolling: function _resetThumbScrolling() {\n    this._thumbScrolling = false;\n    this._crossThumbScrolling = false;\n  },\n  _stopHandler: function _stopHandler() {\n    if (this._thumbScrolling) {\n      this._scrollComplete();\n    }\n    this._resetThumbScrolling();\n    this._scrollToBounds();\n  },\n  _disposeHandler: function _disposeHandler() {\n    this._stopScrolling();\n    this._$scrollbar.remove();\n  },\n  _updateHandler: function _updateHandler() {\n    this._update();\n    this._moveToBounds();\n  },\n  _update: function _update() {\n    var _this2 = this;\n    this._stopScrolling();\n    return (0, _common.deferUpdate)(function () {\n      _this2._resetScaleRatio();\n      _this2._updateLocation();\n      _this2._updateBounds();\n      _this2._updateScrollbar();\n      (0, _common.deferRender)(function () {\n        _this2._moveScrollbar();\n        _this2._scrollbar.update();\n      });\n    });\n  },\n  _resetScaleRatio: function _resetScaleRatio() {\n    this._scaleRatio = null;\n  },\n  _updateLocation: function _updateLocation() {\n    this._location = (_translator2.default.locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();\n  },\n  _updateBounds: function _updateBounds() {\n    this._maxOffset = Math.round(this._getMaxOffset());\n    this._minOffset = Math.round(this._getMinOffset());\n  },\n  _getMaxOffset: function _getMaxOffset() {\n    return 0;\n  },\n  _getMinOffset: function _getMinOffset() {\n    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);\n    return -this._maxScrollPropValue;\n  },\n  _updateScrollbar: (0, _common.deferUpdater)(function () {\n    var _this3 = this;\n    var containerSize = this._containerSize();\n    var contentSize = this._contentSize();\n    var baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);\n    var baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);\n    (0, _common.deferRender)(function () {\n      _this3._scrollbar.option({\n        containerSize: containerSize,\n        contentSize: contentSize,\n        baseContainerSize: baseContainerSize,\n        baseContentSize: baseContentSize,\n        scaleRatio: _this3._getScaleRatio()\n      });\n    });\n  }),\n  _moveToBounds: (0, _common.deferRenderer)((0, _common.deferUpdater)((0, _common.deferRenderer)(function () {\n    var location = this._boundLocation();\n    var locationChanged = location !== this._location;\n    this._location = location;\n    this._move();\n    if (locationChanged) {\n      this._scrollAction();\n    }\n  }))),\n  _createActionsHandler: function _createActionsHandler(actions) {\n    this._scrollAction = actions.scroll;\n    this._bounceAction = actions.bounce;\n  },\n  _showScrollbar: function _showScrollbar() {\n    this._scrollbar.option(\"visible\", true);\n  },\n  _hideScrollbar: function _hideScrollbar() {\n    this._scrollbar.option(\"visible\", false);\n  },\n  _containerSize: function _containerSize() {\n    return this._getRealDimension(this._$container.get(0), this._dimension);\n  },\n  _contentSize: function _contentSize() {\n    var isOverflowHidden = \"hidden\" === this._$content.css(\"overflow\" + this._axis.toUpperCase());\n    var contentSize = this._getRealDimension(this._$content.get(0), this._dimension);\n    if (!isOverflowHidden) {\n      var containerScrollSize = this._$content[0][\"scroll\" + (0, _inflector.titleize)(this._dimension)] * this._getScaleRatio();\n      contentSize = Math.max(containerScrollSize, contentSize);\n    }\n    return contentSize;\n  },\n  _validateEvent: function _validateEvent(e) {\n    var $target = (0, _renderer2.default)(e.originalEvent.target);\n    return this._isThumb($target) || this._isScrollbar($target) || this._isContent($target);\n  },\n  _isThumb: function _isThumb($element) {\n    return this._scrollByThumb && this._scrollbar.isThumb($element);\n  },\n  _isScrollbar: function _isScrollbar($element) {\n    return this._scrollByThumb && $element && $element.is(this._$scrollbar);\n  },\n  _isContent: function _isContent($element) {\n    return this._scrollByContent && !!$element.closest(this._$element).length;\n  },\n  _reachedMin: function _reachedMin() {\n    return this._location <= this._minOffset;\n  },\n  _reachedMax: function _reachedMax() {\n    return this._location >= this._maxOffset;\n  },\n  _cursorEnterHandler: function _cursorEnterHandler() {\n    this._scrollbar.cursorEnter();\n  },\n  _cursorLeaveHandler: function _cursorLeaveHandler() {\n    this._scrollbar.cursorLeave();\n  },\n  dispose: _common.noop\n});\nvar hoveredScrollable, activeScrollable;\nvar SimulatedStrategy = _class2.default.inherit({\n  ctor: function ctor(scrollable) {\n    this._init(scrollable);\n  },\n  _init: function _init(scrollable) {\n    this._component = scrollable;\n    this._$element = scrollable.$element();\n    this._$container = scrollable._$container;\n    this._$wrapper = scrollable._$wrapper;\n    this._$content = scrollable._$content;\n    this.option = scrollable.option.bind(scrollable);\n    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);\n    this._isLocked = scrollable._isLocked.bind(scrollable);\n    this._isDirection = scrollable._isDirection.bind(scrollable);\n    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);\n  },\n  render: function render() {\n    this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);\n    this._createScrollers();\n    if (this.option(\"useKeyboard\")) {\n      this._$container.prop(\"tabIndex\", 0);\n    }\n    this._attachKeyboardHandler();\n    this._attachCursorHandlers();\n  },\n  _createScrollers: function _createScrollers() {\n    this._scrollers = {};\n    if (this._isDirection(HORIZONTAL)) {\n      this._createScroller(HORIZONTAL);\n    }\n    if (this._isDirection(VERTICAL)) {\n      this._createScroller(VERTICAL);\n    }\n    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, \"always\" === this.option(\"showScrollbar\"));\n    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this.option(\"showScrollbar\"));\n  },\n  _createScroller: function _createScroller(direction) {\n    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));\n  },\n  _scrollerOptions: function _scrollerOptions(direction) {\n    return {\n      direction: direction,\n      $content: this._$content,\n      $container: this._$container,\n      $wrapper: this._$wrapper,\n      $element: this._$element,\n      scrollByContent: this.option(\"scrollByContent\"),\n      scrollByThumb: this.option(\"scrollByThumb\"),\n      scrollbarVisible: this.option(\"showScrollbar\"),\n      bounceEnabled: this.option(\"bounceEnabled\"),\n      inertiaEnabled: this.option(\"inertiaEnabled\"),\n      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)\n    };\n  },\n  _applyScaleRatio: function _applyScaleRatio(targetLocation) {\n    for (var direction in this._scrollers) {\n      var prop = this._getPropByDirection(direction);\n      if ((0, _type.isDefined)(targetLocation[prop])) {\n        var scroller = this._scrollers[direction];\n        targetLocation[prop] *= scroller._getScaleRatio();\n      }\n    }\n    return targetLocation;\n  },\n  _isAnyThumbScrolling: function _isAnyThumbScrolling($target) {\n    var result = false;\n    this._eventHandler(\"isThumbScrolling\", $target).done(function (isThumbScrollingVertical, isThumbScrollingHorizontal) {\n      result = isThumbScrollingVertical || isThumbScrollingHorizontal;\n    });\n    return result;\n  },\n  handleInit: function handleInit(e) {\n    this._suppressDirections(e);\n    this._eventForUserAction = e;\n    this._eventHandler(\"init\", e).done(this._stopAction);\n  },\n  _suppressDirections: function _suppressDirections(e) {\n    if ((0, _utils.isDxMouseWheelEvent)(e.originalEvent)) {\n      this._prepareDirections(true);\n      return;\n    }\n    this._prepareDirections();\n    this._eachScroller(function (scroller, direction) {\n      var isValid = scroller._validateEvent(e);\n      this._validDirections[direction] = isValid;\n    });\n  },\n  _prepareDirections: function _prepareDirections(value) {\n    value = value || false;\n    this._validDirections = {};\n    this._validDirections[HORIZONTAL] = value;\n    this._validDirections[VERTICAL] = value;\n  },\n  _eachScroller: function _eachScroller(callback) {\n    callback = callback.bind(this);\n    (0, _iterator.each)(this._scrollers, function (direction, scroller) {\n      callback(scroller, direction);\n    });\n  },\n  handleStart: function handleStart(e) {\n    this._eventForUserAction = e;\n    this._eventHandler(\"start\").done(this._startAction);\n  },\n  _saveActive: function _saveActive() {\n    activeScrollable = this;\n  },\n  _resetActive: function _resetActive() {\n    if (activeScrollable === this) {\n      activeScrollable = null;\n    }\n  },\n  handleMove: function handleMove(e) {\n    if (this._isLocked()) {\n      e.cancel = true;\n      this._resetActive();\n      return;\n    }\n    this._saveActive();\n    e.preventDefault && e.preventDefault();\n    this._adjustDistance(e.delta);\n    this._eventForUserAction = e;\n    this._eventHandler(\"move\", e.delta);\n  },\n  _adjustDistance: function _adjustDistance(distance) {\n    distance.x *= this._validDirections[HORIZONTAL];\n    distance.y *= this._validDirections[VERTICAL];\n  },\n  handleEnd: function handleEnd(e) {\n    this._resetActive();\n    this._refreshCursorState(e.originalEvent && e.originalEvent.target);\n    this._adjustDistance(e.velocity);\n    this._eventForUserAction = e;\n    return this._eventHandler(\"end\", e.velocity).done(this._endAction);\n  },\n  handleCancel: function handleCancel(e) {\n    this._resetActive();\n    this._eventForUserAction = e;\n    return this._eventHandler(\"end\", {\n      x: 0,\n      y: 0\n    });\n  },\n  handleStop: function handleStop() {\n    this._resetActive();\n    this._eventHandler(\"stop\");\n  },\n  handleScroll: function handleScroll() {\n    this._scrollAction();\n  },\n  _attachKeyboardHandler: function _attachKeyboardHandler() {\n    _events_engine2.default.off(this._$element, \".\" + SCROLLABLE_SIMULATED_KEYBOARD);\n    if (!this.option(\"disabled\") && this.option(\"useKeyboard\")) {\n      _events_engine2.default.on(this._$element, (0, _utils.addNamespace)(\"keydown\", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));\n    }\n  },\n  _keyDownHandler: function _keyDownHandler(e) {\n    var _this4 = this;\n    clearTimeout(this._updateHandlerTimeout);\n    this._updateHandlerTimeout = setTimeout(function () {\n      if ((0, _utils.normalizeKeyName)(e) === KEY_CODES.TAB) {\n        _this4._eachScroller(function (scroller) {\n          scroller._updateHandler();\n        });\n      }\n    });\n    if (!this._$container.is(_dom_adapter2.default.getActiveElement())) {\n      return;\n    }\n    var handled = true;\n    switch ((0, _utils.normalizeKeyName)(e)) {\n      case KEY_CODES.DOWN:\n        this._scrollByLine({\n          y: 1\n        });\n        break;\n      case KEY_CODES.UP:\n        this._scrollByLine({\n          y: -1\n        });\n        break;\n      case KEY_CODES.RIGHT:\n        this._scrollByLine({\n          x: 1\n        });\n        break;\n      case KEY_CODES.LEFT:\n        this._scrollByLine({\n          x: -1\n        });\n        break;\n      case KEY_CODES.PAGE_DOWN:\n        this._scrollByPage(1);\n        break;\n      case KEY_CODES.PAGE_UP:\n        this._scrollByPage(-1);\n        break;\n      case KEY_CODES.HOME:\n        this._scrollToHome();\n        break;\n      case KEY_CODES.END:\n        this._scrollToEnd();\n        break;\n      default:\n        handled = false;\n    }\n    if (handled) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  },\n  _scrollByLine: function _scrollByLine(lines) {\n    this.scrollBy({\n      top: (lines.y || 0) * -SCROLL_LINE_HEIGHT,\n      left: (lines.x || 0) * -SCROLL_LINE_HEIGHT\n    });\n  },\n  _scrollByPage: function _scrollByPage(page) {\n    var prop = this._wheelProp();\n    var dimension = this._dimensionByProp(prop);\n    var distance = {};\n    distance[prop] = page * -this._$container[dimension]();\n    this.scrollBy(distance);\n  },\n  _dimensionByProp: function _dimensionByProp(prop) {\n    return \"left\" === prop ? \"width\" : \"height\";\n  },\n  _getPropByDirection: function _getPropByDirection(direction) {\n    return direction === HORIZONTAL ? \"left\" : \"top\";\n  },\n  _scrollToHome: function _scrollToHome() {\n    var prop = this._wheelProp();\n    var distance = {};\n    distance[prop] = 0;\n    this._component.scrollTo(distance);\n  },\n  _scrollToEnd: function _scrollToEnd() {\n    var prop = this._wheelProp();\n    var dimension = this._dimensionByProp(prop);\n    var distance = {};\n    distance[prop] = this._$content[dimension]() - this._$container[dimension]();\n    this._component.scrollTo(distance);\n  },\n  createActions: function createActions() {\n    this._startAction = this._createActionHandler(\"onStart\");\n    this._stopAction = this._createActionHandler(\"onStop\");\n    this._endAction = this._createActionHandler(\"onEnd\");\n    this._updateAction = this._createActionHandler(\"onUpdated\");\n    this._createScrollerActions();\n  },\n  _createScrollerActions: function _createScrollerActions() {\n    this._scrollAction = this._createActionHandler(\"onScroll\");\n    this._bounceAction = this._createActionHandler(\"onBounce\");\n    this._eventHandler(\"createActions\", {\n      scroll: this._scrollAction,\n      bounce: this._bounceAction\n    });\n  },\n  _createActionHandler: function _createActionHandler(optionName) {\n    var _this5 = this,\n      _arguments = arguments;\n    var actionHandler = this._createActionByOption(optionName);\n    return function () {\n      actionHandler((0, _extend.extend)(_this5._createActionArgs(), _arguments));\n    };\n  },\n  _createActionArgs: function _createActionArgs() {\n    var scrollerX = this._scrollers[HORIZONTAL];\n    var scrollerY = this._scrollers[VERTICAL];\n    var location = this.location();\n    this._scrollOffset = {\n      top: scrollerY && -location.top,\n      left: scrollerX && -location.left\n    };\n    return {\n      event: this._eventForUserAction,\n      scrollOffset: this._scrollOffset,\n      reachedLeft: scrollerX && scrollerX._reachedMax(),\n      reachedRight: scrollerX && scrollerX._reachedMin(),\n      reachedTop: scrollerY && scrollerY._reachedMax(),\n      reachedBottom: scrollerY && scrollerY._reachedMin()\n    };\n  },\n  _eventHandler: function _eventHandler(eventName) {\n    var args = [].slice.call(arguments).slice(1);\n    var deferreds = (0, _iterator.map)(this._scrollers, function (scroller) {\n      return scroller[\"_\" + eventName + \"Handler\"].apply(scroller, args);\n    });\n    return _deferred.when.apply(_renderer2.default, deferreds).promise();\n  },\n  location: function location() {\n    var location = _translator2.default.locate(this._$content);\n    location.top -= this._$container.scrollTop();\n    location.left -= this._$container.scrollLeft();\n    return location;\n  },\n  disabledChanged: function disabledChanged() {\n    this._attachCursorHandlers();\n  },\n  _attachCursorHandlers: function _attachCursorHandlers() {\n    _events_engine2.default.off(this._$element, \".\" + SCROLLABLE_SIMULATED_CURSOR);\n    if (!this.option(\"disabled\") && this._isHoverMode()) {\n      _events_engine2.default.on(this._$element, (0, _utils.addNamespace)(\"mouseenter\", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));\n      _events_engine2.default.on(this._$element, (0, _utils.addNamespace)(\"mouseleave\", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));\n    }\n  },\n  _isHoverMode: function _isHoverMode() {\n    return \"onHover\" === this.option(\"showScrollbar\");\n  },\n  _cursorEnterHandler: function _cursorEnterHandler(e) {\n    e = e || {};\n    e.originalEvent = e.originalEvent || {};\n    if (activeScrollable || e.originalEvent._hoverHandled) {\n      return;\n    }\n    if (hoveredScrollable) {\n      hoveredScrollable._cursorLeaveHandler();\n    }\n    hoveredScrollable = this;\n    this._eventHandler(\"cursorEnter\");\n    e.originalEvent._hoverHandled = true;\n  },\n  _cursorLeaveHandler: function _cursorLeaveHandler(e) {\n    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {\n      return;\n    }\n    this._eventHandler(\"cursorLeave\");\n    hoveredScrollable = null;\n    this._refreshCursorState(e && e.relatedTarget);\n  },\n  _refreshCursorState: function _refreshCursorState(target) {\n    if (!this._isHoverMode() && (!target || activeScrollable)) {\n      return;\n    }\n    var $target = (0, _renderer2.default)(target);\n    var $scrollable = $target.closest(\".\" + SCROLLABLE_SIMULATED_CLASS + \":not(.dx-state-disabled)\");\n    var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);\n    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {\n      hoveredScrollable._cursorLeaveHandler();\n    }\n    if (targetScrollable) {\n      targetScrollable._cursorEnterHandler();\n    }\n  },\n  update: function update() {\n    var _this6 = this;\n    var result = this._eventHandler(\"update\").done(this._updateAction);\n    return (0, _deferred.when)(result, (0, _common.deferUpdate)(function () {\n      var allowedDirections = _this6._allowedDirections();\n      (0, _common.deferRender)(function () {\n        var touchDirection = allowedDirections.vertical ? \"pan-x\" : \"\";\n        touchDirection = allowedDirections.horizontal ? \"pan-y\" : touchDirection;\n        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? \"none\" : touchDirection;\n        _this6._$container.css(\"touchAction\", touchDirection);\n      });\n      return (0, _deferred.when)().promise();\n    }));\n  },\n  _allowedDirections: function _allowedDirections() {\n    var bounceEnabled = this.option(\"bounceEnabled\");\n    var verticalScroller = this._scrollers[VERTICAL];\n    var horizontalScroller = this._scrollers[HORIZONTAL];\n    return {\n      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),\n      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)\n    };\n  },\n  updateBounds: function updateBounds() {\n    this._scrollers[HORIZONTAL] && this._scrollers[HORIZONTAL]._updateBounds();\n  },\n  scrollBy: function scrollBy(distance) {\n    var verticalScroller = this._scrollers[VERTICAL];\n    var horizontalScroller = this._scrollers[HORIZONTAL];\n    if (verticalScroller) {\n      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;\n    }\n    if (horizontalScroller) {\n      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;\n    }\n    this._prepareDirections(true);\n    this._startAction();\n    this._eventHandler(\"scrollBy\", {\n      x: distance.left,\n      y: distance.top\n    });\n    this._endAction();\n  },\n  validate: function validate(e) {\n    if (this.option(\"disabled\")) {\n      return false;\n    }\n    if (this.option(\"bounceEnabled\")) {\n      return true;\n    }\n    return (0, _utils.isDxMouseWheelEvent)(e) ? this._validateWheel(e) : this._validateMove(e);\n  },\n  _validateWheel: function _validateWheel(e) {\n    var _this7 = this;\n    var scroller = this._scrollers[this._wheelDirection(e)];\n    var reachedMin = scroller._reachedMin();\n    var reachedMax = scroller._reachedMax();\n    var contentGreaterThanContainer = !reachedMin || !reachedMax;\n    var locatedNotAtBound = !reachedMin && !reachedMax;\n    var scrollFromMin = reachedMin && e.delta > 0;\n    var scrollFromMax = reachedMax && e.delta < 0;\n    var validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);\n    validated = validated || void 0 !== this._validateWheelTimer;\n    if (validated) {\n      clearTimeout(this._validateWheelTimer);\n      this._validateWheelTimer = setTimeout(function () {\n        _this7._validateWheelTimer = void 0;\n      }, VALIDATE_WHEEL_TIMEOUT);\n    }\n    return validated;\n  },\n  _validateMove: function _validateMove(e) {\n    if (!this.option(\"scrollByContent\") && !(0, _renderer2.default)(e.target).closest(\".\" + SCROLLABLE_SCROLLBAR_CLASS).length) {\n      return false;\n    }\n    return this._allowedDirection();\n  },\n  getDirection: function getDirection(e) {\n    return (0, _utils.isDxMouseWheelEvent)(e) ? this._wheelDirection(e) : this._allowedDirection();\n  },\n  _wheelProp: function _wheelProp() {\n    return this._wheelDirection() === HORIZONTAL ? \"left\" : \"top\";\n  },\n  _wheelDirection: function _wheelDirection(e) {\n    switch (this.option(\"direction\")) {\n      case HORIZONTAL:\n        return HORIZONTAL;\n      case VERTICAL:\n        return VERTICAL;\n      default:\n        return e && e.shiftKey ? HORIZONTAL : VERTICAL;\n    }\n  },\n  verticalOffset: function verticalOffset() {\n    return 0;\n  },\n  dispose: function dispose() {\n    this._resetActive();\n    if (hoveredScrollable === this) {\n      hoveredScrollable = null;\n    }\n    this._eventHandler(\"dispose\");\n    this._detachEventHandlers();\n    this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);\n    this._eventForUserAction = null;\n    clearTimeout(this._validateWheelTimer);\n    clearTimeout(this._updateHandlerTimeout);\n  },\n  _detachEventHandlers: function _detachEventHandlers() {\n    _events_engine2.default.off(this._$element, \".\" + SCROLLABLE_SIMULATED_CURSOR);\n    _events_engine2.default.off(this._$container, \".\" + SCROLLABLE_SIMULATED_KEYBOARD);\n  }\n});\nexports.SimulatedStrategy = SimulatedStrategy;\nexports.Scroller = Scroller;","map":null,"metadata":{},"sourceType":"script"}