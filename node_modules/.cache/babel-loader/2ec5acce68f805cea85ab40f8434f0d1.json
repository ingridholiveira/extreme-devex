{"ast":null,"code":"/**\r\n * DevExtreme (ui/grid_core/ui.grid_core.adaptivity.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\nvar _renderer2 = _interopRequireDefault(_renderer);\nvar _events_engine = require(\"../../events/core/events_engine\");\nvar _events_engine2 = _interopRequireDefault(_events_engine);\nvar _utils = require(\"../../events/utils\");\nvar _utils2 = _interopRequireDefault(_utils);\nvar _click = require(\"../../events/click\");\nvar _click2 = _interopRequireDefault(_click);\nvar _type = require(\"../../core/utils/type\");\nvar _type2 = _interopRequireDefault(_type);\nvar _browser = require(\"../../core/utils/browser\");\nvar _browser2 = _interopRequireDefault(_browser);\nvar _guid = require(\"../../core/guid\");\nvar _guid2 = _interopRequireDefault(_guid);\nvar _uiGrid_core = require(\"./ui.grid_core.modules\");\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\nvar _form = require(\"../form\");\nvar _form2 = _interopRequireDefault(_form);\nvar _uiGrid_core3 = require(\"./ui.grid_core.utils\");\nvar _uiGrid_core4 = _interopRequireDefault(_uiGrid_core3);\nvar _themes = require(\"../themes\");\nvar _themes2 = _interopRequireDefault(_themes);\nvar _window = require(\"../../core/utils/window\");\nvar _common = require(\"../../core/utils/common\");\nvar _iterator = require(\"../../core/utils/iterator\");\nvar _extend = require(\"../../core/utils/extend\");\nvar _deferred = require(\"../../core/utils/deferred\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar COLUMN_HEADERS_VIEW = \"columnHeadersView\",\n  ROWS_VIEW = \"rowsView\",\n  FOOTER_VIEW = \"footerView\",\n  COLUMN_VIEWS = [COLUMN_HEADERS_VIEW, ROWS_VIEW, FOOTER_VIEW],\n  ADAPTIVE_NAMESPACE = \"dxDataGridAdaptivity\",\n  HIDDEN_COLUMNS_WIDTH = \"adaptiveHidden\",\n  ADAPTIVE_ROW_TYPE = \"detailAdaptive\",\n  FORM_ITEM_CONTENT_CLASS = \"dx-field-item-content\",\n  FORM_ITEM_MODIFIED = \"dx-item-modified\",\n  HIDDEN_COLUMN_CLASS = \"hidden-column\",\n  ADAPTIVE_COLUMN_BUTTON_CLASS = \"adaptive-more\",\n  ADAPTIVE_COLUMN_NAME_CLASS = \"dx-command-adaptive\",\n  COMMAND_ADAPTIVE_HIDDEN_CLASS = \"dx-command-adaptive-hidden\",\n  ADAPTIVE_DETAIL_ROW_CLASS = \"dx-adaptive-detail-row\",\n  ADAPTIVE_ITEM_TEXT_CLASS = \"dx-adaptive-item-text\",\n  MASTER_DETAIL_CELL_CLASS = \"dx-master-detail-cell\",\n  LAST_DATA_CELL_CLASS = \"dx-last-data-cell\",\n  ADAPTIVE_COLUMN_NAME = \"adaptive\",\n  EDIT_MODE_BATCH = \"batch\",\n  EDIT_MODE_ROW = \"row\",\n  EDIT_MODE_FORM = \"form\",\n  EDIT_MODE_POPUP = \"popup\",\n  REVERT_TOOLTIP_CLASS = \"revert-tooltip\";\nfunction getColumnId(that, column) {\n  return that._columnsController.getColumnId(column);\n}\nfunction getDataCellElements($row) {\n  return $row.find(\"td:not(.dx-datagrid-hidden-column):not([class*='dx-command-'])\");\n}\nfunction adaptiveCellTemplate(container, options) {\n  var $adaptiveColumnButton,\n    $container = (0, _renderer2.default)(container),\n    adaptiveColumnsController = options.component.getController(\"adaptiveColumns\");\n  if (\"data\" === options.rowType) {\n    $adaptiveColumnButton = (0, _renderer2.default)(\"<span>\").addClass(adaptiveColumnsController.addWidgetPrefix(ADAPTIVE_COLUMN_BUTTON_CLASS));\n    _events_engine2.default.on($adaptiveColumnButton, _utils2.default.addNamespace(_click2.default.name, ADAPTIVE_NAMESPACE), adaptiveColumnsController.createAction(function () {\n      adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options.key);\n    }));\n    $adaptiveColumnButton.appendTo($container);\n  } else {\n    _uiGrid_core4.default.setEmptyText($container);\n  }\n}\nvar AdaptiveColumnsController = _uiGrid_core2.default.ViewController.inherit({\n  _isRowEditMode: function _isRowEditMode() {\n    var editMode = this._editingController.getEditMode();\n    return editMode === EDIT_MODE_ROW;\n  },\n  _isItemModified: function _isItemModified(item, cellOptions) {\n    var columnIndex = this._columnsController.getVisibleIndex(item.column.index),\n      rowIndex = this._dataController.getRowIndexByKey(cellOptions.key),\n      row = this._dataController.items()[rowIndex + 1];\n    return row && row.modifiedValues && _type2.default.isDefined(row.modifiedValues[columnIndex]);\n  },\n  _renderFormViewTemplate: function _renderFormViewTemplate(item, cellOptions, $container) {\n    var container,\n      that = this,\n      column = item.column,\n      focusAction = that.createAction(function () {\n        _events_engine2.default.trigger($container, _click2.default.name);\n      }),\n      value = column.calculateCellValue(cellOptions.data),\n      displayValue = _uiGrid_core4.default.getDisplayValue(column, value, cellOptions.data, cellOptions.rowType),\n      text = _uiGrid_core4.default.formatValue(displayValue, column);\n    if (column.allowEditing && that.getController(\"keyboardNavigation\").isKeyboardEnabled()) {\n      $container.attr(\"tabIndex\", that.option(\"tabIndex\"));\n      _events_engine2.default.off($container, \"focus\", focusAction);\n      _events_engine2.default.on($container, \"focus\", focusAction);\n    }\n    if (column.cellTemplate) {\n      var templateOptions = (0, _extend.extend)({}, cellOptions, {\n        value: value,\n        displayValue: displayValue,\n        text: text,\n        column: column\n      });\n      that._rowsView.renderTemplate($container, column.cellTemplate, templateOptions, !!$container.closest((0, _window.getWindow)().document).length);\n    } else {\n      container = $container.get(0);\n      if (column.encodeHtml) {\n        container.textContent = text;\n      } else {\n        container.innerHTML = text;\n      }\n      $container.addClass(ADAPTIVE_ITEM_TEXT_CLASS);\n      if (!_type2.default.isDefined(text) || \"\" === text) {\n        $container.html(\"&nbsp;\");\n      }\n      if (!that._isRowEditMode()) {\n        if (that._isItemModified(item, cellOptions)) {\n          $container.addClass(FORM_ITEM_MODIFIED);\n        }\n      }\n    }\n    that.getView(\"rowsView\")._cellPrepared($container, cellOptions);\n  },\n  _getTemplate: function _getTemplate(item, cellOptions) {\n    var that = this,\n      column = item.column,\n      editingController = this.getController(\"editing\");\n    return function (options, container) {\n      var $container = (0, _renderer2.default)(container),\n        columnIndex = that._columnsController.getVisibleIndex(column.visibleIndex),\n        templateOptions = (0, _extend.extend)({}, cellOptions);\n      var renderFormTemplate = function renderFormTemplate() {\n        var isItemEdited = that._isItemEdited(item);\n        templateOptions.value = cellOptions.row.values[columnIndex];\n        if (isItemEdited || column.showEditorAlways) {\n          editingController.renderFormEditTemplate(templateOptions, item, options.component, $container, !isItemEdited);\n        } else {\n          templateOptions.column = column;\n          templateOptions.columnIndex = columnIndex;\n          that._renderFormViewTemplate(item, templateOptions, $container);\n        }\n      };\n      renderFormTemplate();\n      templateOptions.watch && templateOptions.watch(function () {\n        return {\n          isItemEdited: that._isItemEdited(item),\n          value: cellOptions.row.values[columnIndex]\n        };\n      }, function () {\n        $container.contents().remove();\n        $container.removeClass(ADAPTIVE_ITEM_TEXT_CLASS);\n        renderFormTemplate();\n      });\n    };\n  },\n  _isVisibleColumnsValid: function _isVisibleColumnsValid(visibleColumns) {\n    var getCommandColumnsCount = function getCommandColumnsCount() {\n      var j,\n        visibleColumn,\n        result = 0;\n      for (j = 0; j < visibleColumns.length; j++) {\n        visibleColumn = visibleColumns[j];\n        if (visibleColumn.command) {\n          result++;\n        }\n      }\n      return result;\n    };\n    if (visibleColumns < 2) {\n      return false;\n    }\n    if (visibleColumns.length - getCommandColumnsCount() <= 1) {\n      return false;\n    }\n    return true;\n  },\n  _calculatePercentWidths: function _calculatePercentWidths(widths, visibleColumns) {\n    var that = this,\n      percentWidths = 0;\n    visibleColumns.forEach(function (item, index) {\n      if (widths[index] !== HIDDEN_COLUMNS_WIDTH) {\n        percentWidths += that._getItemPercentWidth(item);\n      }\n    });\n    return percentWidths;\n  },\n  _isPercentWidth: function _isPercentWidth(width) {\n    return _type2.default.isString(width) && \"%\" === width.slice(-1);\n  },\n  _isColumnHidden: function _isColumnHidden(column) {\n    return this._hiddenColumns.filter(function (hiddenColumn) {\n      return hiddenColumn.index === column.index;\n    }).length > 0;\n  },\n  _getAverageColumnsWidth: function _getAverageColumnsWidth(containerWidth, columns, columnsCanFit) {\n    var that = this,\n      fixedColumnsWidth = 0,\n      columnsWithoutFixedWidthCount = 0;\n    columns.forEach(function (column) {\n      if (!that._isColumnHidden(column)) {\n        var width = column.width;\n        if (_type2.default.isDefined(width) && !isNaN(parseFloat(width))) {\n          fixedColumnsWidth += that._isPercentWidth(width) ? that._calculatePercentWidth({\n            visibleIndex: column.visibleIndex,\n            columnsCount: columns.length,\n            columnsCanFit: columnsCanFit,\n            bestFitWidth: column.bestFitWidth,\n            columnWidth: width,\n            containerWidth: containerWidth\n          }) : parseFloat(width);\n        } else {\n          columnsWithoutFixedWidthCount++;\n        }\n      }\n    });\n    return (containerWidth - fixedColumnsWidth) / columnsWithoutFixedWidthCount;\n  },\n  _calculateColumnWidth: function _calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit) {\n    var colWidth,\n      columnId = getColumnId(this, column),\n      widthOption = this._columnsController.columnOption(columnId, \"width\"),\n      bestFitWidth = this._columnsController.columnOption(columnId, \"bestFitWidth\"),\n      columnsCount = contentColumns.length;\n    if (widthOption && \"auto\" !== widthOption) {\n      if (this._isPercentWidth(widthOption)) {\n        colWidth = this._calculatePercentWidth({\n          visibleIndex: column.visibleIndex,\n          columnsCount: columnsCount,\n          columnsCanFit: columnsCanFit,\n          bestFitWidth: bestFitWidth,\n          columnWidth: widthOption,\n          containerWidth: containerWidth\n        });\n      } else {\n        return widthOption;\n      }\n    } else {\n      var columnAutoWidth = this.option(\"columnAutoWidth\");\n      colWidth = columnAutoWidth || !!column.command ? bestFitWidth : this._getAverageColumnsWidth(containerWidth, contentColumns, columnsCanFit);\n    }\n    return colWidth;\n  },\n  _calculatePercentWidth: function _calculatePercentWidth(options) {\n    var columnFitted = options.visibleIndex < options.columnsCount - 1 && options.columnsCanFit,\n      partialWidth = options.containerWidth * parseFloat(options.columnWidth) / 100,\n      resultWidth = options.columnsCanFit && partialWidth < options.bestFitWidth ? options.bestFitWidth : partialWidth;\n    return columnFitted ? options.containerWidth * parseFloat(options.columnWidth) / 100 : resultWidth;\n  },\n  _getNotTruncatedColumnWidth: function _getNotTruncatedColumnWidth(column, containerWidth, contentColumns, columnsCanFit) {\n    var colWidth,\n      columnId = getColumnId(this, column),\n      widthOption = this._columnsController.columnOption(columnId, \"width\"),\n      bestFitWidth = this._columnsController.columnOption(columnId, \"bestFitWidth\");\n    if (widthOption && \"auto\" !== widthOption && !this._isPercentWidth(widthOption)) {\n      return widthOption;\n    }\n    colWidth = this._calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit);\n    return colWidth < bestFitWidth ? null : colWidth;\n  },\n  _getItemPercentWidth: function _getItemPercentWidth(item) {\n    var result = 0;\n    if (item.width && this._isPercentWidth(item.width)) {\n      result = parseFloat(item.width);\n    }\n    return result;\n  },\n  _getCommandColumnsWidth: function _getCommandColumnsWidth() {\n    var that = this,\n      columns = that._columnsController.getVisibleColumns(),\n      colWidth = 0;\n    (0, _iterator.each)(columns, function (index, column) {\n      if (column.index < 0 || column.command) {\n        colWidth += that._columnsController.columnOption(getColumnId(that, column), \"bestFitWidth\") || 0;\n      }\n    });\n    return colWidth;\n  },\n  _isItemEdited: function _isItemEdited(item) {\n    if (this.isFormEditMode()) {\n      return false;\n    }\n    if (this._isRowEditMode()) {\n      var editRowKey = this._editingController.getEditRowKey();\n      if ((0, _common.equalByValue)(editRowKey, this._dataController.adaptiveExpandedKey())) {\n        return true;\n      }\n    } else {\n      var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1,\n        columnIndex = this._columnsController.getVisibleIndex(item.column.index);\n      return this._editingController.isEditCell(rowIndex, columnIndex);\n    }\n  },\n  _getFormItemsByHiddenColumns: function _getFormItemsByHiddenColumns(hiddenColumns) {\n    var items = [];\n    (0, _iterator.each)(hiddenColumns, function (_, column) {\n      items.push({\n        column: column,\n        name: column.name,\n        dataField: column.dataField,\n        visibleIndex: column.visibleIndex\n      });\n    });\n    return items;\n  },\n  _getAdaptiveColumnVisibleIndex: function _getAdaptiveColumnVisibleIndex(visibleColumns) {\n    var i, column;\n    for (i = 0; i < visibleColumns.length; i++) {\n      column = visibleColumns[i];\n      if (column.command === ADAPTIVE_COLUMN_NAME) {\n        return i;\n      }\n    }\n  },\n  _hideAdaptiveColumn: function _hideAdaptiveColumn(resultWidths, visibleColumns) {\n    var visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);\n    if (_type2.default.isDefined(visibleIndex)) {\n      resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH;\n      this._addCssClassToColumn(COMMAND_ADAPTIVE_HIDDEN_CLASS, visibleIndex);\n    }\n  },\n  _removeCssClassFromColumn: function _removeCssClassFromColumn(cssClassName) {\n    var i, view, $cells;\n    for (i = 0; i < COLUMN_VIEWS.length; i++) {\n      view = this.getView(COLUMN_VIEWS[i]);\n      if (view && view.isVisible() && view.element()) {\n        $cells = view.element().find(\".\" + cssClassName);\n        $cells.removeClass(cssClassName);\n      }\n    }\n  },\n  _removeCssClassesFromColumns: function _removeCssClassesFromColumns() {\n    this._removeCssClassFromColumn(COMMAND_ADAPTIVE_HIDDEN_CLASS);\n    this._removeCssClassFromColumn(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));\n  },\n  _isCellValid: function _isCellValid($cell) {\n    return $cell && $cell.length && !$cell.hasClass(MASTER_DETAIL_CELL_CLASS);\n  },\n  _addCssClassToColumn: function _addCssClassToColumn(cssClassName, visibleIndex) {\n    var that = this;\n    COLUMN_VIEWS.forEach(function (viewName) {\n      var view = that.getView(viewName);\n      view && that._addCssClassToViewColumn(view, cssClassName, visibleIndex);\n    });\n  },\n  _addCssClassToViewColumn: function _addCssClassToViewColumn(view, cssClassName, visibleIndex) {\n    var rowsCount,\n      rowIndex,\n      $cellElement,\n      currentVisibleIndex,\n      viewName = view.name,\n      column = this._columnsController.getVisibleColumns()[visibleIndex],\n      editFormRowIndex = this._editingController && this._editingController.getEditFormRowIndex();\n    if (view && view.isVisible() && column) {\n      rowsCount = view.getRowsCount();\n      var $rowElements = view._getRowElements();\n      for (rowIndex = 0; rowIndex < rowsCount; rowIndex++) {\n        if (rowIndex !== editFormRowIndex || viewName !== ROWS_VIEW) {\n          currentVisibleIndex = viewName === COLUMN_HEADERS_VIEW ? this._columnsController.getVisibleIndex(column.index, rowIndex) : visibleIndex;\n          if (currentVisibleIndex >= 0) {\n            $cellElement = $rowElements.eq(rowIndex).children().eq(currentVisibleIndex);\n            this._isCellValid($cellElement) && $cellElement.addClass(cssClassName);\n          }\n        }\n      }\n    }\n  },\n  isFormEditMode: function isFormEditMode() {\n    var editMode = this._editingController.getEditMode();\n    return editMode === EDIT_MODE_FORM || editMode === EDIT_MODE_POPUP;\n  },\n  hideRedundantColumns: function hideRedundantColumns(resultWidths, visibleColumns, hiddenQueue) {\n    var visibleColumn,\n      that = this;\n    this._hiddenColumns = [];\n    if (that._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {\n      var percentWidths,\n        columnsCanFit,\n        i,\n        hasHiddenColumns,\n        needHideColumn,\n        totalWidth = 0,\n        $rootElement = that.component.$element(),\n        rootElementWidth = $rootElement.width() - that._getCommandColumnsWidth(),\n        getVisibleContentColumns = function () {\n          var _this = this;\n          return visibleColumns.filter(function (item) {\n            return !item.command && 0 === _this._hiddenColumns.filter(function (i) {\n              return i.dataField === item.dataField;\n            }).length;\n          });\n        }.bind(this),\n        visibleContentColumns = getVisibleContentColumns(),\n        contentColumnsCount = visibleContentColumns.length;\n      do {\n        needHideColumn = false;\n        totalWidth = 0;\n        percentWidths = that._calculatePercentWidths(resultWidths, visibleColumns);\n        columnsCanFit = percentWidths < 100 && 0 !== percentWidths;\n        for (i = 0; i < visibleColumns.length; i++) {\n          visibleColumn = visibleColumns[i];\n          var columnWidth = that._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, visibleContentColumns, columnsCanFit),\n            columnId = getColumnId(that, visibleColumn),\n            widthOption = that._columnsController.columnOption(columnId, \"width\"),\n            minWidth = that._columnsController.columnOption(columnId, \"minWidth\"),\n            columnBestFitWidth = that._columnsController.columnOption(columnId, \"bestFitWidth\");\n          if (resultWidths[i] === HIDDEN_COLUMNS_WIDTH) {\n            hasHiddenColumns = true;\n            continue;\n          }\n          if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {\n            needHideColumn = true;\n            break;\n          }\n          if (!widthOption || \"auto\" === widthOption) {\n            columnWidth = Math.max(columnBestFitWidth || 0, minWidth || 0);\n          }\n          if (visibleColumn.command !== ADAPTIVE_COLUMN_NAME || hasHiddenColumns) {\n            totalWidth += columnWidth;\n          }\n        }\n        needHideColumn = needHideColumn || totalWidth > $rootElement.width();\n        if (needHideColumn) {\n          var column = hiddenQueue.pop(),\n            visibleIndex = that._columnsController.getVisibleIndex(column.index);\n          rootElementWidth += that._calculateColumnWidth(column, rootElementWidth, visibleContentColumns, columnsCanFit);\n          that._addCssClassToColumn(that.addWidgetPrefix(HIDDEN_COLUMN_CLASS), visibleIndex);\n          resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH;\n          this._hiddenColumns.push(column);\n          visibleContentColumns = getVisibleContentColumns();\n        }\n      } while (needHideColumn && visibleContentColumns.length > 1 && hiddenQueue.length);\n      if (contentColumnsCount === visibleContentColumns.length) {\n        that._hideAdaptiveColumn(resultWidths, visibleColumns);\n      }\n    } else {\n      that._hideAdaptiveColumn(resultWidths, visibleColumns);\n    }\n  },\n  getItemContentByColumnIndex: function getItemContentByColumnIndex(visibleColumnIndex) {\n    var $itemContent, i, item;\n    for (i = 0; i < this._$itemContents.length; i++) {\n      $itemContent = this._$itemContents.eq(i);\n      item = $itemContent.data(\"dx-form-item\");\n      if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {\n        return $itemContent;\n      }\n    }\n  },\n  toggleExpandAdaptiveDetailRow: function toggleExpandAdaptiveDetailRow(key, alwaysExpanded) {\n    if (!(this.isFormEditMode() && this._editingController.isEditing())) {\n      this.getController(\"data\").toggleExpandAdaptiveDetailRow(key, alwaysExpanded);\n    }\n  },\n  createFormByHiddenColumns: function createFormByHiddenColumns(container, options) {\n    var that = this,\n      $container = (0, _renderer2.default)(container),\n      userFormOptions = {\n        items: that._getFormItemsByHiddenColumns(that._hiddenColumns),\n        formID: \"dx-\" + new _guid2.default()\n      },\n      defaultFormOptions = _themes2.default.isMaterial() ? {\n        colCount: 2\n      } : {};\n    this.executeAction(\"onAdaptiveDetailRowPreparing\", {\n      formOptions: userFormOptions\n    });\n    that._$itemContents = null;\n    that._form = that._createComponent((0, _renderer2.default)(\"<div>\").appendTo($container), _form2.default, (0, _extend.extend)(defaultFormOptions, userFormOptions, {\n      customizeItem: function customizeItem(item) {\n        var column = item.column || that._columnsController.columnOption(item.name || item.dataField);\n        if (column) {\n          item.label = item.label || {};\n          item.label.text = item.label.text || column.caption;\n          item.column = column;\n          item.template = that._getTemplate(item, options, that.updateForm.bind(that));\n        }\n        userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item);\n      },\n      onContentReady: function onContentReady(e) {\n        userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);\n        that._$itemContents = $container.find(\".\" + FORM_ITEM_CONTENT_CLASS);\n      }\n    }));\n  },\n  hasAdaptiveDetailRowExpanded: function hasAdaptiveDetailRowExpanded() {\n    return _type2.default.isDefined(this._dataController.adaptiveExpandedKey());\n  },\n  updateForm: function updateForm(hiddenColumns) {\n    if (this.hasAdaptiveDetailRowExpanded()) {\n      if (this._form && _type2.default.isDefined(this._form._contentReadyAction)) {\n        if (hiddenColumns && hiddenColumns.length) {\n          this._form.option(\"items\", this._getFormItemsByHiddenColumns(hiddenColumns));\n        } else {\n          this._form.repaint();\n        }\n      }\n    }\n  },\n  updateHidingQueue: function updateHidingQueue(columns) {\n    var columnsHasHidingPriority,\n      i,\n      that = this,\n      hideableColumns = columns.filter(function (column) {\n        return column.visible && !column.type && !column.fixed && !(_type2.default.isDefined(column.groupIndex) && column.groupIndex >= 0);\n      });\n    that._hidingColumnsQueue = [];\n    if (that.option(\"allowColumnResizing\") && \"widget\" === that.option(\"columnResizingMode\")) {\n      return that._hidingColumnsQueue;\n    }\n    for (i = 0; i < hideableColumns.length; i++) {\n      if (_type2.default.isDefined(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {\n        columnsHasHidingPriority = true;\n        that._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i];\n      }\n    }\n    if (columnsHasHidingPriority) {\n      that._hidingColumnsQueue.reverse();\n    } else {\n      if (that.option(\"columnHidingEnabled\")) {\n        for (i = 0; i < hideableColumns.length; i++) {\n          var visibleIndex = that._columnsController.getVisibleIndex(hideableColumns[i].index);\n          that._hidingColumnsQueue[visibleIndex] = hideableColumns[i];\n        }\n      }\n    }\n    that._hidingColumnsQueue = that._hidingColumnsQueue.filter(Object);\n    return that._hidingColumnsQueue;\n  },\n  getHiddenColumns: function getHiddenColumns() {\n    return this._hiddenColumns;\n  },\n  hasHiddenColumns: function hasHiddenColumns() {\n    return this._hiddenColumns.length > 0;\n  },\n  getHidingColumnsQueue: function getHidingColumnsQueue() {\n    return this._hidingColumnsQueue;\n  },\n  init: function init() {\n    var that = this;\n    that._columnsController = that.getController(\"columns\");\n    that._dataController = that.getController(\"data\");\n    that._rowsView = that.getView(\"rowsView\");\n    that._columnsController.addCommandColumn({\n      type: ADAPTIVE_COLUMN_NAME,\n      command: ADAPTIVE_COLUMN_NAME,\n      visible: true,\n      adaptiveHidden: true,\n      cssClass: ADAPTIVE_COLUMN_NAME_CLASS,\n      alignment: \"center\",\n      width: \"auto\",\n      cellTemplate: adaptiveCellTemplate,\n      fixedPosition: \"right\"\n    });\n    that._columnsController.columnsChanged.add(function () {\n      var isAdaptiveVisible = !!that.updateHidingQueue(that._columnsController.getColumns()).length;\n      that._columnsController.columnOption(\"command:adaptive\", \"adaptiveHidden\", !isAdaptiveVisible, true);\n    });\n    that._editingController = that.getController(\"editing\");\n    that._hidingColumnsQueue = [];\n    that._hiddenColumns = [];\n    that.createAction(\"onAdaptiveDetailRowPreparing\");\n    that.callBase();\n  },\n  optionChanged: function optionChanged(args) {\n    if (\"columnHidingEnabled\" === args.name) {\n      this._columnsController.columnOption(\"command:adaptive\", \"adaptiveHidden\", !args.value);\n    }\n    this.callBase(args);\n  },\n  publicMethods: function publicMethods() {\n    return [\"isAdaptiveDetailRowExpanded\", \"expandAdaptiveDetailRow\", \"collapseAdaptiveDetailRow\"];\n  },\n  isAdaptiveDetailRowExpanded: function isAdaptiveDetailRowExpanded(key) {\n    return this._dataController.adaptiveExpandedKey() && (0, _common.equalByValue)(this._dataController.adaptiveExpandedKey(), key);\n  },\n  expandAdaptiveDetailRow: function expandAdaptiveDetailRow(key) {\n    if (!this.hasAdaptiveDetailRowExpanded()) {\n      this.toggleExpandAdaptiveDetailRow(key);\n    }\n  },\n  collapseAdaptiveDetailRow: function collapseAdaptiveDetailRow() {\n    if (this.hasAdaptiveDetailRowExpanded()) {\n      this.toggleExpandAdaptiveDetailRow();\n    }\n  }\n});\nmodule.exports = {\n  defaultOptions: function defaultOptions() {\n    return {\n      columnHidingEnabled: false,\n      onAdaptiveDetailRowPreparing: null\n    };\n  },\n  controllers: {\n    adaptiveColumns: AdaptiveColumnsController\n  },\n  extenders: {\n    views: {\n      rowsView: {\n        _getCellTemplate: function _getCellTemplate(options) {\n          var that = this,\n            column = options.column;\n          if (options.rowType === ADAPTIVE_ROW_TYPE && \"detail\" === column.command) {\n            return function (container, options) {\n              that._adaptiveColumnsController.createFormByHiddenColumns((0, _renderer2.default)(container), options);\n            };\n          }\n          return that.callBase(options);\n        },\n        _createRow: function _createRow(row) {\n          var $row = this.callBase(row);\n          if (row && row.rowType === ADAPTIVE_ROW_TYPE && row.key === this._dataController.adaptiveExpandedKey()) {\n            $row.addClass(ADAPTIVE_DETAIL_ROW_CLASS);\n          }\n          return $row;\n        },\n        _renderCells: function _renderCells($row, options) {\n          this.callBase($row, options);\n          var hidingColumnsQueueLength = this._adaptiveColumnsController.getHidingColumnsQueue().length,\n            hiddenColumnsLength = this._adaptiveColumnsController.getHiddenColumns().length;\n          if (hidingColumnsQueueLength && !hiddenColumnsLength) {\n            getDataCellElements($row).last().addClass(LAST_DATA_CELL_CLASS);\n          }\n        },\n        _getColumnIndexByElementCore: function _getColumnIndexByElementCore($element) {\n          var $itemContent = $element.closest(\".\" + FORM_ITEM_CONTENT_CLASS);\n          if ($itemContent.length && $itemContent.closest(this.component.$element()).length) {\n            var formItem = $itemContent.length ? $itemContent.first().data(\"dx-form-item\") : null;\n            return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);\n          } else {\n            return this.callBase($element);\n          }\n        },\n        _cellPrepared: function _cellPrepared($cell, options) {\n          this.callBase.apply(this, arguments);\n          if (options.row.rowType !== ADAPTIVE_ROW_TYPE && options.column.visibleWidth === HIDDEN_COLUMNS_WIDTH) {\n            $cell.addClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));\n          }\n        },\n        _getCellElement: function _getCellElement(rowIndex, columnIdentifier) {\n          var item = this._dataController.items()[rowIndex];\n          if (item && item.rowType === ADAPTIVE_ROW_TYPE) {\n            return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier);\n          } else {\n            return this.callBase(rowIndex, columnIdentifier);\n          }\n        },\n        getContextMenuItems: function getContextMenuItems(options) {\n          if (options.row && \"detailAdaptive\" === options.row.rowType) {\n            var view = this.component.getView(\"columnHeadersView\");\n            var formItem = (0, _renderer2.default)(options.targetElement).closest(\".dx-field-item-label\").next().data(\"dx-form-item\");\n            options.column = formItem ? formItem.column : options.column;\n            return view.getContextMenuItems && view.getContextMenuItems(options);\n          }\n          return this.callBase && this.callBase(options);\n        },\n        isClickableElement: function isClickableElement($target) {\n          var isClickable = this.callBase ? this.callBase($target) : false;\n          return isClickable || !!$target.closest(\".\" + ADAPTIVE_COLUMN_NAME_CLASS).length;\n        },\n        init: function init() {\n          this.callBase();\n          this._adaptiveColumnsController = this.getController(\"adaptiveColumns\");\n        }\n      }\n    },\n    controllers: {\n      \"export\": {\n        _updateColumnWidth: function _updateColumnWidth(column, width) {\n          this.callBase(column, column.visibleWidth === HIDDEN_COLUMNS_WIDTH ? column.bestFitWidth : width);\n        }\n      },\n      columnsResizer: {\n        _pointCreated: function _pointCreated(point, cellsLength, columns) {\n          var result = this.callBase(point, cellsLength, columns),\n            currentColumn = columns[point.columnIndex] || {},\n            nextColumnIndex = this._getNextColumnIndex(point.columnIndex),\n            nextColumn = columns[nextColumnIndex] || {},\n            hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command,\n            hasAdaptiveHiddenWidth = currentColumn.visibleWidth === HIDDEN_COLUMNS_WIDTH || hasHiddenColumnsOnly;\n          return result || hasAdaptiveHiddenWidth;\n        },\n        _getNextColumnIndex: function _getNextColumnIndex(currentColumnIndex) {\n          var visibleColumns = this._columnsController.getVisibleColumns(),\n            index = this.callBase(currentColumnIndex);\n          while (visibleColumns[index] && visibleColumns[index].visibleWidth === HIDDEN_COLUMNS_WIDTH) {\n            index++;\n          }\n          return index;\n        }\n      },\n      draggingHeader: {\n        _pointCreated: function _pointCreated(point, columns, location, sourceColumn) {\n          var result = this.callBase(point, columns, location, sourceColumn),\n            column = columns[point.columnIndex - 1] || {},\n            hasAdaptiveHiddenWidth = column.visibleWidth === HIDDEN_COLUMNS_WIDTH;\n          return result || hasAdaptiveHiddenWidth;\n        }\n      },\n      editing: {\n        _isRowEditMode: function _isRowEditMode() {\n          return this.getEditMode() === EDIT_MODE_ROW;\n        },\n        _getFormEditItemTemplate: function _getFormEditItemTemplate(cellOptions, column) {\n          if (this.getEditMode() !== EDIT_MODE_ROW && \"detailAdaptive\" === cellOptions.rowType) {\n            cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.index);\n            return this.getColumnTemplate(cellOptions);\n          }\n          return this.callBase(cellOptions, column);\n        },\n        _closeEditItem: function _closeEditItem($targetElement) {\n          var $itemContents = $targetElement.closest(\".\" + FORM_ITEM_CONTENT_CLASS),\n            rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1,\n            formItem = $itemContents.length ? $itemContents.first().data(\"dx-form-item\") : null,\n            columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);\n          if (!this.isEditCell(rowIndex, columnIndex)) {\n            this.callBase($targetElement);\n          }\n        },\n        _beforeUpdateItems: function _beforeUpdateItems(rowIndices, rowIndex) {\n          if (!this._adaptiveController.isFormEditMode() && this._adaptiveController.hasHiddenColumns()) {\n            var items = this._dataController.items(),\n              item = items[rowIndex],\n              oldExpandRowIndex = _uiGrid_core4.default.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);\n            this._isForceRowAdaptiveExpand = !this._adaptiveController.hasAdaptiveDetailRowExpanded();\n            if (oldExpandRowIndex >= 0 && rowIndex > oldExpandRowIndex) {\n              this._editRowIndex--;\n            }\n            if (oldExpandRowIndex >= 0) {\n              rowIndices.push(oldExpandRowIndex + 1);\n            }\n            rowIndices.push(rowIndex + 1);\n            this._dataController.adaptiveExpandedKey(item.key);\n          }\n        },\n        _afterInsertRow: function _afterInsertRow(options) {\n          this.callBase(options);\n          if (this._adaptiveController.hasHiddenColumns()) {\n            this._adaptiveController.toggleExpandAdaptiveDetailRow(options.key, this.isRowEditMode());\n            this._isForceRowAdaptiveExpand = true;\n          }\n        },\n        _collapseAdaptiveDetailRow: function _collapseAdaptiveDetailRow() {\n          if (this._isRowEditMode() && this._isForceRowAdaptiveExpand) {\n            this._adaptiveController.collapseAdaptiveDetailRow();\n            this._isForceRowAdaptiveExpand = false;\n          }\n        },\n        _cancelEditAdaptiveDetailRow: function _cancelEditAdaptiveDetailRow() {\n          if (this._adaptiveController.hasHiddenColumns()) {\n            this._collapseAdaptiveDetailRow();\n          }\n        },\n        _afterSaveEditData: function _afterSaveEditData() {\n          var _this2 = this;\n          this.callBase();\n          var deferred = new _deferred.Deferred();\n          if (this._isRowEditMode() && this._adaptiveController.hasHiddenColumns()) {\n            (0, _deferred.when)(this.getController(\"validating\").validate(true)).done(function (isValid) {\n              if (isValid) {\n                _this2._cancelEditAdaptiveDetailRow();\n              }\n              deferred.resolve();\n            });\n          } else {\n            deferred.resolve();\n          }\n          return deferred.promise();\n        },\n        _beforeCancelEditData: function _beforeCancelEditData() {\n          this.callBase();\n          this._cancelEditAdaptiveDetailRow();\n        },\n        _getRowIndicesForCascadeUpdating: function _getRowIndicesForCascadeUpdating(row) {\n          var rowIndices = this.callBase.apply(this, arguments);\n          if (this._adaptiveController.isAdaptiveDetailRowExpanded(row.key)) {\n            rowIndices.push(row.rowType === ADAPTIVE_ROW_TYPE ? row.rowIndex - 1 : row.rowIndex + 1);\n          }\n          return rowIndices;\n        },\n        _beforeCloseEditCellInBatchMode: function _beforeCloseEditCellInBatchMode(rowIndices) {\n          var rowIndex,\n            expandedKey = this._dataController._adaptiveExpandedKey;\n          if (expandedKey) {\n            rowIndex = _uiGrid_core4.default.getIndexByKey(expandedKey, this._dataController.items());\n            if (rowIndex > -1) {\n              rowIndices.unshift(rowIndex);\n            }\n          }\n        },\n        editRow: function editRow(rowIndex) {\n          if (this._adaptiveController.isFormEditMode()) {\n            this._adaptiveController.collapseAdaptiveDetailRow();\n          }\n          this.callBase(rowIndex);\n        },\n        deleteRow: function deleteRow(rowIndex) {\n          var rowKey = this._dataController.getKeyByRowIndex(rowIndex);\n          if (this.getEditMode() === EDIT_MODE_BATCH && this._adaptiveController.isAdaptiveDetailRowExpanded(rowKey)) {\n            this._adaptiveController.collapseAdaptiveDetailRow();\n          }\n          this.callBase(rowIndex);\n        },\n        init: function init() {\n          this.callBase();\n          this._adaptiveController = this.getController(\"adaptiveColumns\");\n        }\n      },\n      resizing: {\n        _needBestFit: function _needBestFit() {\n          return this.callBase() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length;\n        },\n        _updateScrollableForIE: function _updateScrollableForIE() {\n          var that = this;\n          if (_browser2.default.msie && parseInt(_browser2.default.version) <= 11) {\n            this._updateScrollableTimeoutID = setTimeout(function () {\n              that.getView(\"rowsView\")._updateScrollable();\n            });\n          }\n        },\n        _correctColumnWidths: function _correctColumnWidths(resultWidths, visibleColumns) {\n          var hiddenColumns,\n            adaptiveController = this._adaptiveColumnsController,\n            columnAutoWidth = this.option(\"columnAutoWidth\"),\n            oldHiddenColumns = adaptiveController.getHiddenColumns(),\n            hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());\n          adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);\n          hiddenColumns = adaptiveController.getHiddenColumns();\n          if (adaptiveController.hasAdaptiveDetailRowExpanded()) {\n            if (oldHiddenColumns.length !== hiddenColumns.length) {\n              adaptiveController.updateForm(hiddenColumns);\n            }\n          }\n          !hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();\n          if (columnAutoWidth && hidingColumnsQueue.length && !hiddenColumns.length) {\n            this._updateScrollableForIE();\n          }\n          return this.callBase.apply(this, arguments);\n        },\n        _toggleBestFitMode: function _toggleBestFitMode(isBestFit) {\n          isBestFit && this._adaptiveColumnsController._removeCssClassesFromColumns();\n          this.callBase(isBestFit);\n        },\n        _needStretch: function _needStretch() {\n          var adaptiveColumnsController = this._adaptiveColumnsController;\n          return this.callBase.apply(this, arguments) || adaptiveColumnsController.getHidingColumnsQueue().length || adaptiveColumnsController.hasHiddenColumns();\n        },\n        init: function init() {\n          this._adaptiveColumnsController = this.getController(\"adaptiveColumns\");\n          this.callBase();\n        },\n        dispose: function dispose() {\n          this.callBase.apply(this, arguments);\n          clearTimeout(this._updateScrollableTimeoutID);\n        }\n      },\n      data: {\n        _processItems: function _processItems(items, changeType) {\n          var item,\n            expandRowIndex,\n            that = this;\n          items = that.callBase.apply(that, arguments);\n          if (\"loadingAll\" === changeType || !_type2.default.isDefined(that._adaptiveExpandedKey)) {\n            return items;\n          }\n          expandRowIndex = _uiGrid_core4.default.getIndexByKey(that._adaptiveExpandedKey, items);\n          if (expandRowIndex >= 0) {\n            item = items[expandRowIndex];\n            items.splice(expandRowIndex + 1, 0, {\n              visible: true,\n              rowType: ADAPTIVE_ROW_TYPE,\n              key: item.key,\n              data: item.data,\n              modifiedValues: item.modifiedValues,\n              isNewRow: item.isNewRow,\n              values: item.values\n            });\n          } else {\n            if (\"refresh\" === changeType) {\n              that._adaptiveExpandedKey = void 0;\n            }\n          }\n          return items;\n        },\n        _getRowIndicesForExpand: function _getRowIndicesForExpand(key) {\n          var lastRowIndex,\n            rowIndices = this.callBase.apply(this, arguments);\n          if (this.getController(\"adaptiveColumns\").isAdaptiveDetailRowExpanded(key)) {\n            lastRowIndex = rowIndices[rowIndices.length - 1];\n            rowIndices.push(lastRowIndex + 1);\n          }\n          return rowIndices;\n        },\n        adaptiveExpandedKey: function adaptiveExpandedKey(value) {\n          if (_type2.default.isDefined(value)) {\n            this._adaptiveExpandedKey = value;\n          } else {\n            return this._adaptiveExpandedKey;\n          }\n        },\n        toggleExpandAdaptiveDetailRow: function toggleExpandAdaptiveDetailRow(key, alwaysExpanded) {\n          var that = this;\n          var oldExpandRowIndex = _uiGrid_core4.default.getIndexByKey(that._adaptiveExpandedKey, that._items);\n          var newExpandRowIndex = _uiGrid_core4.default.getIndexByKey(key, that._items);\n          if (oldExpandRowIndex >= 0 && oldExpandRowIndex === newExpandRowIndex && !alwaysExpanded) {\n            key = void 0;\n            newExpandRowIndex = -1;\n          }\n          that._adaptiveExpandedKey = key;\n          if (oldExpandRowIndex >= 0) {\n            oldExpandRowIndex++;\n          }\n          if (newExpandRowIndex >= 0) {\n            newExpandRowIndex++;\n          }\n          that.updateItems({\n            changeType: \"update\",\n            rowIndices: [oldExpandRowIndex, newExpandRowIndex]\n          });\n        },\n        init: function init() {\n          this.callBase();\n          this._adaptiveExpandedKey = void 0;\n        }\n      },\n      editorFactory: {\n        _getFocusCellSelector: function _getFocusCellSelector() {\n          return this.callBase() + \", .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content\";\n        },\n        _getTooltipsSelector: function _getTooltipsSelector() {\n          return this.callBase() + \", .dx-field-item-content .\" + this.addWidgetPrefix(REVERT_TOOLTIP_CLASS);\n        }\n      },\n      columns: {\n        _isColumnVisible: function _isColumnVisible(column) {\n          return this.callBase(column) && !column.adaptiveHidden;\n        }\n      },\n      keyboardNavigation: {\n        _isCellValid: function _isCellValid($cell) {\n          return this.callBase.apply(this, arguments) && !$cell.hasClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));\n        },\n        _processNextCellInMasterDetail: function _processNextCellInMasterDetail($nextCell) {\n          this.callBase($nextCell);\n          if (!this._isInsideEditForm($nextCell) && $nextCell) {\n            var focusHandler = function focusHandler() {\n              _events_engine2.default.off($nextCell, \"focus\", focusHandler);\n              _events_engine2.default.trigger($nextCell, \"dxclick\");\n            };\n            _events_engine2.default.on($nextCell, \"focus\", focusHandler);\n          }\n        },\n        _handleTabKeyOnMasterDetailCell: function _handleTabKeyOnMasterDetailCell(eventTarget, direction) {\n          var result = this.callBase(eventTarget, direction),\n            $currentCell = this._getFocusedCell();\n          if (!result && $currentCell) {\n            var $row = $currentCell.parent(),\n              $dataCells = getDataCellElements($row),\n              $targetCell = \"next\" === direction ? $dataCells.last() : $dataCells.first(),\n              rowIndex = $row.get(0).rowIndex,\n              adaptiveController = this._adaptiveController,\n              key = this._dataController.getKeyByRowIndex(\"next\" === direction ? rowIndex : rowIndex - 1),\n              isCellElementsEquals = $currentCell && $targetCell && $currentCell.get(0) === $targetCell.get(0);\n            return adaptiveController.isAdaptiveDetailRowExpanded(key) && isCellElementsEquals;\n          }\n          return result;\n        },\n        init: function init() {\n          this.callBase();\n          this._adaptiveController = this.getController(\"adaptiveColumns\");\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}