{"ast":null,"code":"/**\r\n * DevExtreme (localization/ldml/date.formatter.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction leftPad(text, length) {\n  while (text.length < length) {\n    text = \"0\" + text;\n  }\n  return text;\n}\nvar FORMAT_TYPES = {\n  3: \"abbreviated\",\n  4: \"wide\",\n  5: \"narrow\"\n};\nvar LDML_FORMATTERS = {\n  y: function y(date, count, useUtc) {\n    var year = date[useUtc ? \"getUTCFullYear\" : \"getFullYear\"]();\n    if (2 === count) {\n      year %= 100;\n    }\n    return leftPad(year.toString(), count);\n  },\n  M: function M(date, count, useUtc, dateParts) {\n    var month = date[useUtc ? \"getUTCMonth\" : \"getMonth\"]();\n    var formatType = FORMAT_TYPES[count];\n    if (formatType) {\n      return dateParts.getMonthNames(formatType, \"format\")[month];\n    }\n    return leftPad((month + 1).toString(), Math.min(count, 2));\n  },\n  L: function L(date, count, useUtc, dateParts) {\n    var month = date[useUtc ? \"getUTCMonth\" : \"getMonth\"]();\n    var formatType = FORMAT_TYPES[count];\n    if (formatType) {\n      return dateParts.getMonthNames(formatType, \"standalone\")[month];\n    }\n    return leftPad((month + 1).toString(), Math.min(count, 2));\n  },\n  Q: function Q(date, count, useUtc, dateParts) {\n    var month = date[useUtc ? \"getUTCMonth\" : \"getMonth\"]();\n    var quarter = Math.floor(month / 3);\n    var formatType = FORMAT_TYPES[count];\n    if (formatType) {\n      return dateParts.getQuarterNames(formatType)[quarter];\n    }\n    return leftPad((quarter + 1).toString(), Math.min(count, 2));\n  },\n  E: function E(date, count, useUtc, dateParts) {\n    var day = date[useUtc ? \"getUTCDay\" : \"getDay\"]();\n    var formatType = FORMAT_TYPES[count < 3 ? 3 : count];\n    return dateParts.getDayNames(formatType)[day];\n  },\n  a: function a(date, count, useUtc, dateParts) {\n    var hours = date[useUtc ? \"getUTCHours\" : \"getHours\"](),\n      period = hours < 12 ? 0 : 1,\n      formatType = FORMAT_TYPES[count];\n    return dateParts.getPeriodNames(formatType)[period];\n  },\n  d: function d(date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCDate\" : \"getDate\"]().toString(), Math.min(count, 2));\n  },\n  H: function H(date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCHours\" : \"getHours\"]().toString(), Math.min(count, 2));\n  },\n  h: function h(date, count, useUtc) {\n    var hours = date[useUtc ? \"getUTCHours\" : \"getHours\"]();\n    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));\n  },\n  m: function m(date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCMinutes\" : \"getMinutes\"]().toString(), Math.min(count, 2));\n  },\n  s: function s(date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCSeconds\" : \"getSeconds\"]().toString(), Math.min(count, 2));\n  },\n  S: function S(date, count, useUtc) {\n    return leftPad(date[useUtc ? \"getUTCMilliseconds\" : \"getMilliseconds\"]().toString(), 3).substr(0, count);\n  },\n  x: function x(date, count, useUtc) {\n    var timezoneOffset = useUtc ? 0 : date.getTimezoneOffset(),\n      signPart = timezoneOffset > 0 ? \"-\" : \"+\",\n      timezoneOffsetAbs = Math.abs(timezoneOffset),\n      hours = Math.floor(timezoneOffsetAbs / 60),\n      minutes = timezoneOffsetAbs % 60,\n      hoursPart = leftPad(hours.toString(), 2),\n      minutesPart = leftPad(minutes.toString(), 2);\n    return signPart + hoursPart + (count >= 3 ? \":\" : \"\") + (count > 1 || minutes ? minutesPart : \"\");\n  },\n  X: function X(date, count, useUtc) {\n    if (useUtc || !date.getTimezoneOffset()) {\n      return \"Z\";\n    }\n    return LDML_FORMATTERS.x(date, count, useUtc);\n  },\n  Z: function Z(date, count, useUtc) {\n    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);\n  }\n};\nvar getFormatter = function getFormatter(format, dateParts) {\n  return function (date) {\n    var charIndex,\n      formatter,\n      char,\n      isCurrentCharEqualsNext,\n      charCount = 0,\n      separator = \"'\",\n      isEscaping = false,\n      result = \"\";\n    if (!date) {\n      return null;\n    }\n    if (!format) {\n      return date;\n    }\n    var useUtc = \"Z\" === format[format.length - 1] || \"'Z'\" === format.slice(-3);\n    for (charIndex = 0; charIndex < format.length; charIndex++) {\n      char = format[charIndex];\n      formatter = LDML_FORMATTERS[char];\n      isCurrentCharEqualsNext = char === format[charIndex + 1];\n      charCount++;\n      if (!isCurrentCharEqualsNext) {\n        if (formatter && !isEscaping) {\n          result += formatter(date, charCount, useUtc, dateParts);\n        }\n        charCount = 0;\n      }\n      if (char === separator && !isCurrentCharEqualsNext) {\n        isEscaping = !isEscaping;\n      } else {\n        if (isEscaping || !formatter) {\n          result += char;\n        }\n      }\n      if (char === separator && isCurrentCharEqualsNext) {\n        charIndex++;\n      }\n    }\n    return result;\n  };\n};\nmodule.exports.getFormatter = getFormatter;","map":null,"metadata":{},"sourceType":"script"}