{"ast":null,"code":"/**\r\n * DevExtreme (ui/data_grid/ui.data_grid.grouping.core.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\nvar _renderer2 = _interopRequireDefault(_renderer);\nvar _class = require(\"../../core/class\");\nvar _class2 = _interopRequireDefault(_class);\nvar _uiData_grid = require(\"./ui.data_grid.core\");\nvar _uiData_grid2 = _interopRequireDefault(_uiData_grid);\nvar _utils = require(\"../../data/utils\");\nvar _deferred = require(\"../../core/utils/deferred\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nexports.createOffsetFilter = function (path, storeLoadOptions) {\n  var i,\n    j,\n    filterElement,\n    selector,\n    currentFilter,\n    groups = (0, _utils.normalizeSortingInfo)(storeLoadOptions.group),\n    filter = [];\n  for (i = 0; i < path.length; i++) {\n    filterElement = [];\n    for (j = 0; j <= i; j++) {\n      selector = groups[j].selector;\n      if (i === j && (null === path[j] || false === path[j] || true === path[j])) {\n        if (false === path[j]) {\n          filterElement.push([selector, \"=\", groups[j].desc ? true : null]);\n        } else {\n          if (path[j] ? !groups[j].desc : groups[j].desc) {\n            filterElement.push([selector, \"<>\", path[j]]);\n          } else {\n            filterElement.push([selector, \"<>\", null]);\n            filterElement.push([selector, \"=\", null]);\n          }\n        }\n      } else {\n        currentFilter = [selector, i === j ? groups[j].desc ? \">\" : \"<\" : \"=\", path[j]];\n        if (\"<\" === currentFilter[1]) {\n          filterElement.push([currentFilter, \"or\", [selector, \"=\", null]]);\n        } else {\n          filterElement.push(currentFilter);\n        }\n      }\n    }\n    filter.push(_uiData_grid2.default.combineFilters(filterElement));\n  }\n  filter = _uiData_grid2.default.combineFilters(filter, \"or\");\n  return _uiData_grid2.default.combineFilters([filter, storeLoadOptions.filter]);\n};\nexports.GroupingHelper = _class2.default.inherit(function () {\n  var findGroupInfoByKey = function findGroupInfoByKey(groupsInfo, key) {\n    var hash = groupsInfo.hash;\n    return hash && hash[JSON.stringify(key)];\n  };\n  var getGroupInfoIndexByOffset = function getGroupInfoIndexByOffset(groupsInfo, offset) {\n    var index,\n      leftIndex = 0,\n      rightIndex = groupsInfo.length - 1;\n    if (!groupsInfo.length) {\n      return 0;\n    }\n    do {\n      var middleIndex = rightIndex + leftIndex >> 1;\n      if (groupsInfo[middleIndex].offset > offset) {\n        rightIndex = middleIndex;\n      } else {\n        leftIndex = middleIndex;\n      }\n    } while (rightIndex - leftIndex > 1);\n    for (index = leftIndex; index <= rightIndex; index++) {\n      if (groupsInfo[index].offset > offset) {\n        break;\n      }\n    }\n    return index;\n  };\n  var updateGroupInfoOffsets = function updateGroupInfoOffsets(groupsInfo, parents) {\n    var groupInfo, index;\n    parents = parents || [];\n    for (index = 0; index < groupsInfo.length; index++) {\n      groupInfo = groupsInfo[index];\n      if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {\n        groupInfo.offset = groupInfo.data.offset;\n        for (var parentIndex = 0; parentIndex < parents.length; parentIndex++) {\n          parents[parentIndex].offset = groupInfo.offset;\n        }\n      }\n    }\n    groupsInfo.sort(function (a, b) {\n      return a.offset - b.offset;\n    });\n  };\n  var cleanGroupsInfo = function cleanGroupsInfo(groupsInfo, groupIndex, groupsCount) {\n    var i;\n    for (i = 0; i < groupsInfo.length; i++) {\n      if (groupIndex + 1 >= groupsCount) {\n        groupsInfo[i].children = [];\n      } else {\n        cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount);\n      }\n    }\n  };\n  var calculateItemsCount = function calculateItemsCount(that, items, groupsCount) {\n    var i,\n      result = 0;\n    if (items) {\n      if (!groupsCount) {\n        result = items.length;\n      } else {\n        for (i = 0; i < items.length; i++) {\n          if (that.isGroupItemCountable(items[i])) {\n            result++;\n          }\n          result += calculateItemsCount(that, items[i].items, groupsCount - 1);\n        }\n      }\n    }\n    return result;\n  };\n  return {\n    ctor: function ctor(dataSourceAdapter) {\n      this._dataSource = dataSourceAdapter;\n      this.reset();\n    },\n    reset: function reset() {\n      this._groupsInfo = [];\n      this._totalCountCorrection = 0;\n    },\n    totalCountCorrection: function totalCountCorrection() {\n      return this._totalCountCorrection;\n    },\n    updateTotalItemsCount: function updateTotalItemsCount(totalCountCorrection) {\n      this._totalCountCorrection = totalCountCorrection || 0;\n    },\n    isGroupItemCountable: function isGroupItemCountable(item) {\n      return !this._isVirtualPaging() || !item.isContinuation;\n    },\n    _isVirtualPaging: function _isVirtualPaging() {\n      var scrollingMode = this._dataSource.option(\"scrolling.mode\");\n      return \"virtual\" === scrollingMode || \"infinite\" === scrollingMode;\n    },\n    itemsCount: function itemsCount() {\n      var dataSourceAdapter = this._dataSource,\n        dataSource = dataSourceAdapter._dataSource,\n        groupCount = _uiData_grid2.default.normalizeSortingInfo(dataSource.group() || []).length,\n        itemsCount = calculateItemsCount(this, dataSource.items(), groupCount);\n      return itemsCount;\n    },\n    foreachGroups: function foreachGroups(callback, childrenAtFirst, foreachCollapsedGroups, updateOffsets, updateParentOffsets) {\n      var that = this;\n      function foreachGroupsCore(groupsInfo, callback, childrenAtFirst, parents) {\n        var i,\n          callbackResult,\n          callbackResults = [];\n        function executeCallback(callback, data, parents, callbackResults) {\n          var callbackResult = data && callback(data, parents);\n          callbackResult && callbackResults.push(callbackResult);\n          return callbackResult;\n        }\n        for (i = 0; i < groupsInfo.length; i++) {\n          parents.push(groupsInfo[i].data);\n          if (!childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\n            return false;\n          }\n          if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups) {\n            callbackResult = foreachGroupsCore(groupsInfo[i].children, callback, childrenAtFirst, parents);\n            callbackResult && callbackResults.push(callbackResult);\n            if (false === callbackResult) {\n              return false;\n            }\n          }\n          if (childrenAtFirst && false === executeCallback(callback, groupsInfo[i].data, parents, callbackResults)) {\n            return false;\n          }\n          if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {\n            updateOffsets = true;\n          }\n          parents.pop();\n        }\n        var currentParents = updateParentOffsets && parents.slice(0);\n        return updateOffsets && _deferred.when.apply(_renderer2.default, callbackResults).always(function () {\n          updateGroupInfoOffsets(groupsInfo, currentParents);\n        });\n      }\n      return foreachGroupsCore(that._groupsInfo, callback, childrenAtFirst, []);\n    },\n    findGroupInfo: function findGroupInfo(path) {\n      var pathIndex,\n        groupInfo,\n        that = this,\n        groupsInfo = that._groupsInfo;\n      for (pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {\n        groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\n        groupsInfo = groupInfo && groupInfo.children;\n      }\n      return groupInfo && groupInfo.data;\n    },\n    addGroupInfo: function addGroupInfo(groupInfoData) {\n      var index,\n        groupInfo,\n        pathIndex,\n        that = this,\n        path = groupInfoData.path,\n        groupsInfo = that._groupsInfo;\n      for (pathIndex = 0; pathIndex < path.length; pathIndex++) {\n        groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);\n        if (!groupInfo) {\n          groupInfo = {\n            key: path[pathIndex],\n            offset: groupInfoData.offset,\n            data: {\n              offset: groupInfoData.offset,\n              isExpanded: true,\n              path: path.slice(0, pathIndex + 1)\n            },\n            children: []\n          };\n          index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);\n          groupsInfo.splice(index, 0, groupInfo);\n          groupsInfo.hash = groupsInfo.hash || {};\n          groupsInfo.hash[JSON.stringify(groupInfo.key)] = groupInfo;\n        }\n        if (pathIndex === path.length - 1) {\n          groupInfo.data = groupInfoData;\n          if (groupInfo.offset !== groupInfoData.offset) {\n            updateGroupInfoOffsets(groupsInfo);\n          }\n        }\n        groupsInfo = groupInfo.children;\n      }\n    },\n    allowCollapseAll: function allowCollapseAll() {\n      return true;\n    },\n    refresh: function refresh(options) {\n      var groupIndex,\n        that = this,\n        storeLoadOptions = options.storeLoadOptions,\n        groups = (0, _utils.normalizeSortingInfo)(storeLoadOptions.group || []),\n        oldGroups = \"_group\" in that ? (0, _utils.normalizeSortingInfo)(that._group || []) : groups,\n        groupsCount = Math.min(oldGroups.length, groups.length);\n      that._group = storeLoadOptions.group;\n      for (groupIndex = 0; groupIndex < groupsCount; groupIndex++) {\n        if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {\n          groupsCount = groupIndex;\n          break;\n        }\n      }\n      if (!groupsCount) {\n        that.reset();\n      } else {\n        cleanGroupsInfo(that._groupsInfo, 0, groupsCount);\n      }\n    },\n    handleDataLoading: function handleDataLoading() {},\n    handleDataLoaded: function handleDataLoaded(options, callBase) {\n      callBase(options);\n    },\n    handleDataLoadedCore: function handleDataLoadedCore(options, callBase) {\n      callBase(options);\n    }\n  };\n}());","map":null,"metadata":{},"sourceType":"script"}