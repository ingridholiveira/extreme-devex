{"ast":null,"code":"/**\r\n * DevExtreme (ui/data_grid/aggregate_calculator.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _class = require(\"../../core/class\");\nvar _class2 = _interopRequireDefault(_class);\nvar _data = require(\"../../core/utils/data\");\nvar _type = require(\"../../core/utils/type\");\nvar _errors = require(\"../../data/errors\");\nvar _utils = require(\"../../data/utils\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction depthFirstSearch(i, depth, root, callback) {\n  var j = 0;\n  if (i < depth) {\n    for (; j < root.items.length; j++) {\n      depthFirstSearch(i + 1, depth, root.items[j], callback);\n    }\n  }\n  if (i === depth) {\n    callback(root);\n  }\n}\nfunction map(array, callback) {\n  var i, result;\n  if (\"map\" in array) {\n    return array.map(callback);\n  }\n  result = new Array(array.length);\n  for (i in array) {\n    result[i] = callback(array[i], i);\n  }\n  return result;\n}\nfunction isEmpty(x) {\n  return x !== x || \"\" === x || null === x || void 0 === x;\n}\nfunction isCount(aggregator) {\n  return aggregator === _utils.aggregators.count;\n}\nfunction normalizeAggregate(aggregate) {\n  var selector = (0, _data.compileGetter)(aggregate.selector),\n    skipEmptyValues = \"skipEmptyValues\" in aggregate ? aggregate.skipEmptyValues : true,\n    aggregator = aggregate.aggregator;\n  if (\"string\" === typeof aggregator) {\n    aggregator = _utils.aggregators[aggregator];\n    if (!aggregator) {\n      throw _errors.errors.Error(\"E4001\", aggregate.aggregator);\n    }\n  }\n  return {\n    selector: selector,\n    aggregator: aggregator,\n    skipEmptyValues: skipEmptyValues\n  };\n}\nmodule.exports = _class2.default.inherit({\n  ctor: function ctor(options) {\n    this._data = options.data;\n    this._groupLevel = options.groupLevel || 0;\n    this._totalAggregates = map(options.totalAggregates || [], normalizeAggregate);\n    this._groupAggregates = map(options.groupAggregates || [], normalizeAggregate);\n    this._totals = [];\n  },\n  calculate: function calculate() {\n    if (this._totalAggregates.length) {\n      this._calculateTotals(0, {\n        items: this._data\n      });\n    }\n    if (this._groupAggregates.length && this._groupLevel > 0) {\n      this._calculateGroups({\n        items: this._data\n      });\n    }\n  },\n  totalAggregates: function totalAggregates() {\n    return this._totals;\n  },\n  _aggregate: function _aggregate(aggregates, data, container) {\n    var i,\n      j,\n      length = data.items ? data.items.length : 0;\n    for (i = 0; i < aggregates.length; i++) {\n      if (isCount(aggregates[i].aggregator)) {\n        container[i] = (container[i] || 0) + length;\n        continue;\n      }\n      for (j = 0; j < length; j++) {\n        this._accumulate(i, aggregates[i], container, data.items[j]);\n      }\n    }\n  },\n  _calculateTotals: function _calculateTotals(level, data) {\n    var i;\n    if (0 === level) {\n      this._totals = this._seed(this._totalAggregates);\n    }\n    if (level === this._groupLevel) {\n      this._aggregate(this._totalAggregates, data, this._totals);\n    } else {\n      for (i = 0; i < data.items.length; i++) {\n        this._calculateTotals(level + 1, data.items[i]);\n      }\n    }\n    if (0 === level) {\n      this._totals = this._finalize(this._totalAggregates, this._totals);\n    }\n  },\n  _calculateGroups: function _calculateGroups(root) {\n    var maxLevel = this._groupLevel,\n      currentLevel = maxLevel + 1,\n      seedFn = this._seed.bind(this, this._groupAggregates),\n      stepFn = this._aggregate.bind(this, this._groupAggregates),\n      finalizeFn = this._finalize.bind(this, this._groupAggregates);\n    function aggregator(node) {\n      node.aggregates = seedFn(currentLevel - 1);\n      if (currentLevel === maxLevel) {\n        stepFn(node, node.aggregates);\n      } else {\n        depthFirstSearch(currentLevel, maxLevel, node, function (innerNode) {\n          stepFn(innerNode, node.aggregates);\n        });\n      }\n      node.aggregates = finalizeFn(node.aggregates);\n    }\n    while (--currentLevel > 0) {\n      depthFirstSearch(0, currentLevel, root, aggregator);\n    }\n  },\n  _seed: function _seed(aggregates, groupIndex) {\n    return map(aggregates, function (aggregate) {\n      var aggregator = aggregate.aggregator,\n        seed = \"seed\" in aggregator ? (0, _type.isFunction)(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;\n      return seed;\n    });\n  },\n  _accumulate: function _accumulate(aggregateIndex, aggregate, results, item) {\n    var value = aggregate.selector(item),\n      aggregator = aggregate.aggregator,\n      skipEmptyValues = aggregate.skipEmptyValues;\n    if (skipEmptyValues && isEmpty(value)) {\n      return;\n    }\n    if (results[aggregateIndex] !== results[aggregateIndex]) {\n      results[aggregateIndex] = value;\n    } else {\n      results[aggregateIndex] = aggregator.step(results[aggregateIndex], value);\n    }\n  },\n  _finalize: function _finalize(aggregates, results) {\n    return map(aggregates, function (aggregate, index) {\n      var fin = aggregate.aggregator.finalize;\n      return fin ? fin(results[index]) : results[index];\n    });\n  }\n});","map":null,"metadata":{},"sourceType":"script"}