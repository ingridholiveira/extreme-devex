{"ast":null,"code":"/**\r\n * DevExtreme (ui/grid_core/ui.grid_core.columns_controller.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\nvar _renderer2 = _interopRequireDefault(_renderer);\nvar _callbacks = require(\"../../core/utils/callbacks\");\nvar _callbacks2 = _interopRequireDefault(_callbacks);\nvar _variable_wrapper = require(\"../../core/utils/variable_wrapper\");\nvar _data = require(\"../../core/utils/data\");\nvar _data2 = _interopRequireDefault(_data);\nvar _common = require(\"../../core/utils/common\");\nvar _type = require(\"../../core/utils/type\");\nvar _iterator = require(\"../../core/utils/iterator\");\nvar _iterator2 = _interopRequireDefault(_iterator);\nvar _position = require(\"../../core/utils/position\");\nvar _extend = require(\"../../core/utils/extend\");\nvar _array = require(\"../../core/utils/array\");\nvar _config = require(\"../../core/config\");\nvar _config2 = _interopRequireDefault(_config);\nvar _object = require(\"../../core/utils/object\");\nvar _ui = require(\"../widget/ui.errors\");\nvar _ui2 = _interopRequireDefault(_ui);\nvar _uiGrid_core = require(\"./ui.grid_core.modules\");\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\nvar _uiGrid_core3 = require(\"./ui.grid_core.utils\");\nvar _inflector = require(\"../../core/utils/inflector\");\nvar _inflector2 = _interopRequireDefault(_inflector);\nvar _date_serialization = require(\"../../core/utils/date_serialization\");\nvar _date_serialization2 = _interopRequireDefault(_date_serialization);\nvar _number = require(\"../../localization/number\");\nvar _number2 = _interopRequireDefault(_number);\nvar _date = require(\"../../localization/date\");\nvar _date2 = _interopRequireDefault(_date);\nvar _message = require(\"../../localization/message\");\nvar _message2 = _interopRequireDefault(_message);\nvar _deferred = require(\"../../core/utils/deferred\");\nvar _abstract_store = require(\"../../data/abstract_store\");\nvar _abstract_store2 = _interopRequireDefault(_abstract_store);\nvar _data_source = require(\"../../data/data_source/data_source\");\nvar _filtering = require(\"../shared/filtering\");\nvar _filtering2 = _interopRequireDefault(_filtering);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar USER_STATE_FIELD_NAMES_15_1 = [\"filterValues\", \"filterType\", \"fixed\", \"fixedPosition\"],\n  USER_STATE_FIELD_NAMES = [\"visibleIndex\", \"dataField\", \"name\", \"dataType\", \"width\", \"visible\", \"sortOrder\", \"lastSortOrder\", \"sortIndex\", \"groupIndex\", \"filterValue\", \"selectedFilterOperation\", \"added\"].concat(USER_STATE_FIELD_NAMES_15_1),\n  IGNORE_COLUMN_OPTION_NAMES = {\n    visibleWidth: true,\n    bestFitWidth: true,\n    bufferedFilterValue: true\n  },\n  COMMAND_EXPAND_CLASS = \"dx-command-expand\",\n  MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  GROUP_COMMAND_COLUMN_NAME = \"groupExpand\";\nvar regExp = /columns\\[(\\d+)\\]\\.?/gi;\nvar globalColumnId = 1;\nmodule.exports = {\n  defaultOptions: function defaultOptions() {\n    return {\n      commonColumnSettings: {\n        allowFiltering: true,\n        allowHiding: true,\n        allowSorting: true,\n        allowEditing: true,\n        encodeHtml: true,\n        trueText: _message2.default.format(\"dxDataGrid-trueText\"),\n        falseText: _message2.default.format(\"dxDataGrid-falseText\")\n      },\n      allowColumnReordering: false,\n      allowColumnResizing: false,\n      columnResizingMode: \"nextColumn\",\n      columnMinWidth: void 0,\n      columnWidth: void 0,\n      adaptColumnWidthByRatio: true,\n      columns: void 0,\n      regenerateColumnsByVisibleItems: false,\n      customizeColumns: null,\n      dateSerializationFormat: void 0\n    };\n  },\n  controllers: {\n    columns: _uiGrid_core2.default.Controller.inherit(function () {\n      var DEFAULT_COLUMN_OPTIONS = {\n          visible: true,\n          showInColumnChooser: true\n        },\n        DATATYPE_OPERATIONS = {\n          number: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"],\n          string: [\"contains\", \"notcontains\", \"startswith\", \"endswith\", \"=\", \"<>\"],\n          date: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"],\n          datetime: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"]\n        },\n        COLUMN_INDEX_OPTIONS = {\n          visibleIndex: true,\n          groupIndex: true,\n          grouped: true,\n          sortIndex: true,\n          sortOrder: true\n        },\n        GROUP_LOCATION = \"group\",\n        COLUMN_CHOOSER_LOCATION = \"columnChooser\";\n      var setFilterOperationsAsDefaultValues = function setFilterOperationsAsDefaultValues(column) {\n        column.filterOperations = column.defaultFilterOperations;\n      };\n      var createColumn = function createColumn(that, columnOptions, userStateColumnOptions, bandColumn) {\n        var calculatedColumnOptions,\n          commonColumnOptions = {};\n        if (columnOptions) {\n          if ((0, _type.isString)(columnOptions)) {\n            columnOptions = {\n              dataField: columnOptions\n            };\n          }\n          var result = void 0;\n          if (columnOptions.command) {\n            result = (0, _object.deepExtendArraySafe)(commonColumnOptions, columnOptions);\n          } else {\n            commonColumnOptions = that.getCommonSettings(columnOptions);\n            if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {\n              columnOptions = (0, _extend.extend)({}, columnOptions, {\n                dataField: userStateColumnOptions.dataField\n              });\n            }\n            calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);\n            result = (0, _object.deepExtendArraySafe)({\n              headerId: \"dx-col-\" + globalColumnId++\n            }, DEFAULT_COLUMN_OPTIONS);\n            (0, _object.deepExtendArraySafe)(result, commonColumnOptions);\n            (0, _object.deepExtendArraySafe)(result, calculatedColumnOptions);\n            (0, _object.deepExtendArraySafe)(result, columnOptions);\n            (0, _object.deepExtendArraySafe)(result, {\n              selector: null\n            });\n          }\n          if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {\n            setFilterOperationsAsDefaultValues(result);\n          }\n          return result;\n        }\n      };\n      var createColumnsFromOptions = function createColumnsFromOptions(that, columnsOptions, bandColumn) {\n        var result = [];\n        if (columnsOptions) {\n          _iterator2.default.each(columnsOptions, function (index, columnOptions) {\n            var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index],\n              column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);\n            if (column) {\n              if (bandColumn) {\n                column.ownerBand = bandColumn;\n              }\n              result.push(column);\n              if (column.isBand) {\n                result = result.concat(createColumnsFromOptions(that, column.columns, column));\n                delete column.columns;\n              }\n            }\n          });\n        }\n        return result;\n      };\n      var getParentBandColumns = function getParentBandColumns(columnIndex, columnParentByIndex) {\n        var result = [],\n          parent = columnParentByIndex[columnIndex];\n        while (parent) {\n          result.unshift(parent);\n          columnIndex = parent.index;\n          parent = columnParentByIndex[columnIndex];\n        }\n        return result;\n      };\n      var _getChildrenByBandColumn = function _getChildrenByBandColumn(columnIndex, columnChildrenByIndex, recursive) {\n        var column,\n          result = [],\n          children = columnChildrenByIndex[columnIndex];\n        if (children) {\n          for (var i = 0; i < children.length; i++) {\n            column = children[i];\n            if (!(0, _type.isDefined)(column.groupIndex) || column.showWhenGrouped) {\n              result.push(column);\n              if (recursive && column.isBand) {\n                result = result.concat(_getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive));\n              }\n            }\n          }\n        }\n        return result;\n      };\n      var getColumnByIndexes = function getColumnByIndexes(that, columnIndexes) {\n        var result,\n          callbackFilter = function callbackFilter(column) {\n            var ownerBand = result ? result.index : void 0;\n            return column.ownerBand === ownerBand;\n          },\n          columns = that._columns.filter(callbackFilter);\n        for (var i = 0; i < columnIndexes.length; i++) {\n          result = columns[columnIndexes[i]];\n          if (result) {\n            columns = that._columns.filter(callbackFilter);\n          }\n        }\n        return result;\n      };\n      var getColumnFullPath = function getColumnFullPath(that, column) {\n        var result = [],\n          bandColumnsCache = that.getBandColumnsCache(),\n          callbackFilter = function callbackFilter(item) {\n            return item.ownerBand === column.ownerBand;\n          },\n          columns = that._columns.filter(callbackFilter);\n        while (columns.length && columns.indexOf(column) !== -1) {\n          result.unshift(\"columns[\" + columns.indexOf(column) + \"]\");\n          column = bandColumnsCache.columnParentByIndex[column.index];\n          columns = column ? that._columns.filter(callbackFilter) : [];\n        }\n        return result.join(\".\");\n      };\n      var calculateColspan = function calculateColspan(that, columnID) {\n        var colspan = 0,\n          columns = that.getChildrenByBandColumn(columnID, true);\n        _iterator2.default.each(columns, function (_, column) {\n          if (column.isBand) {\n            column.colspan = column.colspan || calculateColspan(that, column.index);\n            colspan += column.colspan || 1;\n          } else {\n            colspan += 1;\n          }\n        });\n        return colspan;\n      };\n      var processBandColumns = function processBandColumns(that, columns, bandColumnsCache) {\n        var i,\n          column,\n          rowspan,\n          rowCount = that.getRowCount();\n        for (i = 0; i < columns.length; i++) {\n          column = columns[i];\n          if (column.visible || column.command) {\n            if (column.isBand) {\n              column.colspan = column.colspan || calculateColspan(that, column.index);\n            }\n            if (!column.isBand || !column.colspan) {\n              rowspan = rowCount - (!column.command && !(0, _type.isDefined)(column.groupIndex) ? getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length : 0);\n              if (rowspan > 1) {\n                column.rowspan = rowspan;\n              }\n            }\n          }\n        }\n      };\n      var getValueDataType = function getValueDataType(value) {\n        var dataType = (0, _type.type)(value);\n        if (\"string\" !== dataType && \"boolean\" !== dataType && \"number\" !== dataType && \"date\" !== dataType && \"object\" !== dataType) {\n          dataType = void 0;\n        }\n        return dataType;\n      };\n      var getSerializationFormat = function getSerializationFormat(dataType, value) {\n        switch (dataType) {\n          case \"date\":\n          case \"datetime\":\n            return _date_serialization2.default.getDateSerializationFormat(value);\n          case \"number\":\n            if ((0, _type.isString)(value)) {\n              return \"string\";\n            }\n            if ((0, _type.isNumeric)(value)) {\n              return null;\n            }\n        }\n      };\n      var updateSerializers = function updateSerializers(options, dataType) {\n        if (!options.deserializeValue) {\n          if ((0, _uiGrid_core3.isDateType)(dataType)) {\n            options.deserializeValue = function (value) {\n              return _date_serialization2.default.deserializeDate(value);\n            };\n            options.serializeValue = function (value) {\n              return (0, _type.isString)(value) ? value : _date_serialization2.default.serializeDate(value, this.serializationFormat);\n            };\n          }\n          if (\"number\" === dataType) {\n            options.deserializeValue = function (value) {\n              var parsedValue = parseFloat(value);\n              return isNaN(parsedValue) ? value : parsedValue;\n            };\n            options.serializeValue = function (value, target) {\n              if (\"filter\" === target) {\n                return value;\n              }\n              return (0, _type.isDefined)(value) && \"string\" === this.serializationFormat ? value.toString() : value;\n            };\n          }\n        }\n      };\n      var getAlignmentByDataType = function getAlignmentByDataType(dataType, isRTL) {\n        switch (dataType) {\n          case \"number\":\n            return \"right\";\n          case \"boolean\":\n            return \"center\";\n          default:\n            return (0, _position.getDefaultAlignment)(isRTL);\n        }\n      };\n      var getCustomizeTextByDataType = function getCustomizeTextByDataType(dataType) {\n        if (\"boolean\" === dataType) {\n          return function (e) {\n            if (true === e.value) {\n              return this.trueText || \"true\";\n            } else {\n              if (false === e.value) {\n                return this.falseText || \"false\";\n              } else {\n                return e.valueText || \"\";\n              }\n            }\n          };\n        }\n      };\n      var createColumnsFromDataSource = function createColumnsFromDataSource(that, dataSource) {\n        var fieldName,\n          i,\n          firstItems = that._getFirstItems(dataSource),\n          processedFields = {},\n          result = [];\n        for (i = 0; i < firstItems.length; i++) {\n          if (firstItems[i]) {\n            for (fieldName in firstItems[i]) {\n              if (!(0, _type.isFunction)(firstItems[i][fieldName]) || (0, _variable_wrapper.isWrapped)(firstItems[i][fieldName])) {\n                processedFields[fieldName] = true;\n              }\n            }\n          }\n        }\n        for (fieldName in processedFields) {\n          if (0 !== fieldName.indexOf(\"__\")) {\n            var column = createColumn(that, fieldName);\n            result.push(column);\n          }\n        }\n        return result;\n      };\n      var updateColumnIndexes = function updateColumnIndexes(that) {\n        _iterator2.default.each(that._columns, function (index, column) {\n          column.index = index;\n        });\n        _iterator2.default.each(that._columns, function (index, column) {\n          if ((0, _type.isObject)(column.ownerBand)) {\n            column.ownerBand = column.ownerBand.index;\n          }\n        });\n        _iterator2.default.each(that._commandColumns, function (index, column) {\n          column.index = -(index + 1);\n        });\n      };\n      var updateColumnGroupIndexes = function updateColumnGroupIndexes(that, currentColumn) {\n        (0, _array.normalizeIndexes)(that._columns, \"groupIndex\", currentColumn, function (column) {\n          var grouped = column.grouped;\n          delete column.grouped;\n          return grouped;\n        });\n      };\n      var updateColumnSortIndexes = function updateColumnSortIndexes(that, currentColumn) {\n        _iterator2.default.each(that._columns, function (index, column) {\n          if ((0, _type.isDefined)(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {\n            delete column.sortIndex;\n          }\n        });\n        (0, _array.normalizeIndexes)(that._columns, \"sortIndex\", currentColumn, function (column) {\n          return !(0, _type.isDefined)(column.groupIndex) && isSortOrderValid(column.sortOrder);\n        });\n      };\n      var updateColumnVisibleIndexes = function updateColumnVisibleIndexes(that, currentColumn) {\n        var i,\n          key,\n          column,\n          bandColumnIndex,\n          parentBandColumns,\n          bandColumns = {},\n          result = [],\n          bandColumnsCache = that.getBandColumnsCache(),\n          columns = that._columns.filter(function (column) {\n            return !column.command;\n          });\n        for (i = 0; i < columns.length; i++) {\n          column = columns[i];\n          parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);\n          if (parentBandColumns.length) {\n            bandColumnIndex = parentBandColumns[parentBandColumns.length - 1].index;\n            bandColumns[bandColumnIndex] = bandColumns[bandColumnIndex] || [];\n            bandColumns[bandColumnIndex].push(column);\n          } else {\n            result.push(column);\n          }\n        }\n        for (key in bandColumns) {\n          (0, _array.normalizeIndexes)(bandColumns[key], \"visibleIndex\", currentColumn);\n        }\n        (0, _array.normalizeIndexes)(result, \"visibleIndex\", currentColumn);\n      };\n      var getColumnIndexByVisibleIndex = function getColumnIndexByVisibleIndex(that, visibleIndex, location) {\n        var column,\n          rowIndex = (0, _type.isObject)(visibleIndex) ? visibleIndex.rowIndex : null,\n          columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);\n        visibleIndex = (0, _type.isObject)(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;\n        column = columns[visibleIndex];\n        if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {\n          column = that._columns.filter(function (col) {\n            return column.type === col.type;\n          })[0] || column;\n        }\n        return column && (0, _type.isDefined)(column.index) ? column.index : -1;\n      };\n      var moveColumnToGroup = function moveColumnToGroup(that, column, groupIndex) {\n        var i,\n          groupColumns = that.getGroupColumns();\n        if (groupIndex >= 0) {\n          for (i = 0; i < groupColumns.length; i++) {\n            if (groupColumns[i].groupIndex >= groupIndex) {\n              groupColumns[i].groupIndex++;\n            }\n          }\n        } else {\n          groupIndex = 0;\n          for (i = 0; i < groupColumns.length; i++) {\n            groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1);\n          }\n        }\n        return groupIndex;\n      };\n      var checkUserStateColumn = function checkUserStateColumn(column, userStateColumn) {\n        return column && userStateColumn && userStateColumn.name === column.name && (userStateColumn.dataField === column.dataField || column.name);\n      };\n      var applyUserState = function applyUserState(that) {\n        var column,\n          columnUserState,\n          userStateColumnIndex,\n          i,\n          columnsUserState = that._columnsUserState,\n          ignoreColumnOptionNames = that._ignoreColumnOptionNames || [],\n          columns = that._columns,\n          columnCountById = {},\n          resultColumns = [],\n          allColumnsHaveState = true,\n          userStateColumnIndexes = [];\n        function applyFieldsState(column, userStateColumn) {\n          var fieldName;\n          if (!userStateColumn) {\n            return;\n          }\n          for (var index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {\n            fieldName = USER_STATE_FIELD_NAMES[index];\n            if ((0, _array.inArray)(fieldName, ignoreColumnOptionNames) >= 0) {\n              continue;\n            }\n            if (\"dataType\" === fieldName) {\n              column[fieldName] = column[fieldName] || userStateColumn[fieldName];\n            } else {\n              if ((0, _array.inArray)(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {\n                if (fieldName in userStateColumn) {\n                  column[fieldName] = userStateColumn[fieldName];\n                }\n              } else {\n                if (\"selectedFilterOperation\" === fieldName && userStateColumn[fieldName]) {\n                  column.defaultSelectedFilterOperation = column[fieldName] || null;\n                }\n                column[fieldName] = userStateColumn[fieldName];\n              }\n            }\n          }\n        }\n        function findUserStateColumn(columnsUserState, column) {\n          var id = column.name || column.dataField,\n            count = columnCountById[id] || 0;\n          for (var j = 0; j < columnsUserState.length; j++) {\n            if (checkUserStateColumn(column, columnsUserState[j])) {\n              if (count) {\n                count--;\n              } else {\n                columnCountById[id] = columnCountById[id] || 0;\n                columnCountById[id]++;\n                return j;\n              }\n            }\n          }\n          return -1;\n        }\n        if (columnsUserState) {\n          for (i = 0; i < columns.length; i++) {\n            userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);\n            allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;\n            userStateColumnIndexes.push(userStateColumnIndex);\n          }\n          for (i = 0; i < columns.length; i++) {\n            column = columns[i];\n            userStateColumnIndex = userStateColumnIndexes[i];\n            if (that._hasUserState || allColumnsHaveState) {\n              applyFieldsState(column, columnsUserState[userStateColumnIndex]);\n            }\n            if (userStateColumnIndex >= 0 && (0, _type.isDefined)(columnsUserState[userStateColumnIndex].initialIndex)) {\n              resultColumns[userStateColumnIndex] = column;\n            } else {\n              resultColumns.push(column);\n            }\n          }\n          var hasAddedBands = false;\n          for (i = 0; i < columnsUserState.length; i++) {\n            columnUserState = columnsUserState[i];\n            if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {\n              column = createColumn(that, columnUserState.added);\n              applyFieldsState(column, columnUserState);\n              resultColumns.push(column);\n              if (columnUserState.added.columns) {\n                hasAddedBands = true;\n              }\n            }\n          }\n          if (hasAddedBands) {\n            updateColumnIndexes(that);\n            resultColumns = createColumnsFromOptions(that, resultColumns);\n          }\n          assignColumns(that, resultColumns);\n        }\n      };\n      var updateIndexes = function updateIndexes(that, column) {\n        updateColumnIndexes(that);\n        updateColumnGroupIndexes(that, column);\n        updateColumnSortIndexes(that, column);\n        updateColumnVisibleIndexes(that, column);\n      };\n      var resetColumnsCache = function resetColumnsCache(that) {\n        that.resetColumnsCache();\n      };\n      var assignColumns = function assignColumns(that, columns) {\n        that._columns = columns;\n        resetColumnsCache(that);\n        that.updateColumnDataTypes();\n      };\n      var updateColumnChanges = function updateColumnChanges(that, changeType, optionName, columnIndex) {\n        var columnChanges = that._columnChanges || {\n          optionNames: {\n            length: 0\n          },\n          changeTypes: {\n            length: 0\n          },\n          columnIndex: columnIndex\n        };\n        optionName = optionName || \"all\";\n        optionName = optionName.split(\".\")[0];\n        var changeTypes = columnChanges.changeTypes;\n        if (changeType && !changeTypes[changeType]) {\n          changeTypes[changeType] = true;\n          changeTypes.length++;\n        }\n        var optionNames = columnChanges.optionNames;\n        if (optionName && !optionNames[optionName]) {\n          optionNames[optionName] = true;\n          optionNames.length++;\n        }\n        if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {\n          delete columnChanges.columnIndex;\n        }\n        that._columnChanges = columnChanges;\n        resetColumnsCache(that);\n      };\n      var fireColumnsChanged = function fireColumnsChanged(that) {\n        var onColumnsChanging = that.option(\"onColumnsChanging\"),\n          columnChanges = that._columnChanges;\n        if (that.isInitialized() && !that._updateLockCount && columnChanges) {\n          if (onColumnsChanging) {\n            that._updateLockCount++;\n            onColumnsChanging((0, _extend.extend)({\n              component: that.component\n            }, columnChanges));\n            that._updateLockCount--;\n          }\n          that._columnChanges = void 0;\n          if (columnChanges.optionNames && (columnChanges.optionNames.dataField || columnChanges.optionNames.lookup || columnChanges.optionNames.dataType)) {\n            that.reinit();\n          } else {\n            that.columnsChanged.fire(columnChanges);\n          }\n        }\n      };\n      var updateSortOrderWhenGrouping = function updateSortOrderWhenGrouping(column, groupIndex, prevGroupIndex) {\n        var columnWasGrouped = prevGroupIndex >= 0;\n        if (groupIndex >= 0) {\n          if (!columnWasGrouped) {\n            column.lastSortOrder = column.sortOrder;\n          }\n        } else {\n          column.sortOrder = column.lastSortOrder;\n        }\n      };\n      var fireOptionChanged = function fireOptionChanged(that, options) {\n        var value = options.value,\n          optionName = options.optionName,\n          prevValue = options.prevValue,\n          fullOptionName = options.fullOptionName;\n        if (!IGNORE_COLUMN_OPTION_NAMES[optionName]) {\n          var oldSkipProcessingColumnsChange = that._skipProcessingColumnsChange;\n          that._skipProcessingColumnsChange = true;\n          var columnOptions = that.component.option(fullOptionName);\n          if ((0, _type.isPlainObject)(columnOptions)) {\n            columnOptions[optionName] = value;\n          }\n          that.component._notifyOptionChanged(fullOptionName + \".\" + optionName, value, prevValue);\n          that._skipProcessingColumnsChange = oldSkipProcessingColumnsChange;\n        }\n      };\n      var columnOptionCore = function columnOptionCore(that, column, optionName, value, notFireEvent) {\n        var prevValue,\n          optionSetter,\n          columns,\n          changeType,\n          fullOptionName,\n          initialColumn,\n          optionGetter = _data2.default.compileGetter(optionName),\n          columnIndex = column.index;\n        if (3 === arguments.length) {\n          return optionGetter(column, {\n            functionsAsIs: true\n          });\n        }\n        prevValue = optionGetter(column, {\n          functionsAsIs: true\n        });\n        if (prevValue !== value) {\n          if (\"groupIndex\" === optionName || \"calculateGroupValue\" === optionName) {\n            changeType = \"grouping\";\n            updateSortOrderWhenGrouping(column, value, prevValue);\n          } else {\n            if (\"sortIndex\" === optionName || \"sortOrder\" === optionName || \"calculateSortValue\" === optionName) {\n              changeType = \"sorting\";\n            } else {\n              changeType = \"columns\";\n            }\n          }\n          optionSetter = _data2.default.compileSetter(optionName);\n          optionSetter(column, value, {\n            functionsAsIs: true\n          });\n          fullOptionName = getColumnFullPath(that, column);\n          fullOptionName && fireOptionChanged(that, {\n            fullOptionName: fullOptionName,\n            optionName: optionName,\n            value: value,\n            prevValue: prevValue\n          });\n          if (!(0, _type.isDefined)(prevValue) && !(0, _type.isDefined)(value) && 0 !== optionName.indexOf(\"buffer\")) {\n            notFireEvent = true;\n          }\n          if (!notFireEvent) {\n            if ((0, _array.inArray)(optionName, USER_STATE_FIELD_NAMES) < 0 && \"visibleWidth\" !== optionName) {\n              columns = that.option(\"columns\");\n              initialColumn = that.getColumnByPath(fullOptionName, columns);\n              if ((0, _type.isString)(initialColumn)) {\n                initialColumn = columns[columnIndex] = {\n                  dataField: initialColumn\n                };\n              }\n              if (initialColumn && checkUserStateColumn(initialColumn, column)) {\n                optionSetter(initialColumn, value, {\n                  functionsAsIs: true\n                });\n              }\n            }\n            updateColumnChanges(that, changeType, optionName, columnIndex);\n          } else {\n            resetColumnsCache(that);\n          }\n        }\n      };\n      var isSortOrderValid = function isSortOrderValid(sortOrder) {\n        return \"asc\" === sortOrder || \"desc\" === sortOrder;\n      };\n      var addExpandColumn = function addExpandColumn(that) {\n        var options = that._getExpandColumnOptions();\n        that.addCommandColumn(options);\n      };\n      var defaultSetCellValue = function defaultSetCellValue(data, value) {\n        var name,\n          i,\n          path = this.dataField.split(\".\"),\n          dotCount = path.length - 1;\n        if (this.serializeValue) {\n          value = this.serializeValue(value);\n        }\n        for (i = 0; i < dotCount; i++) {\n          name = path[i];\n          data = data[name] = data[name] || {};\n        }\n        data[path[dotCount]] = value;\n      };\n      var getDataColumns = function getDataColumns(columns, rowIndex, bandColumnID) {\n        var result = [];\n        rowIndex = rowIndex || 0;\n        columns[rowIndex] && _iterator2.default.each(columns[rowIndex], function (_, column) {\n          if (column.ownerBand === bandColumnID || (0, _type.isDefined)(column.groupIndex)) {\n            if (!column.isBand || !column.colspan) {\n              if (!column.command || rowIndex < 1) {\n                result.push(column);\n              }\n            } else {\n              result.push.apply(result, getDataColumns(columns, rowIndex + 1, column.index));\n            }\n          }\n        });\n        return result;\n      };\n      var _getRowCount = function _getRowCount(that, level, bandColumnIndex) {\n        var rowCount = 1,\n          bandColumnsCache = that.getBandColumnsCache(),\n          columnParentByIndex = bandColumnsCache.columnParentByIndex;\n        that._columns.forEach(function (column) {\n          var parents = getParentBandColumns(column.index, columnParentByIndex),\n            invisibleParents = parents.filter(function (column) {\n              return !column.visible;\n            });\n          if (column.visible && !invisibleParents.length) {\n            rowCount = Math.max(rowCount, parents.length + 1);\n          }\n        });\n        return rowCount;\n      };\n      var getFixedPosition = function getFixedPosition(that, column) {\n        var rtlEnabled = that.option(\"rtlEnabled\");\n        if (column.command && !isCustomCommandColumn(that, column) || !column.fixedPosition) {\n          return rtlEnabled ? \"right\" : \"left\";\n        }\n        return column.fixedPosition;\n      };\n      var processExpandColumns = function processExpandColumns(columns, expandColumns, type, columnIndex) {\n        var customColumnIndex,\n          rowCount = this.getRowCount(),\n          rowspan = columns[columnIndex] && columns[columnIndex].rowspan,\n          expandColumnsByType = expandColumns.filter(function (column) {\n            return column.type === type;\n          });\n        columns.forEach(function (column, index) {\n          if (column.type === type) {\n            customColumnIndex = index;\n            rowspan = columns[index + 1] ? columns[index + 1].rowspan : rowCount;\n          }\n        });\n        if (rowspan > 1) {\n          expandColumnsByType = _iterator2.default.map(expandColumnsByType, function (expandColumn) {\n            return (0, _extend.extend)({}, expandColumn, {\n              rowspan: rowspan\n            });\n          });\n        }\n        expandColumnsByType.unshift.apply(expandColumnsByType, (0, _type.isDefined)(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);\n        columns.splice.apply(columns, expandColumnsByType);\n        return rowspan || 1;\n      };\n      var digitsCount = function digitsCount(number) {\n        var i;\n        for (i = 0; number > 1; i++) {\n          number /= 10;\n        }\n        return i;\n      };\n      var numberToString = function numberToString(number, digitsCount) {\n        var str = number ? number.toString() : \"0\";\n        while (str.length < digitsCount) {\n          str = \"0\" + str;\n        }\n        return str;\n      };\n      var mergeColumns = function mergeColumns(that, columns, commandColumns, needToExtend) {\n        var i,\n          column,\n          columnOptions,\n          commandColumnIndex,\n          result = columns.slice().map(function (column) {\n            return (0, _extend.extend)({}, column);\n          }),\n          isColumnFixing = that._isColumnFixing(),\n          defaultCommandColumns = commandColumns.slice().map(function (column) {\n            return (0, _extend.extend)({\n              fixed: isColumnFixing\n            }, column);\n          }),\n          getCommandColumnIndex = function getCommandColumnIndex(column) {\n            return commandColumns.reduce(function (result, commandColumn, index) {\n              var columnType = needToExtend && column.type === GROUP_COMMAND_COLUMN_NAME ? \"expand\" : column.type;\n              return commandColumn.type === columnType || commandColumn.command === column.command ? index : result;\n            }, -1);\n          },\n          callbackFilter = function callbackFilter(commandColumn) {\n            return commandColumn.command !== commandColumns[commandColumnIndex].command;\n          };\n        for (i = 0; i < columns.length; i++) {\n          column = columns[i];\n          commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;\n          if (commandColumnIndex >= 0) {\n            if (needToExtend) {\n              result[i] = (0, _extend.extend)({\n                fixed: isColumnFixing\n              }, commandColumns[commandColumnIndex], column);\n              if (column.type !== GROUP_COMMAND_COLUMN_NAME) {\n                defaultCommandColumns = defaultCommandColumns.filter(callbackFilter);\n              }\n            } else {\n              columnOptions = {\n                visibleIndex: column.visibleIndex,\n                index: column.index,\n                headerId: column.headerId,\n                allowFixing: 0 === column.groupIndex,\n                allowReordering: 0 === column.groupIndex,\n                groupIndex: column.groupIndex\n              };\n              result[i] = (0, _extend.extend)({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions);\n            }\n          }\n        }\n        if (columns.length && needToExtend && defaultCommandColumns.length) {\n          result = result.concat(defaultCommandColumns);\n        }\n        return result;\n      };\n      var isCustomCommandColumn = function isCustomCommandColumn(that, commandColumn) {\n        return !!that._columns.filter(function (column) {\n          return column.type === commandColumn.type;\n        }).length;\n      };\n      var isColumnFixed = function isColumnFixed(that, column) {\n        return (0, _type.isDefined)(column.fixed) || !column.type ? column.fixed : that._isColumnFixing();\n      };\n      return {\n        _getExpandColumnOptions: function _getExpandColumnOptions() {\n          return {\n            type: \"expand\",\n            command: \"expand\",\n            width: \"auto\",\n            cssClass: COMMAND_EXPAND_CLASS,\n            allowEditing: false,\n            allowGrouping: false,\n            allowSorting: false,\n            allowResizing: false,\n            allowReordering: false,\n            allowHiding: false\n          };\n        },\n        _getFirstItems: function _getFirstItems(dataSource) {\n          var groupsCount,\n            items = [];\n          var getFirstItemsCore = function getFirstItemsCore(items, groupsCount) {\n            var i, childItems;\n            if (!items || !groupsCount) {\n              return items;\n            }\n            for (i = 0; i < items.length; i++) {\n              childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);\n              if (childItems && childItems.length) {\n                return childItems;\n              }\n            }\n          };\n          if (dataSource && dataSource.items().length > 0) {\n            groupsCount = (0, _uiGrid_core3.normalizeSortingInfo)(dataSource.group()).length;\n            items = getFirstItemsCore(dataSource.items(), groupsCount) || [];\n          }\n          return items;\n        },\n        _endUpdateCore: function _endUpdateCore() {\n          !this._skipProcessingColumnsChange && fireColumnsChanged(this);\n        },\n        init: function init() {\n          var that = this,\n            columns = that.option(\"columns\");\n          that._commandColumns = that._commandColumns || [];\n          that._columns = that._columns || [];\n          that._isColumnsFromOptions = !!columns;\n          if (that._isColumnsFromOptions) {\n            assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);\n            applyUserState(that);\n          } else {\n            assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns);\n          }\n          addExpandColumn(that);\n          if (that._dataSourceApplied) {\n            that.applyDataSource(that._dataSource, true);\n          } else {\n            updateIndexes(that);\n          }\n        },\n        callbackNames: function callbackNames() {\n          return [\"columnsChanged\"];\n        },\n        getColumnByPath: function getColumnByPath(path, columns) {\n          var column,\n            that = this,\n            columnIndexes = [];\n          path.replace(regExp, function (_, columnIndex) {\n            columnIndexes.push(parseInt(columnIndex));\n            return \"\";\n          });\n          if (columnIndexes.length) {\n            if (columns) {\n              column = columnIndexes.reduce(function (column, index) {\n                return column && column.columns && column.columns[index];\n              }, {\n                columns: columns\n              });\n            } else {\n              column = getColumnByIndexes(that, columnIndexes);\n            }\n          }\n          return column;\n        },\n        optionChanged: function optionChanged(args) {\n          switch (args.name) {\n            case \"adaptColumnWidthByRatio\":\n              args.handled = true;\n              break;\n            case \"columns\":\n              args.handled = true;\n              if (args.name === args.fullName) {\n                this._columnsUserState = null;\n                this._ignoreColumnOptionNames = null;\n                this.init();\n              } else {\n                if (void 0 === this.option(args.fullName) || this.option(args.fullName) === args.value) {\n                  this._columnOptionChanged(args);\n                  this._updateRequireResize(args);\n                }\n              }\n              break;\n            case \"commonColumnSettings\":\n            case \"columnAutoWidth\":\n            case \"allowColumnResizing\":\n            case \"allowColumnReordering\":\n            case \"columnFixing\":\n            case \"grouping\":\n            case \"groupPanel\":\n            case \"regenerateColumnsByVisibleItems\":\n            case \"customizeColumns\":\n            case \"editing\":\n            case \"columnHidingEnabled\":\n            case \"dateSerializationFormat\":\n            case \"columnResizingMode\":\n            case \"columnMinWidth\":\n            case \"columnWidth\":\n              args.handled = true;\n              if (!(args.fullName && 0 === args.fullName.indexOf(\"editing.popup\"))) {\n                this.reinit();\n              }\n              break;\n            case \"rtlEnabled\":\n              this.reinit();\n              break;\n            default:\n              this.callBase(args);\n          }\n        },\n        _columnOptionChanged: function _columnOptionChanged(args) {\n          var columnOptionValue = {},\n            column = this.getColumnByPath(args.fullName),\n            columnOptionName = args.fullName.replace(regExp, \"\");\n          if (column) {\n            if (columnOptionName) {\n              columnOptionValue[columnOptionName] = args.value;\n            } else {\n              columnOptionValue = args.value;\n            }\n            this.columnOption(column.index, columnOptionValue);\n          }\n        },\n        _updateRequireResize: function _updateRequireResize(args) {\n          var component = this.component;\n          if (\"width\" === args.fullName.replace(regExp, \"\") && component._updateLockCount) {\n            component._requireResize = true;\n          }\n        },\n        publicMethods: function publicMethods() {\n          return [\"addColumn\", \"deleteColumn\", \"columnOption\", \"columnCount\", \"clearSorting\", \"clearGrouping\", \"getVisibleColumns\"];\n        },\n        applyDataSource: function applyDataSource(dataSource, forceApplying) {\n          var that = this,\n            isDataSourceLoaded = dataSource && dataSource.isLoaded();\n          that._dataSource = dataSource;\n          if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option(\"regenerateColumnsByVisibleItems\")) {\n            if (isDataSourceLoaded) {\n              if (!that._isColumnsFromOptions) {\n                var columnsFromDataSource = createColumnsFromDataSource(that, dataSource);\n                if (columnsFromDataSource.length) {\n                  assignColumns(that, columnsFromDataSource);\n                  that._dataSourceColumnsCount = that._columns.length;\n                  applyUserState(that);\n                }\n              }\n              return that.updateColumns(dataSource, forceApplying);\n            } else {\n              that._dataSourceApplied = false;\n            }\n          } else {\n            if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {\n              updateColumnChanges(that, \"columns\");\n              fireColumnsChanged(that);\n              return new _deferred.Deferred().reject().promise();\n            }\n          }\n        },\n        reset: function reset() {\n          this._dataSourceApplied = false;\n          this._dataSourceColumnsCount = void 0;\n          this.reinit();\n        },\n        resetColumnsCache: function resetColumnsCache() {\n          var that = this;\n          that._visibleColumns = void 0;\n          that._fixedColumns = void 0;\n          that._rowCount = void 0;\n          that._bandColumnsCache = void 0;\n        },\n        reinit: function reinit() {\n          this._columnsUserState = this.getUserState();\n          this._ignoreColumnOptionNames = null;\n          this.init();\n        },\n        isInitialized: function isInitialized() {\n          return !!this._columns.length || !!this.option(\"columns\");\n        },\n        isDataSourceApplied: function isDataSourceApplied() {\n          return this._dataSourceApplied;\n        },\n        getCommonSettings: function getCommonSettings(column) {\n          var commonColumnSettings = (!column || !column.type) && this.option(\"commonColumnSettings\") || {},\n            groupingOptions = this.option(\"grouping\") || {},\n            groupPanelOptions = this.option(\"groupPanel\") || {};\n          return (0, _extend.extend)({\n            allowFixing: this.option(\"columnFixing.enabled\"),\n            allowResizing: this.option(\"allowColumnResizing\") || void 0,\n            allowReordering: this.option(\"allowColumnReordering\"),\n            minWidth: this.option(\"columnMinWidth\"),\n            width: this.option(\"columnWidth\"),\n            autoExpandGroup: groupingOptions.autoExpandAll,\n            allowCollapsing: groupingOptions.allowCollapsing,\n            allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled\n          }, commonColumnSettings);\n        },\n        isColumnOptionUsed: function isColumnOptionUsed(optionName) {\n          for (var i = 0; i < this._columns.length; i++) {\n            if (this._columns[i][optionName]) {\n              return true;\n            }\n          }\n        },\n        isAllDataTypesDefined: function isAllDataTypesDefined(checkSerializers) {\n          var i,\n            columns = this._columns;\n          if (!columns.length) {\n            return false;\n          }\n          for (i = 0; i < columns.length; i++) {\n            if (!columns[i].dataField && columns[i].calculateCellValue === columns[i].defaultCalculateCellValue) {\n              continue;\n            }\n            if (!columns[i].dataType || checkSerializers && columns[i].deserializeValue && void 0 === columns[i].serializationFormat) {\n              return false;\n            }\n          }\n          return true;\n        },\n        getColumns: function getColumns() {\n          return this._columns;\n        },\n        isBandColumnsUsed: function isBandColumnsUsed() {\n          return this.getColumns().some(function (column) {\n            return column.isBand;\n          });\n        },\n        getGroupColumns: function getGroupColumns() {\n          var result = [];\n          _iterator2.default.each(this._columns, function () {\n            var column = this;\n            if ((0, _type.isDefined)(column.groupIndex)) {\n              result[column.groupIndex] = column;\n            }\n          });\n          return result;\n        },\n        getVisibleColumns: function getVisibleColumns(rowIndex) {\n          this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();\n          rowIndex = (0, _type.isDefined)(rowIndex) ? rowIndex : this._visibleColumns.length - 1;\n          return this._visibleColumns[rowIndex] || [];\n        },\n        getFixedColumns: function getFixedColumns(rowIndex) {\n          this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();\n          rowIndex = (0, _type.isDefined)(rowIndex) ? rowIndex : this._fixedColumns.length - 1;\n          return this._fixedColumns[rowIndex] || [];\n        },\n        getFilteringColumns: function getFilteringColumns() {\n          return this.getColumns().filter(function (item) {\n            return (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering);\n          }).map(function (item) {\n            var field = (0, _extend.extend)(true, {}, item);\n            if (!(0, _type.isDefined)(field.dataField)) {\n              field.dataField = field.name;\n            }\n            field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;\n            return field;\n          });\n        },\n        _getFixedColumnsCore: function _getFixedColumnsCore() {\n          var i,\n            j,\n            column,\n            prevColumn,\n            notFixedColumnCount,\n            transparentColumnIndex,\n            lastFixedPosition,\n            visibleColumns,\n            that = this,\n            result = [],\n            rowCount = that.getRowCount(),\n            isColumnFixing = that._isColumnFixing(),\n            transparentColumn = {\n              command: \"transparent\"\n            },\n            transparentColspan = 0;\n          if (isColumnFixing) {\n            for (i = 0; i <= rowCount; i++) {\n              notFixedColumnCount = 0;\n              lastFixedPosition = null;\n              transparentColumnIndex = null;\n              visibleColumns = that.getVisibleColumns(i, true);\n              for (j = 0; j < visibleColumns.length; j++) {\n                prevColumn = visibleColumns[j - 1];\n                column = visibleColumns[j];\n                if (!column.fixed) {\n                  if (0 === i) {\n                    if (column.isBand && column.colspan) {\n                      transparentColspan += column.colspan;\n                    } else {\n                      transparentColspan++;\n                    }\n                  }\n                  notFixedColumnCount++;\n                  if (!(0, _type.isDefined)(transparentColumnIndex)) {\n                    transparentColumnIndex = j;\n                  }\n                } else {\n                  if (prevColumn && prevColumn.fixed && getFixedPosition(that, prevColumn) !== getFixedPosition(that, column)) {\n                    if (!(0, _type.isDefined)(transparentColumnIndex)) {\n                      transparentColumnIndex = j;\n                    }\n                  } else {\n                    lastFixedPosition = column.fixedPosition;\n                  }\n                }\n              }\n              if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {\n                return [];\n              }\n              if (!(0, _type.isDefined)(transparentColumnIndex)) {\n                transparentColumnIndex = \"right\" === lastFixedPosition ? 0 : visibleColumns.length;\n              }\n              result[i] = visibleColumns.slice(0);\n              if (!transparentColumn.colspan) {\n                transparentColumn.colspan = transparentColspan;\n              }\n              result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn);\n            }\n          }\n          return result;\n        },\n        _isColumnFixing: function _isColumnFixing() {\n          var isColumnFixing = this.option(\"columnFixing.enabled\");\n          !isColumnFixing && _iterator2.default.each(this._columns, function (_, column) {\n            if (column.fixed) {\n              isColumnFixing = true;\n              return false;\n            }\n          });\n          return isColumnFixing;\n        },\n        _getExpandColumnsCore: function _getExpandColumnsCore() {\n          return this.getGroupColumns();\n        },\n        getExpandColumns: function getExpandColumns() {\n          var expandColumn,\n            expandColumns = this._getExpandColumnsCore(),\n            firstGroupColumn = expandColumns.filter(function (column) {\n              return 0 === column.groupIndex;\n            })[0],\n            isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed,\n            isColumnFixing = this._isColumnFixing();\n          if (expandColumns.length) {\n            expandColumn = this.columnOption(\"command:expand\");\n          }\n          expandColumns = _iterator2.default.map(expandColumns, function (column) {\n            return (0, _extend.extend)({}, column, {\n              visibleWidth: null,\n              minWidth: null,\n              cellTemplate: !(0, _type.isDefined)(column.groupIndex) ? column.cellTemplate : null,\n              headerCellTemplate: null,\n              fixed: !(0, _type.isDefined)(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true\n            }, expandColumn, {\n              index: column.index,\n              type: column.type || GROUP_COMMAND_COLUMN_NAME\n            });\n          });\n          return expandColumns;\n        },\n        getBandColumnsCache: function getBandColumnsCache() {\n          if (!this._bandColumnsCache) {\n            var columns = this._columns,\n              columnChildrenByIndex = {},\n              columnParentByIndex = {};\n            columns.forEach(function (column) {\n              var parentIndex = column.ownerBand,\n                parent = columns[parentIndex];\n              if (column.colspan) {\n                column.colspan = void 0;\n              }\n              if (column.rowspan) {\n                column.rowspan = void 0;\n              }\n              if (parent) {\n                columnParentByIndex[column.index] = parent;\n              } else {\n                parentIndex = -1;\n              }\n              columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];\n              columnChildrenByIndex[parentIndex].push(column);\n            });\n            this._bandColumnsCache = {\n              columnChildrenByIndex: columnChildrenByIndex,\n              columnParentByIndex: columnParentByIndex\n            };\n          }\n          return this._bandColumnsCache;\n        },\n        _isColumnVisible: function _isColumnVisible(column) {\n          return column.visible && this.isParentColumnVisible(column.index);\n        },\n        _getVisibleColumnsCore: function _getVisibleColumnsCore() {\n          var i,\n            firstPositiveIndexColumn,\n            isFixedToEnd,\n            that = this,\n            result = [],\n            rowspanGroupColumns = 0,\n            rowspanExpandColumns = 0,\n            rowCount = that.getRowCount(),\n            positiveIndexedColumns = [],\n            negativeIndexedColumns = [],\n            notGroupedColumnsCount = 0,\n            rtlEnabled = that.option(\"rtlEnabled\"),\n            bandColumnsCache = that.getBandColumnsCache(),\n            expandColumns = mergeColumns(that, that.getExpandColumns(), that._columns),\n            columns = mergeColumns(that, that._columns, that._commandColumns, true),\n            columnDigitsCount = digitsCount(columns.length);\n          processBandColumns(that, columns, bandColumnsCache);\n          for (i = 0; i < rowCount; i++) {\n            result[i] = [];\n            negativeIndexedColumns[i] = [{}];\n            positiveIndexedColumns[i] = [{}, {}, {}];\n          }\n          _iterator2.default.each(columns, function () {\n            var rowIndex,\n              indexedColumns,\n              column = this,\n              visibleIndex = column.visibleIndex,\n              parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex),\n              visible = that._isColumnVisible(column);\n            if (visible && (!(0, _type.isDefined)(column.groupIndex) || column.showWhenGrouped)) {\n              rowIndex = parentBandColumns.length;\n              if (visibleIndex < 0) {\n                visibleIndex = -visibleIndex;\n                indexedColumns = negativeIndexedColumns[rowIndex];\n              } else {\n                column.fixed = parentBandColumns.length ? parentBandColumns[0].fixed : column.fixed;\n                column.fixedPosition = parentBandColumns.length ? parentBandColumns[0].fixedPosition : column.fixedPosition;\n                if (column.fixed) {\n                  isFixedToEnd = \"right\" === column.fixedPosition;\n                  if (rtlEnabled && (!column.command || isCustomCommandColumn(that, column))) {\n                    isFixedToEnd = !isFixedToEnd;\n                  }\n                  if (isFixedToEnd) {\n                    indexedColumns = positiveIndexedColumns[rowIndex][2];\n                  } else {\n                    indexedColumns = positiveIndexedColumns[rowIndex][0];\n                  }\n                } else {\n                  indexedColumns = positiveIndexedColumns[rowIndex][1];\n                }\n              }\n              if (parentBandColumns.length) {\n                visibleIndex = numberToString(visibleIndex, columnDigitsCount);\n                for (i = parentBandColumns.length - 1; i >= 0; i--) {\n                  visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex;\n                }\n              }\n              indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];\n              indexedColumns[visibleIndex].push(column);\n              notGroupedColumnsCount++;\n            }\n          });\n          _iterator2.default.each(result, function (rowIndex) {\n            (0, _object.orderEach)(negativeIndexedColumns[rowIndex], function (_, columns) {\n              result[rowIndex].unshift.apply(result[rowIndex], columns);\n            });\n            firstPositiveIndexColumn = result[rowIndex].length;\n            _iterator2.default.each(positiveIndexedColumns[rowIndex], function (index, columnsByFixing) {\n              (0, _object.orderEach)(columnsByFixing, function (_, columnsByVisibleIndex) {\n                result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex);\n              });\n            });\n            if (rowspanExpandColumns < rowIndex + 1) {\n              rowspanExpandColumns += processExpandColumns.call(that, result[rowIndex], expandColumns, \"detailExpand\", firstPositiveIndexColumn);\n            }\n            if (rowspanGroupColumns < rowIndex + 1) {\n              rowspanGroupColumns += processExpandColumns.call(that, result[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);\n            }\n          });\n          result.push(getDataColumns(result));\n          if (!notGroupedColumnsCount && that._columns.length) {\n            result[rowCount].push({\n              command: \"empty\"\n            });\n          }\n          return result;\n        },\n        getInvisibleColumns: function getInvisibleColumns(columns, bandColumnIndex) {\n          var hiddenColumnsByBand,\n            that = this,\n            result = [];\n          columns = columns || that._columns;\n          _iterator2.default.each(columns, function (_, column) {\n            if (column.ownerBand !== bandColumnIndex) {\n              return;\n            }\n            if (column.isBand) {\n              if (!column.visible) {\n                hiddenColumnsByBand = that.getChildrenByBandColumn(column.index);\n              } else {\n                hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index);\n              }\n              if (hiddenColumnsByBand.length) {\n                result.push(column);\n                result = result.concat(hiddenColumnsByBand);\n              }\n              return;\n            }\n            if (!column.visible) {\n              result.push(column);\n            }\n          });\n          return result;\n        },\n        getChooserColumns: function getChooserColumns(getAllColumns) {\n          var columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();\n          return (0, _common.grep)(columns, function (column) {\n            return column.showInColumnChooser;\n          });\n        },\n        allowMoveColumn: function allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\n          var that = this,\n            columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),\n            sourceColumn = that._columns[columnIndex];\n          if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {\n            if (sourceLocation === targetLocation) {\n              if (sourceLocation === COLUMN_CHOOSER_LOCATION) {\n                return false;\n              }\n              fromVisibleIndex = (0, _type.isObject)(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;\n              toVisibleIndex = (0, _type.isObject)(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\n              return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex;\n            } else {\n              if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {\n                return sourceColumn && sourceColumn.allowGrouping;\n              } else {\n                if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {\n                  return sourceColumn && sourceColumn.allowHiding;\n                }\n              }\n            }\n            return true;\n          }\n          return false;\n        },\n        moveColumn: function moveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\n          var prevGroupIndex,\n            targetGroupIndex,\n            column,\n            that = this,\n            options = {},\n            fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation),\n            toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);\n          if (fromIndex >= 0) {\n            column = that._columns[fromIndex];\n            toVisibleIndex = (0, _type.isObject)(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\n            targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;\n            if ((0, _type.isDefined)(column.groupIndex) && sourceLocation === GROUP_LOCATION) {\n              if (targetGroupIndex > column.groupIndex) {\n                targetGroupIndex--;\n              }\n              if (targetLocation !== GROUP_LOCATION) {\n                options.groupIndex = void 0;\n              } else {\n                prevGroupIndex = column.groupIndex;\n                delete column.groupIndex;\n                updateColumnGroupIndexes(that);\n              }\n            }\n            if (targetLocation === GROUP_LOCATION) {\n              options.groupIndex = moveColumnToGroup(that, column, targetGroupIndex);\n              column.groupIndex = prevGroupIndex;\n            } else {\n              if (toVisibleIndex >= 0) {\n                var targetColumn = that._columns[toIndex];\n                if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {\n                  options.visibleIndex = MAX_SAFE_INTEGER;\n                } else {\n                  if (isColumnFixed(that, column) ^ isColumnFixed(that, targetColumn)) {\n                    options.visibleIndex = MAX_SAFE_INTEGER;\n                  } else {\n                    options.visibleIndex = targetColumn.visibleIndex;\n                  }\n                }\n              }\n            }\n            var isVisible = targetLocation !== COLUMN_CHOOSER_LOCATION;\n            if (column.visible !== isVisible) {\n              options.visible = isVisible;\n            }\n            that.columnOption(column.index, options);\n          }\n        },\n        changeSortOrder: function changeSortOrder(columnIndex, sortOrder) {\n          var that = this,\n            options = {},\n            sortingOptions = that.option(\"sorting\"),\n            sortingMode = sortingOptions && sortingOptions.mode,\n            needResetSorting = \"single\" === sortingMode || !sortOrder,\n            allowSorting = \"single\" === sortingMode || \"multiple\" === sortingMode,\n            column = that._columns[columnIndex],\n            nextSortOrder = function nextSortOrder(column) {\n              if (\"ctrl\" === sortOrder) {\n                if (!(\"sortOrder\" in column && \"sortIndex\" in column)) {\n                  return false;\n                }\n                options.sortOrder = void 0;\n                options.sortIndex = void 0;\n              } else {\n                if ((0, _type.isDefined)(column.groupIndex) || (0, _type.isDefined)(column.sortIndex)) {\n                  options.sortOrder = \"desc\" === column.sortOrder ? \"asc\" : \"desc\";\n                } else {\n                  options.sortOrder = \"asc\";\n                }\n              }\n              return true;\n            };\n          if (allowSorting && column && column.allowSorting) {\n            if (needResetSorting && !(0, _type.isDefined)(column.groupIndex)) {\n              _iterator2.default.each(that._columns, function (index) {\n                if (index !== columnIndex && this.sortOrder && !(0, _type.isDefined)(this.groupIndex)) {\n                  delete this.sortOrder;\n                  delete this.sortIndex;\n                }\n              });\n            }\n            if (isSortOrderValid(sortOrder)) {\n              if (column.sortOrder !== sortOrder) {\n                options.sortOrder = sortOrder;\n              }\n            } else {\n              if (\"none\" === sortOrder) {\n                if (column.sortOrder) {\n                  options.sortIndex = void 0;\n                  options.sortOrder = void 0;\n                }\n              } else {\n                nextSortOrder(column);\n              }\n            }\n          }\n          that.columnOption(column.index, options);\n        },\n        getSortDataSourceParameters: function getSortDataSourceParameters(useLocalSelector) {\n          var that = this,\n            sortColumns = [],\n            sort = [];\n          _iterator2.default.each(that._columns, function () {\n            if ((this.dataField || this.selector || this.calculateCellValue) && (0, _type.isDefined)(this.sortIndex) && !(0, _type.isDefined)(this.groupIndex)) {\n              sortColumns[this.sortIndex] = this;\n            }\n          });\n          _iterator2.default.each(sortColumns, function () {\n            var sortOrder = this && this.sortOrder;\n            if (isSortOrderValid(sortOrder)) {\n              var sortItem = {\n                selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,\n                desc: \"desc\" === this.sortOrder\n              };\n              if (this.sortingMethod) {\n                sortItem.compare = this.sortingMethod.bind(this);\n              }\n              sort.push(sortItem);\n            }\n          });\n          return sort.length > 0 ? sort : null;\n        },\n        getGroupDataSourceParameters: function getGroupDataSourceParameters(useLocalSelector) {\n          var group = [];\n          _iterator2.default.each(this.getGroupColumns(), function () {\n            var selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;\n            if (selector) {\n              var groupItem = {\n                selector: selector,\n                desc: \"desc\" === this.sortOrder,\n                isExpanded: !!this.autoExpandGroup\n              };\n              if (this.sortingMethod) {\n                groupItem.compare = this.sortingMethod.bind(this);\n              }\n              group.push(groupItem);\n            }\n          });\n          return group.length > 0 ? group : null;\n        },\n        refresh: function refresh(updateNewLookupsOnly) {\n          var deferreds = [];\n          _iterator2.default.each(this._columns, function () {\n            var lookup = this.lookup;\n            if (lookup && !this.calculateDisplayValue) {\n              if (updateNewLookupsOnly && lookup.valueMap) {\n                return;\n              }\n              if (lookup.update) {\n                deferreds.push(lookup.update());\n              }\n            }\n          });\n          return _deferred.when.apply(_renderer2.default, deferreds).done(resetColumnsCache.bind(null, this));\n        },\n        _updateColumnOptions: function _updateColumnOptions(column) {\n          column.selector = column.selector || function (data) {\n            return column.calculateCellValue(data);\n          };\n          _iterator2.default.each([\"calculateSortValue\", \"calculateGroupValue\", \"calculateDisplayValue\"], function (_, calculateCallbackName) {\n            var calculateCallback = column[calculateCallbackName];\n            if ((0, _type.isFunction)(calculateCallback) && !calculateCallback.originalCallback) {\n              column[calculateCallbackName] = function (data) {\n                return calculateCallback.call(column, data);\n              };\n              column[calculateCallbackName].originalCallback = calculateCallback;\n            }\n          });\n          if ((0, _type.isString)(column.calculateDisplayValue)) {\n            column.displayField = column.calculateDisplayValue;\n            column.calculateDisplayValue = _data2.default.compileGetter(column.displayField);\n          }\n          if (column.calculateDisplayValue) {\n            column.displayValueMap = column.displayValueMap || {};\n          }\n          updateSerializers(column, column.dataType);\n          var lookup = column.lookup;\n          if (lookup) {\n            updateSerializers(lookup, lookup.dataType);\n          }\n          var dataType = lookup ? lookup.dataType : column.dataType;\n          if (dataType) {\n            column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option(\"rtlEnabled\"));\n            column.format = column.format || (0, _uiGrid_core3.getFormatByDataType)(dataType);\n            column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);\n            column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];\n            if (!(0, _type.isDefined)(column.filterOperations)) {\n              setFilterOperationsAsDefaultValues(column);\n            }\n            column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || \"=\";\n            column.showEditorAlways = (0, _type.isDefined)(column.showEditorAlways) ? column.showEditorAlways : \"boolean\" === dataType && !column.cellTemplate;\n          }\n        },\n        updateColumnDataTypes: function updateColumnDataTypes(dataSource) {\n          var that = this,\n            dateSerializationFormat = that.option(\"dateSerializationFormat\"),\n            firstItems = that._getFirstItems(dataSource),\n            isColumnDataTypesUpdated = false;\n          _iterator2.default.each(that._columns, function (index, column) {\n            var i,\n              value,\n              dataType,\n              lookupDataType,\n              valueDataType,\n              lookup = column.lookup;\n            if ((0, _uiGrid_core3.isDateType)(column.dataType) && void 0 === column.serializationFormat) {\n              column.serializationFormat = dateSerializationFormat;\n            }\n            if (lookup && (0, _uiGrid_core3.isDateType)(lookup.dataType) && void 0 === column.serializationFormat) {\n              lookup.serializationFormat = dateSerializationFormat;\n            }\n            if (column.calculateCellValue && firstItems.length) {\n              if (!column.dataType || lookup && !lookup.dataType) {\n                for (i = 0; i < firstItems.length; i++) {\n                  value = column.calculateCellValue(firstItems[i]);\n                  if (!column.dataType) {\n                    valueDataType = getValueDataType(value);\n                    dataType = dataType || valueDataType;\n                    if (dataType && valueDataType && dataType !== valueDataType) {\n                      dataType = \"string\";\n                    }\n                  }\n                  if (lookup && !lookup.dataType) {\n                    valueDataType = getValueDataType((0, _uiGrid_core3.getDisplayValue)(column, value, firstItems[i]));\n                    lookupDataType = lookupDataType || valueDataType;\n                    if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {\n                      lookupDataType = \"string\";\n                    }\n                  }\n                }\n                if (dataType || lookupDataType) {\n                  if (dataType) {\n                    column.dataType = dataType;\n                  }\n                  if (lookup && lookupDataType) {\n                    lookup.dataType = lookupDataType;\n                  }\n                  isColumnDataTypesUpdated = true;\n                }\n              }\n              if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {\n                for (i = 0; i < firstItems.length; i++) {\n                  value = column.calculateCellValue(firstItems[i], true);\n                  if (void 0 === column.serializationFormat) {\n                    column.serializationFormat = getSerializationFormat(column.dataType, value);\n                  }\n                  if (lookup && void 0 === lookup.serializationFormat) {\n                    lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true));\n                  }\n                }\n              }\n            }\n            that._updateColumnOptions(column);\n          });\n          return isColumnDataTypesUpdated;\n        },\n        _customizeColumns: function _customizeColumns(columns) {\n          var hasOwnerBand,\n            that = this,\n            customizeColumns = that.option(\"customizeColumns\");\n          if (customizeColumns) {\n            hasOwnerBand = columns.some(function (column) {\n              return (0, _type.isObject)(column.ownerBand);\n            });\n            if (hasOwnerBand) {\n              updateIndexes(that);\n            }\n            customizeColumns(columns);\n            assignColumns(that, createColumnsFromOptions(that, columns));\n          }\n        },\n        updateColumns: function updateColumns(dataSource, forceApplying) {\n          var sortParameters,\n            groupParameters,\n            that = this;\n          if (!forceApplying) {\n            that.updateSortingGrouping(dataSource);\n          }\n          if (!dataSource || dataSource.isLoaded()) {\n            sortParameters = dataSource ? dataSource.sort() || [] : that.getSortDataSourceParameters();\n            groupParameters = dataSource ? dataSource.group() || [] : that.getGroupDataSourceParameters();\n            that._customizeColumns(that._columns);\n            updateIndexes(that);\n            var columns = that._columns;\n            return (0, _deferred.when)(that.refresh(true)).always(function () {\n              if (that._columns !== columns) {\n                return;\n              }\n              that._updateChanges(dataSource, {\n                sorting: sortParameters,\n                grouping: groupParameters\n              });\n              fireColumnsChanged(that);\n            });\n          }\n        },\n        _updateChanges: function _updateChanges(dataSource, parameters) {\n          var that = this;\n          if (dataSource) {\n            that.updateColumnDataTypes(dataSource);\n            that._dataSourceApplied = true;\n          }\n          if (!(0, _uiGrid_core3.equalSortParameters)(parameters.sorting, that.getSortDataSourceParameters())) {\n            updateColumnChanges(that, \"sorting\");\n          }\n          if (!(0, _uiGrid_core3.equalSortParameters)(parameters.grouping, that.getGroupDataSourceParameters())) {\n            updateColumnChanges(that, \"grouping\");\n          }\n          updateColumnChanges(that, \"columns\");\n        },\n        updateSortingGrouping: function updateSortingGrouping(dataSource, fromDataSource) {\n          var sortParameters,\n            groupParameters,\n            columnsGroupParameters,\n            columnsSortParameters,\n            isColumnsChanged,\n            that = this,\n            updateSortGroupParameterIndexes = function updateSortGroupParameterIndexes(columns, sortParameters, indexParameterName) {\n              var i, selector, isExpanded;\n              _iterator2.default.each(columns, function (index, column) {\n                delete column[indexParameterName];\n                if (sortParameters) {\n                  for (i = 0; i < sortParameters.length; i++) {\n                    selector = sortParameters[i].selector;\n                    isExpanded = sortParameters[i].isExpanded;\n                    if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue) {\n                      column.sortOrder = column.sortOrder || (sortParameters[i].desc ? \"desc\" : \"asc\");\n                      if (void 0 !== isExpanded) {\n                        column.autoExpandGroup = isExpanded;\n                      }\n                      column[indexParameterName] = i;\n                      break;\n                    }\n                  }\n                }\n              });\n            };\n          if (dataSource) {\n            sortParameters = (0, _uiGrid_core3.normalizeSortingInfo)(dataSource.sort());\n            groupParameters = (0, _uiGrid_core3.normalizeSortingInfo)(dataSource.group());\n            columnsGroupParameters = that.getGroupDataSourceParameters();\n            columnsSortParameters = that.getSortDataSourceParameters();\n            if (!that._columns.length) {\n              _iterator2.default.each(groupParameters, function (index, group) {\n                that._columns.push(group.selector);\n              });\n              _iterator2.default.each(sortParameters, function (index, sort) {\n                that._columns.push(sort.selector);\n              });\n              assignColumns(that, createColumnsFromOptions(that, that._columns));\n            }\n            if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && !(0, _uiGrid_core3.equalSortParameters)(groupParameters, columnsGroupParameters)) {\n              updateSortGroupParameterIndexes(that._columns, groupParameters, \"groupIndex\");\n              if (fromDataSource) {\n                updateColumnChanges(that, \"grouping\");\n                isColumnsChanged = true;\n              }\n            }\n            if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !(0, _uiGrid_core3.equalSortParameters)(sortParameters, columnsSortParameters)) {\n              updateSortGroupParameterIndexes(that._columns, sortParameters, \"sortIndex\");\n              if (fromDataSource) {\n                updateColumnChanges(that, \"sorting\");\n                isColumnsChanged = true;\n              }\n            }\n            if (isColumnsChanged) {\n              fireColumnsChanged(that);\n            }\n          }\n        },\n        updateFilter: function updateFilter(filter, remoteFiltering, columnIndex, filterValue) {\n          var that = this;\n          if (!Array.isArray(filter)) {\n            return filter;\n          }\n          var column, i;\n          filter = (0, _extend.extend)([], filter);\n          columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;\n          filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;\n          if ((0, _type.isString)(filter[0])) {\n            column = that.columnOption(filter[0]);\n            if (remoteFiltering) {\n              if ((0, _config2.default)().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {\n                filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], \"filter\");\n              }\n            } else {\n              if (column && column.selector) {\n                filter[0] = column.selector;\n                filter[0].columnIndex = column.index;\n              }\n            }\n          } else {\n            if ((0, _type.isFunction)(filter[0])) {\n              filter[0].columnIndex = columnIndex;\n              filter[0].filterValue = filterValue;\n            }\n          }\n          for (i = 0; i < filter.length; i++) {\n            filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue);\n          }\n          return filter;\n        },\n        columnCount: function columnCount() {\n          return this._columns ? this._columns.length : 0;\n        },\n        columnOption: function columnOption(identifier, option, value, notFireEvent) {\n          var i,\n            needUpdateIndexes,\n            column,\n            that = this,\n            identifierOptionName = (0, _type.isString)(identifier) && identifier.substr(0, identifier.indexOf(\":\")),\n            columns = that._columns.concat(that._commandColumns);\n          if (void 0 === identifier) {\n            return;\n          }\n          if (identifierOptionName) {\n            identifier = identifier.substr(identifierOptionName.length + 1);\n          }\n          for (i = 0; i < columns.length; i++) {\n            if (identifierOptionName) {\n              if (\"\" + columns[i][identifierOptionName] === identifier) {\n                column = columns[i];\n                break;\n              }\n            } else {\n              if (columns[i].index === identifier || columns[i].name === identifier || columns[i].dataField === identifier || columns[i].caption === identifier) {\n                column = columns[i];\n                break;\n              }\n            }\n          }\n          if (column) {\n            if (1 === arguments.length) {\n              return (0, _extend.extend)({}, column);\n            }\n            if ((0, _type.isString)(option)) {\n              if (2 === arguments.length) {\n                return columnOptionCore(that, column, option);\n              } else {\n                needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[option];\n                columnOptionCore(that, column, option, value, notFireEvent);\n              }\n            } else {\n              if ((0, _type.isObject)(option)) {\n                _iterator2.default.each(option, function (optionName, value) {\n                  needUpdateIndexes = needUpdateIndexes || COLUMN_INDEX_OPTIONS[optionName];\n                  columnOptionCore(that, column, optionName, value, notFireEvent);\n                });\n              }\n            }\n            if (needUpdateIndexes) {\n              updateIndexes(that, column);\n            }\n            fireColumnsChanged(that);\n          }\n        },\n        clearSorting: function clearSorting() {\n          var i,\n            that = this,\n            columnCount = this.columnCount();\n          that.beginUpdate();\n          for (i = 0; i < columnCount; i++) {\n            that.columnOption(i, \"sortOrder\", void 0);\n          }\n          that.endUpdate();\n        },\n        clearGrouping: function clearGrouping() {\n          var i,\n            that = this,\n            columnCount = this.columnCount();\n          that.beginUpdate();\n          for (i = 0; i < columnCount; i++) {\n            that.columnOption(i, \"groupIndex\", void 0);\n          }\n          that.endUpdate();\n        },\n        getVisibleIndex: function getVisibleIndex(index, rowIndex) {\n          var i,\n            columns = this.getVisibleColumns(rowIndex);\n          for (i = columns.length - 1; i >= 0; i--) {\n            if (columns[i].index === index) {\n              return i;\n            }\n          }\n          return -1;\n        },\n        addColumn: function addColumn(options) {\n          var that = this,\n            column = createColumn(that, options),\n            index = that._columns.length;\n          that._columns.push(column);\n          if (column.isBand) {\n            that._columns = createColumnsFromOptions(that, that._columns);\n            column = that._columns[index];\n          }\n          column.added = options;\n          updateIndexes(that, column);\n          that.updateColumns(that._dataSource);\n        },\n        deleteColumn: function deleteColumn(id) {\n          var childIndexes,\n            that = this,\n            column = that.columnOption(id);\n          if (column && column.index >= 0) {\n            that._columns.splice(column.index, 1);\n            if (column.isBand) {\n              childIndexes = that.getChildrenByBandColumn(column.index).map(function (column) {\n                return column.index;\n              });\n              that._columns = that._columns.filter(function (column) {\n                return childIndexes.indexOf(column.index) < 0;\n              });\n            }\n            updateIndexes(that);\n            that.updateColumns(that._dataSource);\n          }\n        },\n        addCommandColumn: function addCommandColumn(options) {\n          var commandColumn = this._commandColumns.filter(function (column) {\n            return column.command === options.command;\n          })[0];\n          if (!commandColumn) {\n            commandColumn = options;\n            this._commandColumns.push(commandColumn);\n          }\n        },\n        getUserState: function getUserState() {\n          var i,\n            columns = this._columns,\n            result = [];\n          function handleStateField(index, value) {\n            if (void 0 !== columns[i][value]) {\n              result[i][value] = columns[i][value];\n            }\n          }\n          for (i = 0; i < columns.length; i++) {\n            result[i] = {};\n            _iterator2.default.each(USER_STATE_FIELD_NAMES, handleStateField);\n          }\n          return result;\n        },\n        setUserState: function setUserState(state) {\n          var commonColumnSettings,\n            that = this,\n            dataSource = that._dataSource,\n            ignoreColumnOptionNames = that.option(\"stateStoring.ignoreColumnOptionNames\");\n          if (!ignoreColumnOptionNames) {\n            ignoreColumnOptionNames = [];\n            commonColumnSettings = that.getCommonSettings();\n            if (!that.option(\"columnChooser.enabled\")) {\n              ignoreColumnOptionNames.push(\"visible\");\n            }\n            if (\"none\" === that.option(\"sorting.mode\")) {\n              ignoreColumnOptionNames.push(\"sortIndex\", \"sortOrder\");\n            }\n            if (!commonColumnSettings.allowGrouping) {\n              ignoreColumnOptionNames.push(\"groupIndex\");\n            }\n            if (!commonColumnSettings.allowFixing) {\n              ignoreColumnOptionNames.push(\"fixed\", \"fixedPosition\");\n            }\n            if (!commonColumnSettings.allowResizing) {\n              ignoreColumnOptionNames.push(\"width\", \"visibleWidth\");\n            }\n            if (!that.option(\"filterRow.visible\")) {\n              ignoreColumnOptionNames.push(\"filterValue\", \"selectedFilterOperation\");\n            }\n            if (!that.option(\"headerFilter.visible\")) {\n              ignoreColumnOptionNames.push(\"filterValues\", \"filterType\");\n            }\n          }\n          that._columnsUserState = state;\n          that._ignoreColumnOptionNames = ignoreColumnOptionNames;\n          that._hasUserState = !!state;\n          updateColumnChanges(that, \"filtering\");\n          that.init();\n          if (dataSource) {\n            dataSource.sort(null);\n            dataSource.group(null);\n          }\n        },\n        _createCalculatedColumnOptions: function _createCalculatedColumnOptions(columnOptions, bandColumn) {\n          var getter,\n            calculatedColumnOptions = {},\n            dataField = columnOptions.dataField;\n          if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {\n            calculatedColumnOptions.isBand = true;\n            dataField = null;\n          }\n          if (dataField) {\n            if ((0, _type.isString)(dataField)) {\n              getter = _data2.default.compileGetter(dataField);\n              calculatedColumnOptions = {\n                caption: _inflector2.default.captionize(dataField),\n                calculateCellValue: function calculateCellValue(data, skipDeserialization) {\n                  var value = getter(data);\n                  return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;\n                },\n                setCellValue: defaultSetCellValue,\n                parseValue: function parseValue(text) {\n                  var result,\n                    parsedValue,\n                    column = this;\n                  if (\"number\" === column.dataType) {\n                    if ((0, _type.isString)(text) && column.format) {\n                      parsedValue = _number2.default.parse(text);\n                      if ((0, _type.isNumeric)(parsedValue)) {\n                        result = parsedValue;\n                      }\n                    } else {\n                      if ((0, _type.isDefined)(text) && (0, _type.isNumeric)(text)) {\n                        result = Number(text);\n                      }\n                    }\n                  } else {\n                    if (\"boolean\" === column.dataType) {\n                      if (text === column.trueText) {\n                        result = true;\n                      } else {\n                        if (text === column.falseText) {\n                          result = false;\n                        }\n                      }\n                    } else {\n                      if ((0, _uiGrid_core3.isDateType)(column.dataType)) {\n                        parsedValue = _date2.default.parse(text, column.format);\n                        if (parsedValue) {\n                          result = parsedValue;\n                        }\n                      } else {\n                        result = text;\n                      }\n                    }\n                  }\n                  return result;\n                }\n              };\n            }\n            calculatedColumnOptions.allowFiltering = true;\n          } else {\n            calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;\n          }\n          calculatedColumnOptions.calculateFilterExpression = function () {\n            return _filtering2.default.defaultCalculateFilterExpression.apply(this, arguments);\n          };\n          calculatedColumnOptions.createFilterExpression = function (filterValue) {\n            var result;\n            if (this.calculateFilterExpression) {\n              result = this.calculateFilterExpression.apply(this, arguments);\n            }\n            if ((0, _type.isFunction)(result)) {\n              result = [result, \"=\", true];\n            }\n            if (result) {\n              result.columnIndex = this.index;\n              result.filterValue = filterValue;\n            }\n            return result;\n          };\n          if (!dataField || !(0, _type.isString)(dataField)) {\n            (0, _extend.extend)(true, calculatedColumnOptions, {\n              allowSorting: false,\n              allowGrouping: false,\n              calculateCellValue: function calculateCellValue() {\n                return null;\n              }\n            });\n          }\n          if (bandColumn) {\n            calculatedColumnOptions.allowFixing = false;\n          }\n          if (columnOptions.dataType) {\n            calculatedColumnOptions.userDataType = columnOptions.dataType;\n          }\n          if (columnOptions.selectedFilterOperation && !(\"defaultSelectedFilterOperation\" in calculatedColumnOptions)) {\n            calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation;\n          }\n          if (columnOptions.lookup) {\n            calculatedColumnOptions.lookup = {\n              calculateCellValue: function calculateCellValue(value, skipDeserialization) {\n                if (this.valueExpr) {\n                  value = this.valueMap && this.valueMap[value];\n                }\n                return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;\n              },\n              updateValueMap: function updateValueMap() {\n                var calculateValue, calculateDisplayValue, item, i;\n                this.valueMap = {};\n                if (this.items) {\n                  calculateValue = _data2.default.compileGetter(this.valueExpr);\n                  calculateDisplayValue = _data2.default.compileGetter(this.displayExpr);\n                  for (i = 0; i < this.items.length; i++) {\n                    item = this.items[i];\n                    var displayValue = calculateDisplayValue(item);\n                    this.valueMap[calculateValue(item)] = displayValue;\n                    this.dataType = this.dataType || getValueDataType(displayValue);\n                  }\n                }\n              },\n              update: function update() {\n                var dataSourceOptions,\n                  that = this,\n                  dataSource = that.dataSource;\n                if (dataSource) {\n                  if ((0, _type.isFunction)(dataSource) && !(0, _variable_wrapper.isWrapped)(dataSource)) {\n                    dataSource = dataSource({});\n                  }\n                  if ((0, _type.isPlainObject)(dataSource) || dataSource instanceof _abstract_store2.default || Array.isArray(dataSource)) {\n                    if (that.valueExpr) {\n                      dataSourceOptions = (0, _data_source.normalizeDataSourceOptions)(dataSource);\n                      dataSourceOptions.paginate = false;\n                      dataSource = new _data_source.DataSource(dataSourceOptions);\n                      return dataSource.load().done(function (data) {\n                        that.items = data;\n                        that.updateValueMap && that.updateValueMap();\n                      });\n                    }\n                  } else {\n                    _ui2.default.log(\"E1016\");\n                  }\n                } else {\n                  that.updateValueMap && that.updateValueMap();\n                }\n              }\n            };\n          }\n          calculatedColumnOptions.resizedCallbacks = (0, _callbacks2.default)();\n          if (columnOptions.resized) {\n            calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions));\n          }\n          _iterator2.default.each(calculatedColumnOptions, function (optionName) {\n            var defaultOptionName;\n            if ((0, _type.isFunction)(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf(\"default\")) {\n              defaultOptionName = \"default\" + optionName.charAt(0).toUpperCase() + optionName.substr(1);\n              calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName];\n            }\n          });\n          return calculatedColumnOptions;\n        },\n        getRowCount: function getRowCount() {\n          this._rowCount = this._rowCount || _getRowCount(this);\n          return this._rowCount;\n        },\n        getRowIndex: function getRowIndex(columnIndex, alwaysGetRowIndex) {\n          var column = this._columns[columnIndex],\n            bandColumnsCache = this.getBandColumnsCache();\n          return column && (alwaysGetRowIndex || column.visible && !(column.command || (0, _type.isDefined)(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0;\n        },\n        getChildrenByBandColumn: function getChildrenByBandColumn(bandColumnIndex, onlyVisibleDirectChildren) {\n          var that = this,\n            bandColumnsCache = that.getBandColumnsCache(),\n            result = _getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);\n          if (onlyVisibleDirectChildren) {\n            return result.filter(function (column) {\n              return column.visible && !column.command;\n            }).sort(function (column1, column2) {\n              return column1.visibleIndex - column2.visibleIndex;\n            });\n          }\n          return result;\n        },\n        isParentBandColumn: function isParentBandColumn(columnIndex, bandColumnIndex) {\n          var result = false,\n            column = this._columns[columnIndex],\n            bandColumnsCache = this.getBandColumnsCache(),\n            parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\n          if (parentBandColumns) {\n            _iterator2.default.each(parentBandColumns, function (_, bandColumn) {\n              if (bandColumn.index === bandColumnIndex) {\n                result = true;\n                return false;\n              }\n            });\n          }\n          return result;\n        },\n        isParentColumnVisible: function isParentColumnVisible(columnIndex) {\n          var result = true,\n            bandColumnsCache = this.getBandColumnsCache(),\n            bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\n          bandColumns && _iterator2.default.each(bandColumns, function (_, bandColumn) {\n            result = result && bandColumn.visible;\n            return result;\n          });\n          return result;\n        },\n        getColumnId: function getColumnId(column) {\n          if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {\n            if (isCustomCommandColumn(this, column)) {\n              return \"type:\" + column.type;\n            }\n            return \"command:\" + column.command;\n          }\n          return column.index;\n        }\n      };\n    }())\n  }\n};","map":null,"metadata":{},"sourceType":"script"}