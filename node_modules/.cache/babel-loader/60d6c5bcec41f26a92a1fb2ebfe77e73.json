{"ast":null,"code":"/**\r\n * DevExtreme (ui/grid_core/ui.grid_core.column_fixing.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\nvar _renderer2 = _interopRequireDefault(_renderer);\nvar _events_engine = require(\"../../events/core/events_engine\");\nvar _events_engine2 = _interopRequireDefault(_events_engine);\nvar _wheel = require(\"../../events/core/wheel\");\nvar _wheel2 = _interopRequireDefault(_wheel);\nvar _message = require(\"../../localization/message\");\nvar _message2 = _interopRequireDefault(_message);\nvar _uiGrid_core = require(\"../grid_core/ui.grid_core.utils\");\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\nvar _type = require(\"../../core/utils/type\");\nvar _extend = require(\"../../core/utils/extend\");\nvar _iterator = require(\"../../core/utils/iterator\");\nvar _browser = require(\"../../core/utils/browser\");\nvar _browser2 = _interopRequireDefault(_browser);\nvar _translator = require(\"../../animation/translator\");\nvar _translator2 = _interopRequireDefault(_translator);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar CONTENT_CLASS = \"content\",\n  CONTENT_FIXED_CLASS = \"content-fixed\",\n  MASTER_DETAIL_CELL_CLASS = \"dx-master-detail-cell\",\n  FIRST_CELL_CLASS = \"dx-first-cell\",\n  LAST_CELL_CLASS = \"dx-last-cell\",\n  HOVER_STATE_CLASS = \"dx-state-hover\",\n  FIXED_COL_CLASS = \"dx-col-fixed\",\n  FIXED_COLUMNS_CLASS = \"dx-fixed-columns\",\n  POINTER_EVENTS_TARGET_CLASS = \"dx-pointer-events-target\",\n  POINTER_EVENTS_NONE_CLASS = \"dx-pointer-events-none\",\n  COMMAND_TRANSPARENT = \"transparent\",\n  GROUP_ROW_CLASS = \"dx-group-row\",\n  getTransparentColumnIndex = function getTransparentColumnIndex(fixedColumns) {\n    var transparentColumnIndex = -1;\n    (0, _iterator.each)(fixedColumns, function (index, column) {\n      if (column.command === COMMAND_TRANSPARENT) {\n        transparentColumnIndex = index;\n        return false;\n      }\n    });\n    return transparentColumnIndex;\n  },\n  normalizeColumnWidths = function normalizeColumnWidths(fixedColumns, widths, fixedWidths) {\n    var i,\n      fixedColumnIndex = 0;\n    if (fixedColumns && widths && fixedWidths) {\n      for (i = 0; i < fixedColumns.length; i++) {\n        if (fixedColumns[i].command === COMMAND_TRANSPARENT) {\n          fixedColumnIndex += fixedColumns[i].colspan;\n        } else {\n          if (widths[fixedColumnIndex] < fixedWidths[i]) {\n            widths[fixedColumnIndex] = fixedWidths[i];\n          }\n          fixedColumnIndex++;\n        }\n      }\n    }\n    return widths;\n  };\nvar baseFixedColumns = {\n  init: function init() {\n    this.callBase();\n    this._isFixedTableRendering = false;\n    this._isFixedColumns = false;\n  },\n  _createCol: function _createCol(column) {\n    return this.callBase(column).toggleClass(FIXED_COL_CLASS, !!(this._isFixedTableRendering && (column.fixed || column.command && column.command !== COMMAND_TRANSPARENT)));\n  },\n  _correctColumnIndicesForFixedColumns: function _correctColumnIndicesForFixedColumns(fixedColumns, change) {\n    var transparentColumnIndex = getTransparentColumnIndex(fixedColumns),\n      transparentColspan = fixedColumns[transparentColumnIndex].colspan,\n      columnIndices = change && change.columnIndices;\n    if (columnIndices) {\n      change.columnIndices = columnIndices.map(function (columnIndices) {\n        if (columnIndices) {\n          return columnIndices.map(function (columnIndex) {\n            if (columnIndex < transparentColumnIndex) {\n              return columnIndex;\n            } else {\n              if (columnIndex >= transparentColumnIndex + transparentColspan) {\n                return columnIndex - transparentColspan + 1;\n              }\n            }\n            return -1;\n          }).filter(function (columnIndex) {\n            return columnIndex >= 0;\n          });\n        }\n      });\n    }\n  },\n  _renderTable: function _renderTable(options) {\n    var $fixedTable,\n      $table,\n      that = this,\n      fixedColumns = that.getFixedColumns();\n    that._isFixedColumns = !!fixedColumns.length;\n    $table = that.callBase(options);\n    if (that._isFixedColumns) {\n      that._isFixedTableRendering = true;\n      var change = options && options.change,\n        columnIndices = change && change.columnIndices;\n      that._correctColumnIndicesForFixedColumns(fixedColumns, change);\n      $fixedTable = that._createTable(fixedColumns);\n      that._renderRows($fixedTable, (0, _extend.extend)({}, options, {\n        columns: fixedColumns\n      }));\n      that._updateContent($fixedTable, change);\n      if (columnIndices) {\n        change.columnIndices = columnIndices;\n      }\n      that._isFixedTableRendering = false;\n    } else {\n      that._fixedTableElement && that._fixedTableElement.remove();\n      that._fixedTableElement = null;\n    }\n    return $table;\n  },\n  _renderRow: function _renderRow($table, options) {\n    var fixedCells,\n      fixedCorrection,\n      cells = options.row.cells;\n    this.callBase.apply(this, arguments);\n    if (this._isFixedTableRendering && cells && cells.length) {\n      fixedCorrection = 0;\n      fixedCells = options.row.cells || [];\n      cells = cells.slice();\n      options.row.cells = cells;\n      for (var i = 0; i < fixedCells.length; i++) {\n        if (fixedCells[i].column && fixedCells[i].column.command === COMMAND_TRANSPARENT) {\n          fixedCorrection = (fixedCells[i].column.colspan || 1) - 1;\n          continue;\n        }\n        cells[i + fixedCorrection] = fixedCells[i];\n      }\n    }\n  },\n  _createCell: function _createCell(options) {\n    var fixedColumns,\n      prevFixedColumn,\n      transparentColumnIndex,\n      that = this,\n      column = options.column,\n      columnCommand = column && column.command,\n      rowType = options.rowType,\n      $cell = that.callBase.apply(that, arguments);\n    if (that._isFixedTableRendering || \"filter\" === rowType) {\n      fixedColumns = that.getFixedColumns();\n      transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n      prevFixedColumn = fixedColumns[transparentColumnIndex - 1];\n    }\n    if (that._isFixedTableRendering) {\n      if (columnCommand === COMMAND_TRANSPARENT) {\n        $cell.addClass(POINTER_EVENTS_NONE_CLASS).toggleClass(FIRST_CELL_CLASS, 0 === transparentColumnIndex || prevFixedColumn && \"expand\" === prevFixedColumn.command).toggleClass(LAST_CELL_CLASS, fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1);\n        if (\"freeSpace\" !== rowType) {\n          _uiGrid_core2.default.setEmptyText($cell);\n        }\n      }\n    } else {\n      if (\"filter\" === rowType) {\n        $cell.toggleClass(FIRST_CELL_CLASS, options.columnIndex === transparentColumnIndex);\n      }\n    }\n    return $cell;\n  },\n  _wrapTableInScrollContainer: function _wrapTableInScrollContainer() {\n    var $scrollContainer = this.callBase.apply(this, arguments);\n    if (this._isFixedTableRendering) {\n      $scrollContainer.addClass(this.addWidgetPrefix(CONTENT_FIXED_CLASS) + \" \" + POINTER_EVENTS_TARGET_CLASS);\n    }\n    return $scrollContainer;\n  },\n  _renderCellContent: function _renderCellContent($cell, options) {\n    var columns,\n      isEmptyCell,\n      transparentColumnIndex,\n      alignByFixedColumnCellCount,\n      that = this,\n      column = options.column,\n      isFixedTableRendering = that._isFixedTableRendering,\n      isGroupCell = \"group\" === options.rowType && (0, _type.isDefined)(column.groupIndex);\n    if (isFixedTableRendering && isGroupCell && !column.command) {\n      $cell.css(\"pointerEvents\", \"none\");\n    }\n    if (!isFixedTableRendering && that._isFixedColumns) {\n      isEmptyCell = column.fixed || column.command && false !== column.fixed;\n      if (isGroupCell) {\n        isEmptyCell = false;\n        if (options.row.summaryCells && options.row.summaryCells.length) {\n          columns = that._columnsController.getVisibleColumns();\n          alignByFixedColumnCellCount = that._getAlignByColumnCellCount ? that._getAlignByColumnCellCount(column.colspan, {\n            columns: columns,\n            row: options.row,\n            isFixed: true\n          }) : 0;\n          if (alignByFixedColumnCellCount > 0) {\n            transparentColumnIndex = getTransparentColumnIndex(that._columnsController.getFixedColumns());\n            isEmptyCell = columns.length - alignByFixedColumnCellCount < transparentColumnIndex;\n          }\n        }\n      }\n      if (isEmptyCell) {\n        if (that.option(\"legacyRendering\") || column.command && \"buttons\" !== column.type || \"group\" === options.rowType) {\n          $cell.html(\"&nbsp;\").addClass(column.cssClass);\n          return;\n        } else {\n          $cell.addClass(\"dx-hidden-cell\");\n        }\n      }\n    }\n    if (column.command !== COMMAND_TRANSPARENT) {\n      that.callBase($cell, options);\n    }\n  },\n  _getCellElementsCore: function _getCellElementsCore(rowIndex) {\n    var fixedColumn,\n      fixedColumns,\n      fixedColumnIndex,\n      fixedCellElements,\n      that = this,\n      cellElements = that.callBase(rowIndex),\n      isGroupRow = cellElements.parent().hasClass(GROUP_ROW_CLASS),\n      index = \"columnHeadersView\" === that.name ? rowIndex : void 0;\n    if (that._fixedTableElement && cellElements) {\n      fixedColumns = that.getFixedColumns(index);\n      fixedCellElements = that._getRowElements(that._fixedTableElement).eq(rowIndex).children(\"td\");\n      (0, _iterator.each)(fixedCellElements, function (columnIndex, cell) {\n        if (isGroupRow) {\n          if (cellElements[columnIndex] && \"hidden\" !== cell.style.visibility) {\n            cellElements[columnIndex] = cell;\n          }\n        } else {\n          fixedColumn = fixedColumns[columnIndex];\n          if (fixedColumn) {\n            if (fixedColumn.command === COMMAND_TRANSPARENT) {\n              if (fixedCellElements.eq(columnIndex).hasClass(MASTER_DETAIL_CELL_CLASS)) {\n                cellElements[columnIndex] = cell || cellElements[columnIndex];\n              }\n            } else {\n              fixedColumnIndex = that._columnsController.getVisibleIndex(fixedColumn.index, index);\n              cellElements[fixedColumnIndex] = cell || cellElements[fixedColumnIndex];\n            }\n          }\n        }\n      });\n    }\n    return cellElements;\n  },\n  getColumnWidths: function getColumnWidths() {\n    var fixedWidths,\n      that = this,\n      result = that.callBase(),\n      fixedColumns = that.getFixedColumns();\n    if (that._fixedTableElement && result.length) {\n      fixedWidths = that.callBase(that._fixedTableElement);\n    }\n    return normalizeColumnWidths(fixedColumns, result, fixedWidths);\n  },\n  _getTableElement: function _getTableElement() {\n    var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();\n    return tableElement;\n  },\n  _setTableElement: function _setTableElement(tableElement) {\n    if (this._isFixedTableRendering) {\n      this._fixedTableElement = tableElement.addClass(POINTER_EVENTS_NONE_CLASS);\n    } else {\n      this.callBase(tableElement);\n    }\n  },\n  getColumns: function getColumns(rowIndex, $tableElement) {\n    $tableElement = $tableElement || this._getTableElement();\n    if (this._isFixedTableRendering || $tableElement && $tableElement.closest(\"table\").parent(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).length) {\n      return this.getFixedColumns(rowIndex);\n    }\n    return this.callBase(rowIndex, $tableElement);\n  },\n  getRowIndex: function getRowIndex($row) {\n    var $fixedTable = this._fixedTableElement;\n    if ($fixedTable && $fixedTable.find($row).length) {\n      return this._getRowElements($fixedTable).index($row);\n    }\n    return this.callBase($row);\n  },\n  getTableElements: function getTableElements() {\n    var result = this.callBase.apply(this, arguments);\n    if (this._fixedTableElement) {\n      result = (0, _renderer2.default)([result.get(0), this._fixedTableElement.get(0)]);\n    }\n    return result;\n  },\n  getFixedColumns: function getFixedColumns(rowIndex) {\n    return this._columnsController.getFixedColumns(rowIndex);\n  },\n  getFixedColumnsOffset: function getFixedColumnsOffset() {\n    var $transparentColumn,\n      positionTransparentColumn,\n      offset = {\n        left: 0,\n        right: 0\n      };\n    if (this._fixedTableElement) {\n      $transparentColumn = this.getTransparentColumnElement();\n      positionTransparentColumn = $transparentColumn.position();\n      offset = {\n        left: positionTransparentColumn.left,\n        right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)\n      };\n    }\n    return offset;\n  },\n  getTransparentColumnElement: function getTransparentColumnElement() {\n    return this._fixedTableElement && this._fixedTableElement.find(\".\" + POINTER_EVENTS_NONE_CLASS).first();\n  },\n  getFixedTableElement: function getFixedTableElement() {\n    return this._fixedTableElement;\n  },\n  isFixedColumns: function isFixedColumns() {\n    return this._isFixedColumns;\n  },\n  _resizeCore: function _resizeCore() {\n    this.callBase();\n    this.synchronizeRows();\n  },\n  setColumnWidths: function setColumnWidths(widths) {\n    var columns,\n      visibleColumns = this._columnsController.getVisibleColumns(),\n      hasVisibleWidth = widths && widths.length && (0, _type.isDefined)(visibleColumns[0].visibleWidth),\n      useVisibleColumns = false;\n    this.callBase.apply(this, arguments);\n    if (this._fixedTableElement) {\n      if (this.option(\"legacyRendering\")) {\n        useVisibleColumns = widths && widths.length && !this.isScrollbarVisible(true);\n      } else {\n        var hasAutoWidth = widths && widths.some(function (width) {\n          return \"auto\" === width;\n        });\n        useVisibleColumns = hasAutoWidth && (!hasVisibleWidth || !this.isScrollbarVisible(true));\n      }\n      if (useVisibleColumns) {\n        columns = visibleColumns;\n      }\n      this.callBase(widths, this._fixedTableElement, columns, true);\n    }\n    if (hasVisibleWidth) {\n      this.synchronizeRows();\n    }\n  },\n  _createColGroup: function _createColGroup(columns) {\n    if (!this.option(\"legacyRendering\") && this._isFixedTableRendering && !this.option(\"columnAutoWidth\")) {\n      var visibleColumns = this._columnsController.getVisibleColumns();\n      var useVisibleColumns = visibleColumns.filter(function (column) {\n        return !column.width;\n      }).length;\n      if (useVisibleColumns) {\n        columns = visibleColumns;\n      }\n    }\n    return this.callBase(columns);\n  },\n  _getClientHeight: function _getClientHeight(element) {\n    var boundingClientRectElement = element.getBoundingClientRect && element.getBoundingClientRect();\n    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight;\n  },\n  synchronizeRows: function synchronizeRows() {\n    var rowHeight,\n      fixedRowHeight,\n      rowIndex,\n      heightTable,\n      heightFixedTable,\n      $rowElements,\n      $fixedRowElements,\n      $contentElement,\n      that = this,\n      rowHeights = [],\n      fixedRowHeights = [];\n    if (that._isFixedColumns && that._tableElement && that._fixedTableElement) {\n      heightTable = that._getClientHeight(that._tableElement.get(0));\n      heightFixedTable = that._getClientHeight(that._fixedTableElement.get(0));\n      $rowElements = that._getRowElements(that._tableElement);\n      $fixedRowElements = that._getRowElements(that._fixedTableElement);\n      $contentElement = that._findContentElement();\n      if (heightTable !== heightFixedTable) {\n        $contentElement && $contentElement.css(\"height\", heightTable);\n        $rowElements.css(\"height\", \"\");\n        $fixedRowElements.css(\"height\", \"\");\n        for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {\n          rowHeights.push(that._getClientHeight($rowElements.get(rowIndex)));\n          fixedRowHeights.push(that._getClientHeight($fixedRowElements.get(rowIndex)));\n        }\n        for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {\n          rowHeight = rowHeights[rowIndex];\n          fixedRowHeight = fixedRowHeights[rowIndex];\n          if (rowHeight > fixedRowHeight) {\n            $fixedRowElements.eq(rowIndex).css(\"height\", rowHeight);\n          } else {\n            if (rowHeight < fixedRowHeight) {\n              $rowElements.eq(rowIndex).css(\"height\", fixedRowHeight);\n            }\n          }\n        }\n        $contentElement && $contentElement.css(\"height\", \"\");\n      }\n    }\n  }\n};\nvar ColumnHeadersViewFixedColumnsExtender = (0, _extend.extend)({}, baseFixedColumns, {\n  _getRowVisibleColumns: function _getRowVisibleColumns(rowIndex) {\n    if (this._isFixedTableRendering) {\n      return this.getFixedColumns(rowIndex);\n    }\n    return this.callBase(rowIndex);\n  },\n  getContextMenuItems: function getContextMenuItems(options) {\n    var onItemClick,\n      that = this,\n      column = options.column,\n      columnFixingOptions = that.option(\"columnFixing\"),\n      items = that.callBase(options);\n    if (options.row && \"header\" === options.row.rowType) {\n      if (column && column.allowFixing) {\n        onItemClick = function onItemClick(params) {\n          switch (params.itemData.value) {\n            case \"none\":\n              that._columnsController.columnOption(column.index, \"fixed\", false);\n              break;\n            case \"left\":\n              that._columnsController.columnOption(column.index, {\n                fixed: true,\n                fixedPosition: \"left\"\n              });\n              break;\n            case \"right\":\n              that._columnsController.columnOption(column.index, {\n                fixed: true,\n                fixedPosition: \"right\"\n              });\n          }\n        };\n        items = items || [];\n        items.push({\n          text: columnFixingOptions.texts.fix,\n          beginGroup: true,\n          items: [{\n            text: columnFixingOptions.texts.leftPosition,\n            value: \"left\",\n            disabled: column.fixed && (!column.fixedPosition || \"left\" === column.fixedPosition),\n            onItemClick: onItemClick\n          }, {\n            text: columnFixingOptions.texts.rightPosition,\n            value: \"right\",\n            disabled: column.fixed && \"right\" === column.fixedPosition,\n            onItemClick: onItemClick\n          }]\n        }, {\n          text: columnFixingOptions.texts.unfix,\n          value: \"none\",\n          disabled: !column.fixed,\n          onItemClick: onItemClick\n        });\n      }\n    }\n    return items;\n  },\n  setScrollerSpacing: function setScrollerSpacing(width) {\n    var that = this,\n      rtlEnabled = that.option(\"rtlEnabled\");\n    that.callBase(width);\n    that.element().children(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).css(rtlEnabled ? {\n      paddingLeft: width\n    } : {\n      paddingRight: width\n    });\n  },\n  getFixedColumnElements: function getFixedColumnElements(rowIndex) {\n    var columnElements,\n      transparentColumnIndex,\n      $transparentColumnElement,\n      that = this;\n    if ((0, _type.isDefined)(rowIndex)) {\n      return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children();\n    }\n    columnElements = that.getColumnElements();\n    $transparentColumnElement = that.getTransparentColumnElement();\n    if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {\n      transparentColumnIndex = getTransparentColumnIndex(that.getFixedColumns());\n      columnElements.splice(transparentColumnIndex, $transparentColumnElement.get(0).colSpan, $transparentColumnElement.get(0));\n    }\n    return columnElements;\n  },\n  getColumnWidths: function getColumnWidths() {\n    var fixedWidths,\n      that = this,\n      result = that.callBase(),\n      $fixedColumnElements = that.getFixedColumnElements(),\n      fixedColumns = that.getFixedColumns();\n    if (that._fixedTableElement) {\n      if ($fixedColumnElements && $fixedColumnElements.length) {\n        fixedWidths = that._getWidths($fixedColumnElements);\n      } else {\n        fixedWidths = that.callBase(that._fixedTableElement);\n      }\n    }\n    return normalizeColumnWidths(fixedColumns, result, fixedWidths);\n  }\n});\nvar RowsViewFixedColumnsExtender = (0, _extend.extend)({}, baseFixedColumns, {\n  _detachHoverEvents: function _detachHoverEvents() {\n    this._fixedTableElement && _events_engine2.default.off(this._fixedTableElement, \"mouseover mouseout\", \".dx-data-row\");\n    this._tableElement && _events_engine2.default.off(this._tableElement, \"mouseover mouseout\", \".dx-data-row\");\n  },\n  _attachHoverEvents: function _attachHoverEvents() {\n    var that = this,\n      attachHoverEvent = function attachHoverEvent($table) {\n        _events_engine2.default.on($table, \"mouseover mouseout\", \".dx-data-row\", that.createAction(function (args) {\n          var event = args.event,\n            rowIndex = that.getRowIndex((0, _renderer2.default)(event.target).closest(\".dx-row\")),\n            isHover = \"mouseover\" === event.type;\n          if (rowIndex >= 0) {\n            that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);\n            that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);\n          }\n        }));\n      };\n    if (that._fixedTableElement && that._tableElement) {\n      attachHoverEvent(that._fixedTableElement);\n      attachHoverEvent(that._tableElement);\n    }\n  },\n  _findContentElement: function _findContentElement() {\n    var $content,\n      scrollable,\n      scrollTop,\n      that = this,\n      contentClass = that.addWidgetPrefix(CONTENT_CLASS),\n      element = that.element(),\n      scrollDelay = _browser2.default.mozilla ? 60 : 0;\n    if (element && that._isFixedTableRendering) {\n      $content = element.children(\".\" + contentClass);\n      scrollable = that.getScrollable();\n      if (!$content.length && scrollable) {\n        $content = (0, _renderer2.default)(\"<div>\").addClass(contentClass);\n        _events_engine2.default.on($content, \"scroll\", function (e) {\n          clearTimeout(that._fixedScrollTimeout);\n          that._fixedScrollTimeout = setTimeout(function () {\n            scrollTop = (0, _renderer2.default)(e.target).scrollTop();\n            scrollable.scrollTo({\n              y: scrollTop\n            });\n          }, scrollDelay);\n        });\n        _events_engine2.default.on($content, _wheel2.default.name, function (e) {\n          if (scrollable) {\n            scrollTop = scrollable.scrollTop();\n            scrollable.scrollTo({\n              y: scrollTop - e.delta\n            });\n            if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth()) {\n              return false;\n            }\n          }\n        });\n        $content.appendTo(element);\n      }\n      return $content;\n    }\n    return that.callBase();\n  },\n  _updateScrollable: function _updateScrollable() {\n    this.callBase();\n    var scrollable = this.getScrollable(),\n      scrollTop = scrollable && scrollable.scrollOffset().top;\n    this._updateFixedTablePosition(scrollTop);\n  },\n  _renderContent: function _renderContent(contentElement, tableElement) {\n    if (this._isFixedTableRendering) {\n      return contentElement.empty().addClass(this.addWidgetPrefix(CONTENT_CLASS) + \" \" + this.addWidgetPrefix(CONTENT_FIXED_CLASS) + \" \" + POINTER_EVENTS_TARGET_CLASS).append(tableElement);\n    }\n    return this.callBase(contentElement, tableElement);\n  },\n  _getGroupCellOptions: function _getGroupCellOptions(options) {\n    if (this._isFixedTableRendering) {\n      return this.callBase((0, _extend.extend)({}, options, {\n        columns: this._columnsController.getVisibleColumns()\n      }));\n    }\n    return this.callBase(options);\n  },\n  _renderGroupedCells: function _renderGroupedCells($row, options) {\n    return this.callBase($row, (0, _extend.extend)({}, options, {\n      columns: this._columnsController.getVisibleColumns()\n    }));\n  },\n  _renderGroupSummaryCells: function _renderGroupSummaryCells($row, options) {\n    if (this._isFixedTableRendering) {\n      this.callBase($row, (0, _extend.extend)({}, options, {\n        columns: this._columnsController.getVisibleColumns()\n      }));\n    } else {\n      this.callBase($row, options);\n    }\n  },\n  _hasAlignByColumnSummaryItems: function _hasAlignByColumnSummaryItems(columnIndex, options) {\n    var result = this.callBase.apply(this, arguments),\n      column = options.columns[columnIndex];\n    if (options.isFixed) {\n      return column.fixed && (result || \"right\" === column.fixedPosition);\n    }\n    return result && !column.fixed;\n  },\n  _renderGroupSummaryCellsCore: function _renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount) {\n    var startColumnIndex, transparentColumnIndex, alignByFixedColumnCellCount;\n    if (this._isFixedTableRendering) {\n      options.isFixed = true;\n      alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);\n      options.isFixed = false;\n      startColumnIndex = options.columns.length - alignByFixedColumnCellCount;\n      options = (0, _extend.extend)({}, options, {\n        columns: this.getFixedColumns()\n      });\n      transparentColumnIndex = getTransparentColumnIndex(options.columns);\n      if (startColumnIndex < transparentColumnIndex) {\n        alignByFixedColumnCellCount -= options.columns[transparentColumnIndex].colspan - 1 || 0;\n        groupCellColSpan -= options.columns[transparentColumnIndex].colspan - 1 || 0;\n      } else {\n        if (alignByColumnCellCount > 0) {\n          $groupCell.css(\"visibility\", \"hidden\");\n        }\n      }\n      alignByColumnCellCount = alignByFixedColumnCellCount;\n    }\n    this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount);\n  },\n  _getSummaryCellIndex: function _getSummaryCellIndex(columnIndex, columns) {\n    var transparentColumnIndex;\n    if (this._isFixedTableRendering) {\n      transparentColumnIndex = getTransparentColumnIndex(columns);\n      if (columnIndex > transparentColumnIndex) {\n        columnIndex += columns[transparentColumnIndex].colspan - 1;\n      }\n      return columnIndex;\n    }\n    return this.callBase.apply(this, arguments);\n  },\n  _renderCore: function _renderCore(change) {\n    this._detachHoverEvents();\n    this.callBase(change);\n    var isFixedColumns = this._isFixedColumns;\n    this.element().toggleClass(FIXED_COLUMNS_CLASS, isFixedColumns);\n    if (this.option(\"hoverStateEnabled\") && isFixedColumns) {\n      this._attachHoverEvents();\n    }\n  },\n  setRowsOpacity: function setRowsOpacity(columnIndex, value) {\n    this.callBase(columnIndex, value);\n    var $rows = this._getRowElements(this._fixedTableElement);\n    this._setRowsOpacityCore($rows, this.getFixedColumns(), columnIndex, value);\n  },\n  optionChanged: function optionChanged(args) {\n    var that = this;\n    that.callBase(args);\n    if (\"hoverStateEnabled\" === args.name && that._isFixedColumns) {\n      args.value ? this._attachHoverEvents() : this._detachHoverEvents();\n    }\n  },\n  getCellIndex: function getCellIndex($cell) {\n    var columns,\n      $fixedTable = this._fixedTableElement,\n      cellIndex = 0;\n    if ($fixedTable && $fixedTable.find($cell).length) {\n      columns = this.getFixedColumns();\n      (0, _iterator.each)(columns, function (index, column) {\n        if (index === $cell[0].cellIndex) {\n          return false;\n        }\n        if (column.colspan) {\n          cellIndex += column.colspan;\n          return;\n        }\n        cellIndex++;\n      });\n      return cellIndex;\n    }\n    return this.callBase.apply(this, arguments);\n  },\n  _updateFixedTablePosition: function _updateFixedTablePosition(scrollTop, needFocus) {\n    if (this._fixedTableElement && this._tableElement) {\n      var $focusedElement,\n        editorFactory = this.getController(\"editorFactory\");\n      this._fixedTableElement.parent().scrollTop(scrollTop);\n      if (needFocus) {\n        $focusedElement = editorFactory.focus();\n        $focusedElement && editorFactory.focus($focusedElement);\n      }\n    }\n  },\n  setScrollerSpacing: function setScrollerSpacing(vWidth, hWidth) {\n    var useNativeScrolling,\n      that = this,\n      styles = {\n        marginBottom: 0\n      },\n      $fixedContent = that.element().children(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS));\n    if ($fixedContent.length && that._fixedTableElement) {\n      $fixedContent.css(styles);\n      that._fixedTableElement.css(styles);\n      styles[that.option(\"rtlEnabled\") ? \"marginLeft\" : \"marginRight\"] = vWidth;\n      styles.marginBottom = hWidth;\n      useNativeScrolling = that._scrollable && that._scrollable.option(\"useNative\");\n      (useNativeScrolling ? $fixedContent : that._fixedTableElement).css(styles);\n    }\n  },\n  _getElasticScrollTop: function _getElasticScrollTop(e) {\n    var maxScrollTop = void 0,\n      scrollableContent = void 0,\n      scrollableContainer = void 0,\n      elasticScrollTop = 0,\n      scrollbarWidth = this.getScrollbarWidth(true);\n    if (e.scrollOffset.top < 0) {\n      elasticScrollTop = -e.scrollOffset.top;\n    } else {\n      if (e.reachedBottom) {\n        scrollableContent = this._findContentElement();\n        scrollableContainer = e.component._container();\n        maxScrollTop = Math.max(scrollableContent.height() + scrollbarWidth - scrollableContainer.height(), 0);\n        elasticScrollTop = maxScrollTop - e.scrollOffset.top;\n      }\n    }\n    return elasticScrollTop;\n  },\n  _applyElasticScrolling: function _applyElasticScrolling(e) {\n    if (this._fixedTableElement) {\n      var elasticScrollTop = this._getElasticScrollTop(e);\n      if (0 !== Math.ceil(elasticScrollTop)) {\n        _translator2.default.move(this._fixedTableElement, {\n          top: elasticScrollTop\n        });\n      } else {\n        this._fixedTableElement.css(\"transform\", \"\");\n      }\n    }\n  },\n  _handleScroll: function _handleScroll(e) {\n    this._updateFixedTablePosition(e.scrollOffset.top, true);\n    this._applyElasticScrolling(e);\n    this.callBase(e);\n  },\n  _updateContentPosition: function _updateContentPosition(isRender) {\n    this.callBase.apply(this, arguments);\n    if (!isRender) {\n      this._updateFixedTablePosition(this._scrollTop);\n    }\n  },\n  _afterRowPrepared: function _afterRowPrepared(e) {\n    if (this._isFixedTableRendering) {\n      return;\n    }\n    this.callBase(e);\n  },\n  dispose: function dispose() {\n    this.callBase.apply(this, arguments);\n    clearTimeout(this._fixedScrollTimeout);\n  }\n});\nvar FooterViewFixedColumnsExtender = baseFixedColumns;\nmodule.exports = {\n  defaultOptions: function defaultOptions() {\n    return {\n      columnFixing: {\n        enabled: false,\n        texts: {\n          fix: _message2.default.format(\"dxDataGrid-columnFixingFix\"),\n          unfix: _message2.default.format(\"dxDataGrid-columnFixingUnfix\"),\n          leftPosition: _message2.default.format(\"dxDataGrid-columnFixingLeftPosition\"),\n          rightPosition: _message2.default.format(\"dxDataGrid-columnFixingRightPosition\")\n        }\n      }\n    };\n  },\n  extenders: {\n    views: {\n      columnHeadersView: ColumnHeadersViewFixedColumnsExtender,\n      rowsView: RowsViewFixedColumnsExtender,\n      footerView: FooterViewFixedColumnsExtender\n    },\n    controllers: function () {\n      var normalizeColumnIndicesByPoints = function normalizeColumnIndicesByPoints(columns, fixedColumns, pointsByColumns) {\n        var transparentColumnIndex = getTransparentColumnIndex(fixedColumns),\n          correctIndex = columns.length - fixedColumns.length;\n        (0, _iterator.each)(pointsByColumns, function (_, point) {\n          if (point.index > transparentColumnIndex) {\n            point.columnIndex += correctIndex;\n            point.index += correctIndex;\n          }\n        });\n        return pointsByColumns;\n      };\n      return {\n        draggingHeader: {\n          _generatePointsByColumns: function _generatePointsByColumns(options) {\n            var pointsByColumns,\n              visibleColumns = options.columns,\n              targetDraggingPanel = options.targetDraggingPanel;\n            if (targetDraggingPanel && \"headers\" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {\n              if (options.sourceColumn.fixed) {\n                if (!options.rowIndex) {\n                  options.columnElements = targetDraggingPanel.getFixedColumnElements(0);\n                }\n                options.columns = targetDraggingPanel.getFixedColumns(options.rowIndex);\n                pointsByColumns = this.callBase(options);\n                normalizeColumnIndicesByPoints(visibleColumns, options.columns, pointsByColumns);\n                return pointsByColumns;\n              }\n            }\n            return this.callBase(options);\n          },\n          _pointCreated: function _pointCreated(point, columns, location, sourceColumn) {\n            var boundingRect,\n              result = this.callBase.apply(this, arguments),\n              $transparentColumn = this._columnHeadersView.getTransparentColumnElement();\n            if (!result && \"headers\" === location && $transparentColumn && $transparentColumn.length) {\n              boundingRect = $transparentColumn.get(0).getBoundingClientRect();\n              if (sourceColumn && sourceColumn.fixed) {\n                return \"right\" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left;\n              } else {\n                return point.x < boundingRect.left || point.x > boundingRect.right;\n              }\n            }\n            return result;\n          }\n        },\n        columnsResizer: {\n          _generatePointsByColumns: function _generatePointsByColumns() {\n            var that = this,\n              columnsController = that._columnsController,\n              columns = columnsController && that._columnsController.getVisibleColumns(),\n              fixedColumns = columnsController && that._columnsController.getFixedColumns(),\n              cells = that._columnHeadersView.getFixedColumnElements(),\n              pointsByFixedColumns = [];\n            that.callBase();\n            if (cells && cells.length > 0) {\n              pointsByFixedColumns = _uiGrid_core2.default.getPointsByColumns(cells, function (point) {\n                return that._pointCreated(point, cells.length, fixedColumns);\n              });\n              that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, fixedColumns, pointsByFixedColumns);\n            }\n          },\n          _pointCreated: function _pointCreated(point, cellsLength, columns) {\n            var currentColumn,\n              nextColumn,\n              isWidgetResizingMode = \"widget\" === this.option(\"columnResizingMode\");\n            if (point.index > 0 && point.index < cellsLength) {\n              currentColumn = columns[point.columnIndex - 1] || {};\n              nextColumn = columns[point.columnIndex] || {};\n              if (currentColumn.fixed || nextColumn.fixed) {\n                point.columnIndex -= 1;\n                return !((currentColumn.allowResizing || currentColumn.command === COMMAND_TRANSPARENT) && (isWidgetResizingMode || nextColumn.allowResizing || nextColumn.command === COMMAND_TRANSPARENT));\n              }\n            }\n            return this.callBase.apply(this, arguments);\n          },\n          _getTargetPoint: function _getTargetPoint(pointsByColumns, currentX, deltaX) {\n            var boundingRect,\n              $transparentColumn = this._columnHeadersView.getTransparentColumnElement();\n            if ($transparentColumn && $transparentColumn.length) {\n              boundingRect = $transparentColumn.get(0).getBoundingClientRect();\n              if (currentX <= boundingRect.left || currentX >= boundingRect.right) {\n                return this.callBase(this._pointsByFixedColumns, currentX, deltaX);\n              }\n            }\n            return this.callBase(pointsByColumns, currentX, deltaX);\n          }\n        },\n        keyboardNavigation: {\n          _scrollToElement: function _scrollToElement($element) {\n            var focusedView = this.getFocusedView();\n            this.callBase($element, focusedView && focusedView.getFixedColumnsOffset());\n          }\n        }\n      };\n    }()\n  }\n};","map":null,"metadata":{},"sourceType":"script"}