{"ast":null,"code":"/**\r\n * DevExtreme (animation/position.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../core/renderer\"),\n  commonUtils = require(\"../core/utils/common\"),\n  each = require(\"../core/utils/iterator\").each,\n  windowUtils = require(\"../core/utils/window\"),\n  window = windowUtils.getWindow(),\n  domAdapter = require(\"../core/dom_adapter\"),\n  isWindow = require(\"../core/utils/type\").isWindow,\n  extend = require(\"../core/utils/extend\").extend,\n  browser = require(\"../core/utils/browser\"),\n  translator = require(\"./translator\"),\n  support = require(\"../core/utils/support\");\nvar horzRe = /left|right/,\n  vertRe = /top|bottom/,\n  collisionRe = /fit|flip|none/,\n  IS_SAFARI = browser.safari;\nvar normalizeAlign = function normalizeAlign(raw) {\n  var result = {\n    h: \"center\",\n    v: \"center\"\n  };\n  var pair = commonUtils.splitPair(raw);\n  if (pair) {\n    each(pair, function () {\n      var w = String(this).toLowerCase();\n      if (horzRe.test(w)) {\n        result.h = w;\n      } else {\n        if (vertRe.test(w)) {\n          result.v = w;\n        }\n      }\n    });\n  }\n  return result;\n};\nvar normalizeOffset = function normalizeOffset(raw) {\n  return commonUtils.pairToObject(raw);\n};\nvar normalizeCollision = function normalizeCollision(raw) {\n  var pair = commonUtils.splitPair(raw),\n    h = String(pair && pair[0]).toLowerCase(),\n    v = String(pair && pair[1]).toLowerCase();\n  if (!collisionRe.test(h)) {\n    h = \"none\";\n  }\n  if (!collisionRe.test(v)) {\n    v = h;\n  }\n  return {\n    h: h,\n    v: v\n  };\n};\nvar getAlignFactor = function getAlignFactor(align) {\n  switch (align) {\n    case \"center\":\n      return .5;\n    case \"right\":\n    case \"bottom\":\n      return 1;\n    default:\n      return 0;\n  }\n};\nvar inverseAlign = function inverseAlign(align) {\n  switch (align) {\n    case \"left\":\n      return \"right\";\n    case \"right\":\n      return \"left\";\n    case \"top\":\n      return \"bottom\";\n    case \"bottom\":\n      return \"top\";\n    default:\n      return align;\n  }\n};\nvar calculateOversize = function calculateOversize(data, bounds) {\n  var oversize = 0;\n  if (data.myLocation < bounds.min) {\n    oversize += bounds.min - data.myLocation;\n  }\n  if (data.myLocation > bounds.max) {\n    oversize += data.myLocation - bounds.max;\n  }\n  return oversize;\n};\nvar collisionSide = function collisionSide(direction, data, bounds) {\n  if (data.myLocation < bounds.min) {\n    return \"h\" === direction ? \"left\" : \"top\";\n  }\n  if (data.myLocation > bounds.max) {\n    return \"h\" === direction ? \"right\" : \"bottom\";\n  }\n  return \"none\";\n};\nvar initMyLocation = function initMyLocation(data) {\n  data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset;\n};\nvar collisionResolvers = {\n  fit: function fit(data, bounds) {\n    var result = false;\n    if (data.myLocation > bounds.max) {\n      data.myLocation = bounds.max;\n      result = true;\n    }\n    if (data.myLocation < bounds.min) {\n      data.myLocation = bounds.min;\n      result = true;\n    }\n    data.fit = result;\n  },\n  flip: function flip(data, bounds) {\n    data.flip = false;\n    if (\"center\" === data.myAlign && \"center\" === data.atAlign) {\n      return;\n    }\n    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {\n      var inverseData = extend({}, data, {\n        myAlign: inverseAlign(data.myAlign),\n        atAlign: inverseAlign(data.atAlign),\n        offset: -data.offset\n      });\n      initMyLocation(inverseData);\n      inverseData.oversize = calculateOversize(inverseData, bounds);\n      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {\n        data.myLocation = inverseData.myLocation;\n        data.oversize = inverseData.oversize;\n        data.flip = true;\n      }\n    }\n  },\n  flipfit: function flipfit(data, bounds) {\n    this.flip(data, bounds);\n    this.fit(data, bounds);\n  },\n  none: function none(data) {\n    data.oversize = 0;\n  }\n};\nvar scrollbarWidth;\nvar calculateScrollbarWidth = function calculateScrollbarWidth() {\n  var $scrollDiv = $(\"<div>\").css({\n      width: 100,\n      height: 100,\n      overflow: \"scroll\",\n      position: \"absolute\",\n      top: -9999\n    }).appendTo($(\"body\")),\n    result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;\n  $scrollDiv.remove();\n  scrollbarWidth = result;\n};\nvar defaultPositionResult = {\n  h: {\n    location: 0,\n    flip: false,\n    fit: false,\n    oversize: 0\n  },\n  v: {\n    location: 0,\n    flip: false,\n    fit: false,\n    oversize: 0\n  }\n};\nvar calculatePosition = function calculatePosition(what, options) {\n  var $what = $(what),\n    currentOffset = $what.offset(),\n    result = extend(true, {}, defaultPositionResult, {\n      h: {\n        location: currentOffset.left\n      },\n      v: {\n        location: currentOffset.top\n      }\n    });\n  if (!options) {\n    return result;\n  }\n  var my = normalizeAlign(options.my),\n    at = normalizeAlign(options.at),\n    of = $(options.of).length && options.of || window,\n    offset = normalizeOffset(options.offset),\n    collision = normalizeCollision(options.collision),\n    boundary = options.boundary,\n    boundaryOffset = normalizeOffset(options.boundaryOffset);\n  var h = {\n    mySize: $what.outerWidth(),\n    myAlign: my.h,\n    atAlign: at.h,\n    offset: offset.h,\n    collision: collision.h,\n    boundaryOffset: boundaryOffset.h\n  };\n  var v = {\n    mySize: $what.outerHeight(),\n    myAlign: my.v,\n    atAlign: at.v,\n    offset: offset.v,\n    collision: collision.v,\n    boundaryOffset: boundaryOffset.v\n  };\n  if (of.preventDefault) {\n    h.atLocation = of.pageX;\n    v.atLocation = of.pageY;\n    h.atSize = 0;\n    v.atSize = 0;\n  } else {\n    of = $(of);\n    if (isWindow(of[0])) {\n      h.atLocation = of.scrollLeft();\n      v.atLocation = of.scrollTop();\n      h.atSize = of[0].innerWidth >= of[0].outerWidth ? of[0].innerWidth : of.width();\n      v.atSize = of[0].innerHeight >= of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : of.height();\n    } else {\n      if (9 === of[0].nodeType) {\n        h.atLocation = 0;\n        v.atLocation = 0;\n        h.atSize = of.width();\n        v.atSize = of.height();\n      } else {\n        var o = of.offset();\n        h.atLocation = o.left;\n        v.atLocation = o.top;\n        h.atSize = of.outerWidth();\n        v.atSize = of.outerHeight();\n      }\n    }\n  }\n  initMyLocation(h);\n  initMyLocation(v);\n  var bounds = function () {\n    var win = $(window),\n      windowWidth = win.width(),\n      windowHeight = win.height(),\n      left = win.scrollLeft(),\n      top = win.scrollTop(),\n      documentElement = domAdapter.getDocumentElement(),\n      hZoomLevel = support.touch ? documentElement.clientWidth / windowWidth : 1,\n      vZoomLevel = support.touch ? documentElement.clientHeight / windowHeight : 1;\n    if (void 0 === scrollbarWidth) {\n      calculateScrollbarWidth();\n    }\n    var boundaryWidth = windowWidth,\n      boundaryHeight = windowHeight;\n    if (boundary) {\n      var $boundary = $(boundary),\n        boundaryPosition = $boundary.offset();\n      left = boundaryPosition.left;\n      top = boundaryPosition.top;\n      boundaryWidth = $boundary.width();\n      boundaryHeight = $boundary.height();\n    }\n    return {\n      h: {\n        min: left + h.boundaryOffset,\n        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset\n      },\n      v: {\n        min: top + v.boundaryOffset,\n        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset\n      }\n    };\n  }();\n  h.oversize = calculateOversize(h, bounds.h);\n  v.oversize = calculateOversize(v, bounds.v);\n  h.collisionSide = collisionSide(\"h\", h, bounds.h);\n  v.collisionSide = collisionSide(\"v\", v, bounds.v);\n  if (collisionResolvers[h.collision]) {\n    collisionResolvers[h.collision](h, bounds.h);\n  }\n  if (collisionResolvers[v.collision]) {\n    collisionResolvers[v.collision](v, bounds.v);\n  }\n  var preciser = function preciser(number) {\n    return options.precise ? number : Math.round(number);\n  };\n  extend(true, result, {\n    h: {\n      location: preciser(h.myLocation),\n      oversize: preciser(h.oversize),\n      fit: h.fit,\n      flip: h.flip,\n      collisionSide: h.collisionSide\n    },\n    v: {\n      location: preciser(v.myLocation),\n      oversize: preciser(v.oversize),\n      fit: v.fit,\n      flip: v.flip,\n      collisionSide: v.collisionSide\n    },\n    precise: options.precise\n  });\n  return result;\n};\nvar position = function position(what, options) {\n  var $what = $(what);\n  if (!options) {\n    return $what.offset();\n  }\n  translator.resetPosition($what, true);\n  var offset = $what.offset(),\n    targetPosition = options.h && options.v ? options : calculatePosition($what, options);\n  var preciser = function preciser(number) {\n    return options.precise ? number : Math.round(number);\n  };\n  translator.move($what, {\n    left: targetPosition.h.location - preciser(offset.left),\n    top: targetPosition.v.location - preciser(offset.top)\n  });\n  return targetPosition;\n};\nvar offset = function offset(element) {\n  element = $(element).get(0);\n  if (isWindow(element)) {\n    return null;\n  } else {\n    if (element && \"pageY\" in element && \"pageX\" in element) {\n      return {\n        top: element.pageY,\n        left: element.pageX\n      };\n    }\n  }\n  return $(element).offset();\n};\nif (!position.inverseAlign) {\n  position.inverseAlign = inverseAlign;\n}\nif (!position.normalizeAlign) {\n  position.normalizeAlign = normalizeAlign;\n}\nmodule.exports = {\n  calculateScrollbarWidth: calculateScrollbarWidth,\n  calculate: calculatePosition,\n  setup: position,\n  offset: offset\n};","map":null,"metadata":{},"sourceType":"script"}