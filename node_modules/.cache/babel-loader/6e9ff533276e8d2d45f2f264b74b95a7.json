{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.scrollable.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\"),\n  eventsEngine = require(\"../../events/core/events_engine\"),\n  support = require(\"../../core/utils/support\"),\n  browser = require(\"../../core/utils/browser\"),\n  commonUtils = require(\"../../core/utils/common\"),\n  typeUtils = require(\"../../core/utils/type\"),\n  extend = require(\"../../core/utils/extend\").extend,\n  getPublicElement = require(\"../../core/utils/dom\").getPublicElement,\n  windowUtils = require(\"../../core/utils/window\"),\n  navigator = windowUtils.getNavigator(),\n  domAdapter = require(\"../../core/dom_adapter\"),\n  devices = require(\"../../core/devices\"),\n  registerComponent = require(\"../../core/component_registrator\"),\n  DOMComponent = require(\"../../core/dom_component\"),\n  selectors = require(\"../widget/selectors\"),\n  eventUtils = require(\"../../events/utils\"),\n  scrollEvents = require(\"./ui.events.emitter.gesture.scroll\"),\n  simulatedStrategy = require(\"./ui.scrollable.simulated\"),\n  NativeStrategy = require(\"./ui.scrollable.native\"),\n  when = require(\"../../core/utils/deferred\").when;\nvar SCROLLABLE = \"dxScrollable\",\n  SCROLLABLE_STRATEGY = \"dxScrollableStrategy\",\n  SCROLLABLE_CLASS = \"dx-scrollable\",\n  SCROLLABLE_DISABLED_CLASS = \"dx-scrollable-disabled\",\n  SCROLLABLE_CONTAINER_CLASS = \"dx-scrollable-container\",\n  SCROLLABLE_WRAPPER_CLASS = \"dx-scrollable-wrapper\",\n  SCROLLABLE_CONTENT_CLASS = \"dx-scrollable-content\",\n  SCROLLABLE_CUSTOMIZABLE_SCROLLBARS_CLASS = \"dx-scrollable-customizable-scrollbars\",\n  VERTICAL = \"vertical\",\n  HORIZONTAL = \"horizontal\",\n  BOTH = \"both\";\nvar deviceDependentOptions = function deviceDependentOptions() {\n  return [{\n    device: function device() {\n      return !support.nativeScrolling;\n    },\n    options: {\n      useNative: false\n    }\n  }, {\n    device: function device(_device) {\n      return !devices.isSimulator() && \"desktop\" === devices.real().deviceType && \"generic\" === _device.platform;\n    },\n    options: {\n      bounceEnabled: false,\n      scrollByThumb: true,\n      scrollByContent: support.touch,\n      showScrollbar: \"onHover\"\n    }\n  }];\n};\nvar Scrollable = DOMComponent.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      disabled: false,\n      onScroll: null,\n      direction: VERTICAL,\n      showScrollbar: \"onScroll\",\n      useNative: true,\n      bounceEnabled: true,\n      scrollByContent: true,\n      scrollByThumb: false,\n      onUpdated: null,\n      onStart: null,\n      onEnd: null,\n      onBounce: null,\n      onStop: null,\n      useSimulatedScrollbar: false,\n      useKeyboard: true,\n      inertiaEnabled: true,\n      pushBackValue: 0,\n      updateManually: false\n    });\n  },\n  _defaultOptionsRules: function _defaultOptionsRules() {\n    return this.callBase().concat(deviceDependentOptions(), [{\n      device: function device() {\n        return support.nativeScrolling && \"android\" === devices.real().platform && !browser.mozilla;\n      },\n      options: {\n        useSimulatedScrollbar: true\n      }\n    }, {\n      device: function device() {\n        return \"ios\" === devices.real().platform;\n      },\n      options: {\n        pushBackValue: 1\n      }\n    }]);\n  },\n  _initOptions: function _initOptions(options) {\n    this.callBase(options);\n    if (!(\"useSimulatedScrollbar\" in options)) {\n      this._setUseSimulatedScrollbar();\n    }\n  },\n  _setUseSimulatedScrollbar: function _setUseSimulatedScrollbar() {\n    if (!this.initialOption(\"useSimulatedScrollbar\")) {\n      this.option(\"useSimulatedScrollbar\", !this.option(\"useNative\"));\n    }\n  },\n  _init: function _init() {\n    this.callBase();\n    this._initScrollableMarkup();\n    this._locked = false;\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible) {\n      this.update();\n      this._updateRtlPosition();\n      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);\n      delete this._savedScrollOffset;\n    } else {\n      this._savedScrollOffset = this.scrollOffset();\n    }\n  },\n  _initScrollableMarkup: function _initScrollableMarkup() {\n    var $element = this.$element().addClass(SCROLLABLE_CLASS),\n      $container = this._$container = $(\"<div>\").addClass(SCROLLABLE_CONTAINER_CLASS),\n      $wrapper = this._$wrapper = $(\"<div>\").addClass(SCROLLABLE_WRAPPER_CLASS),\n      $content = this._$content = $(\"<div>\").addClass(SCROLLABLE_CONTENT_CLASS);\n    if (domAdapter.hasDocumentProperty(\"onbeforeactivate\") && browser.msie && browser.version < 12) {\n      eventsEngine.on($element, eventUtils.addNamespace(\"beforeactivate\", SCROLLABLE), function (e) {\n        if (!$(e.target).is(selectors.focusable)) {\n          e.preventDefault();\n        }\n      });\n    }\n    $content.append($element.contents()).appendTo($container);\n    $container.appendTo($wrapper);\n    $wrapper.appendTo($element);\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    this.update();\n  },\n  _attachNativeScrollbarsCustomizationCss: function _attachNativeScrollbarsCustomizationCss() {\n    if (\"desktop\" === devices.real().deviceType && !(navigator.platform.indexOf(\"Mac\") > -1 && browser.webkit)) {\n      this.$element().addClass(SCROLLABLE_CUSTOMIZABLE_SCROLLBARS_CLASS);\n    }\n  },\n  _initMarkup: function _initMarkup() {\n    this.callBase();\n    this._renderDirection();\n  },\n  _render: function _render() {\n    this._renderStrategy();\n    this._attachNativeScrollbarsCustomizationCss();\n    this._attachEventHandlers();\n    this._renderDisabledState();\n    this._createActions();\n    this.update();\n    this.callBase();\n    this._updateRtlPosition();\n  },\n  _updateRtlPosition: function _updateRtlPosition() {\n    var that = this,\n      rtl = that.option(\"rtlEnabled\");\n    this._updateBounds();\n    if (rtl && this.option(\"direction\") !== VERTICAL) {\n      commonUtils.deferUpdate(function () {\n        var left = that.scrollWidth() - that.clientWidth();\n        commonUtils.deferRender(function () {\n          that.scrollTo({\n            left: left\n          });\n        });\n      });\n    }\n  },\n  _updateBounds: function _updateBounds() {\n    this._strategy.updateBounds();\n  },\n  _attachEventHandlers: function _attachEventHandlers() {\n    var strategy = this._strategy;\n    var initEventData = {\n      getDirection: strategy.getDirection.bind(strategy),\n      validate: this._validate.bind(this),\n      isNative: this.option(\"useNative\"),\n      scrollTarget: this._$container\n    };\n    eventsEngine.off(this._$wrapper, \".\" + SCROLLABLE);\n    eventsEngine.on(this._$wrapper, eventUtils.addNamespace(scrollEvents.init, SCROLLABLE), initEventData, this._initHandler.bind(this));\n    eventsEngine.on(this._$wrapper, eventUtils.addNamespace(scrollEvents.start, SCROLLABLE), strategy.handleStart.bind(strategy));\n    eventsEngine.on(this._$wrapper, eventUtils.addNamespace(scrollEvents.move, SCROLLABLE), strategy.handleMove.bind(strategy));\n    eventsEngine.on(this._$wrapper, eventUtils.addNamespace(scrollEvents.end, SCROLLABLE), strategy.handleEnd.bind(strategy));\n    eventsEngine.on(this._$wrapper, eventUtils.addNamespace(scrollEvents.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy));\n    eventsEngine.on(this._$wrapper, eventUtils.addNamespace(scrollEvents.stop, SCROLLABLE), strategy.handleStop.bind(strategy));\n    eventsEngine.off(this._$container, \".\" + SCROLLABLE);\n    eventsEngine.on(this._$container, eventUtils.addNamespace(\"scroll\", SCROLLABLE), strategy.handleScroll.bind(strategy));\n  },\n  _validate: function _validate(e) {\n    if (this._isLocked()) {\n      return false;\n    }\n    this._updateIfNeed();\n    return this._strategy.validate(e);\n  },\n  _initHandler: function _initHandler() {\n    var strategy = this._strategy;\n    strategy.handleInit.apply(strategy, arguments);\n  },\n  _renderDisabledState: function _renderDisabledState() {\n    this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option(\"disabled\"));\n    if (this.option(\"disabled\")) {\n      this._lock();\n    } else {\n      this._unlock();\n    }\n  },\n  _renderDirection: function _renderDirection() {\n    this.$element().removeClass(\"dx-scrollable-\" + HORIZONTAL).removeClass(\"dx-scrollable-\" + VERTICAL).removeClass(\"dx-scrollable-\" + BOTH).addClass(\"dx-scrollable-\" + this.option(\"direction\"));\n  },\n  _renderStrategy: function _renderStrategy() {\n    this._createStrategy();\n    this._strategy.render();\n    this.$element().data(SCROLLABLE_STRATEGY, this._strategy);\n  },\n  _createStrategy: function _createStrategy() {\n    this._strategy = this.option(\"useNative\") ? new NativeStrategy(this) : new simulatedStrategy.SimulatedStrategy(this);\n  },\n  _createActions: function _createActions() {\n    this._strategy && this._strategy.createActions();\n  },\n  _clean: function _clean() {\n    this._strategy && this._strategy.dispose();\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"onStart\":\n      case \"onEnd\":\n      case \"onStop\":\n      case \"onUpdated\":\n      case \"onScroll\":\n      case \"onBounce\":\n        this._createActions();\n        break;\n      case \"direction\":\n        this._resetInactiveDirection();\n        this._invalidate();\n        break;\n      case \"useNative\":\n        this._setUseSimulatedScrollbar();\n        this._invalidate();\n        break;\n      case \"inertiaEnabled\":\n      case \"scrollByContent\":\n      case \"scrollByThumb\":\n      case \"bounceEnabled\":\n      case \"useKeyboard\":\n      case \"showScrollbar\":\n      case \"useSimulatedScrollbar\":\n      case \"pushBackValue\":\n        this._invalidate();\n        break;\n      case \"disabled\":\n        this._renderDisabledState();\n        this._strategy && this._strategy.disabledChanged();\n        break;\n      case \"updateManually\":\n        break;\n      case \"width\":\n        this.callBase(args);\n        this._updateRtlPosition();\n        break;\n      default:\n        this.callBase(args);\n    }\n  },\n  _resetInactiveDirection: function _resetInactiveDirection() {\n    var inactiveProp = this._getInactiveProp();\n    if (!inactiveProp || !windowUtils.hasWindow()) {\n      return;\n    }\n    var scrollOffset = this.scrollOffset();\n    scrollOffset[inactiveProp] = 0;\n    this.scrollTo(scrollOffset);\n  },\n  _getInactiveProp: function _getInactiveProp() {\n    var direction = this.option(\"direction\");\n    if (direction === VERTICAL) {\n      return \"left\";\n    }\n    if (direction === HORIZONTAL) {\n      return \"top\";\n    }\n  },\n  _location: function _location() {\n    return this._strategy.location();\n  },\n  _normalizeLocation: function _normalizeLocation(location) {\n    if (typeUtils.isPlainObject(location)) {\n      var left = commonUtils.ensureDefined(location.left, location.x);\n      var top = commonUtils.ensureDefined(location.top, location.y);\n      return {\n        left: typeUtils.isDefined(left) ? -left : void 0,\n        top: typeUtils.isDefined(top) ? -top : void 0\n      };\n    } else {\n      var direction = this.option(\"direction\");\n      return {\n        left: direction !== VERTICAL ? -location : void 0,\n        top: direction !== HORIZONTAL ? -location : void 0\n      };\n    }\n  },\n  _isLocked: function _isLocked() {\n    return this._locked;\n  },\n  _lock: function _lock() {\n    this._locked = true;\n  },\n  _unlock: function _unlock() {\n    if (!this.option(\"disabled\")) {\n      this._locked = false;\n    }\n  },\n  _isDirection: function _isDirection(direction) {\n    var current = this.option(\"direction\");\n    if (direction === VERTICAL) {\n      return current !== HORIZONTAL;\n    }\n    if (direction === HORIZONTAL) {\n      return current !== VERTICAL;\n    }\n    return current === direction;\n  },\n  _updateAllowedDirection: function _updateAllowedDirection() {\n    var allowedDirections = this._strategy._allowedDirections();\n    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {\n      this._allowedDirectionValue = BOTH;\n    } else {\n      if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {\n        this._allowedDirectionValue = HORIZONTAL;\n      } else {\n        if (this._isDirection(VERTICAL) && allowedDirections.vertical) {\n          this._allowedDirectionValue = VERTICAL;\n        } else {\n          this._allowedDirectionValue = null;\n        }\n      }\n    }\n  },\n  _allowedDirection: function _allowedDirection() {\n    return this._allowedDirectionValue;\n  },\n  _container: function _container() {\n    return this._$container;\n  },\n  $content: function $content() {\n    return this._$content;\n  },\n  content: function content() {\n    return getPublicElement(this._$content);\n  },\n  scrollOffset: function scrollOffset() {\n    var location = this._location();\n    return {\n      top: -location.top,\n      left: -location.left\n    };\n  },\n  scrollTop: function scrollTop() {\n    return this.scrollOffset().top;\n  },\n  scrollLeft: function scrollLeft() {\n    return this.scrollOffset().left;\n  },\n  clientHeight: function clientHeight() {\n    return this._$container.height();\n  },\n  scrollHeight: function scrollHeight() {\n    return this.$content().outerHeight() - 2 * this._strategy.verticalOffset();\n  },\n  clientWidth: function clientWidth() {\n    return this._$container.width();\n  },\n  scrollWidth: function scrollWidth() {\n    return this.$content().outerWidth();\n  },\n  update: function update() {\n    if (!this._strategy) {\n      return;\n    }\n    return when(this._strategy.update()).done(function () {\n      this._updateAllowedDirection();\n    }.bind(this));\n  },\n  scrollBy: function scrollBy(distance) {\n    distance = this._normalizeLocation(distance);\n    if (!distance.top && !distance.left) {\n      return;\n    }\n    this._updateIfNeed();\n    this._strategy.scrollBy(distance);\n  },\n  scrollTo: function scrollTo(targetLocation) {\n    targetLocation = this._normalizeLocation(targetLocation);\n    this._updateIfNeed();\n    var location = this._location();\n    if (!this.option(\"useNative\")) {\n      targetLocation = this._strategy._applyScaleRatio(targetLocation);\n      location = this._strategy._applyScaleRatio(location);\n    }\n    var distance = this._normalizeLocation({\n      left: location.left - commonUtils.ensureDefined(targetLocation.left, location.left),\n      top: location.top - commonUtils.ensureDefined(targetLocation.top, location.top)\n    });\n    if (!distance.top && !distance.left) {\n      return;\n    }\n    this._strategy.scrollBy(distance);\n  },\n  scrollToElement: function scrollToElement(element, offset) {\n    offset = offset || {};\n    var $element = $(element);\n    var elementInsideContent = this.$content().find(element).length;\n    var elementIsInsideContent = $element.parents(\".\" + SCROLLABLE_CLASS).length - $element.parents(\".\" + SCROLLABLE_CONTENT_CLASS).length === 0;\n    if (!elementInsideContent || !elementIsInsideContent) {\n      return;\n    }\n    var scrollPosition = {\n      top: 0,\n      left: 0\n    };\n    var direction = this.option(\"direction\");\n    if (direction !== VERTICAL) {\n      scrollPosition.left = this._scrollToElementPosition($element, HORIZONTAL, offset);\n    }\n    if (direction !== HORIZONTAL) {\n      scrollPosition.top = this._scrollToElementPosition($element, VERTICAL, offset);\n    }\n    this.scrollTo(scrollPosition);\n  },\n  _scrollToElementPosition: function _scrollToElementPosition($element, direction, offset) {\n    var isVertical = direction === VERTICAL;\n    var startOffset = (isVertical ? offset.top : offset.left) || 0;\n    var endOffset = (isVertical ? offset.bottom : offset.right) || 0;\n    var pushBackOffset = isVertical ? this._strategy.verticalOffset() : 0;\n    var elementPositionRelativeToContent = this._elementPositionRelativeToContent($element, isVertical ? \"top\" : \"left\");\n    var elementPosition = elementPositionRelativeToContent - pushBackOffset;\n    var elementSize = $element[isVertical ? \"outerHeight\" : \"outerWidth\"]();\n    var scrollLocation = isVertical ? this.scrollTop() : this.scrollLeft();\n    var clientSize = isVertical ? this.clientHeight() : this.clientWidth();\n    var startDistance = scrollLocation - elementPosition + startOffset;\n    var endDistance = scrollLocation - elementPosition - elementSize + clientSize - endOffset;\n    if (startDistance <= 0 && endDistance >= 0) {\n      return scrollLocation;\n    }\n    return scrollLocation - (Math.abs(startDistance) > Math.abs(endDistance) ? endDistance : startDistance);\n  },\n  _elementPositionRelativeToContent: function _elementPositionRelativeToContent($element, prop) {\n    var result = 0;\n    while (this._hasScrollContent($element)) {\n      result += $element.position()[prop];\n      $element = $element.offsetParent();\n    }\n    return result;\n  },\n  _hasScrollContent: function _hasScrollContent($element) {\n    var $content = this.$content();\n    return $element.closest($content).length && !$element.is($content);\n  },\n  _updateIfNeed: function _updateIfNeed() {\n    if (!this.option(\"updateManually\")) {\n      this.update();\n    }\n  }\n});\nregisterComponent(SCROLLABLE, Scrollable);\nmodule.exports = Scrollable;\nmodule.exports.deviceDependentOptions = deviceDependentOptions;","map":null,"metadata":{},"sourceType":"script"}