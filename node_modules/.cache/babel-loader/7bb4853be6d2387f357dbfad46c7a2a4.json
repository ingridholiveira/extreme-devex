{"ast":null,"code":"/**\r\n * DevExtreme (ui/overlay/ui.overlay.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _typeof = \"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar $ = require(\"../../core/renderer\"),\n  domAdapter = require(\"../../core/dom_adapter\"),\n  windowUtils = require(\"../../core/utils/window\"),\n  ready = require(\"../../core/utils/ready_callbacks\").add,\n  window = windowUtils.getWindow(),\n  navigator = windowUtils.getNavigator(),\n  eventsEngine = require(\"../../events/core/events_engine\"),\n  fx = require(\"../../animation/fx\"),\n  translator = require(\"../../animation/translator\"),\n  compareVersions = require(\"../../core/utils/version\").compare,\n  viewPortUtils = require(\"../../core/utils/view_port\"),\n  extend = require(\"../../core/utils/extend\").extend,\n  inArray = require(\"../../core/utils/array\").inArray,\n  getPublicElement = require(\"../../core/utils/dom\").getPublicElement,\n  viewPortChanged = viewPortUtils.changeCallback,\n  hideTopOverlayCallback = require(\"../../mobile/hide_top_overlay\").hideCallback,\n  positionUtils = require(\"../../animation/position\"),\n  fitIntoRange = require(\"../../core/utils/math\").fitIntoRange,\n  domUtils = require(\"../../core/utils/dom\"),\n  noop = require(\"../../core/utils/common\").noop,\n  typeUtils = require(\"../../core/utils/type\"),\n  each = require(\"../../core/utils/iterator\").each,\n  devices = require(\"../../core/devices\"),\n  browser = require(\"../../core/utils/browser\"),\n  registerComponent = require(\"../../core/component_registrator\"),\n  Widget = require(\"../widget/ui.widget\"),\n  KeyboardProcessor = require(\"../widget/ui.keyboard_processor\"),\n  selectors = require(\"../widget/selectors\"),\n  dragEvents = require(\"../../events/drag\"),\n  eventUtils = require(\"../../events/utils\"),\n  pointerEvents = require(\"../../events/pointer\"),\n  Resizable = require(\"../resizable\"),\n  EmptyTemplate = require(\"../../core/templates/empty_template\").EmptyTemplate,\n  Deferred = require(\"../../core/utils/deferred\").Deferred,\n  zIndexPool = require(\"./z_index\"),\n  swatch = require(\"../widget/swatch_container\");\nvar OVERLAY_CLASS = \"dx-overlay\",\n  OVERLAY_WRAPPER_CLASS = \"dx-overlay-wrapper\",\n  OVERLAY_CONTENT_CLASS = \"dx-overlay-content\",\n  OVERLAY_SHADER_CLASS = \"dx-overlay-shader\",\n  OVERLAY_MODAL_CLASS = \"dx-overlay-modal\",\n  INNER_OVERLAY_CLASS = \"dx-inner-overlay\",\n  INVISIBLE_STATE_CLASS = \"dx-state-invisible\",\n  ANONYMOUS_TEMPLATE_NAME = \"content\",\n  RTL_DIRECTION_CLASS = \"dx-rtl\",\n  ACTIONS = [\"onShowing\", \"onShown\", \"onHiding\", \"onHidden\", \"onPositioning\", \"onPositioned\", \"onResizeStart\", \"onResize\", \"onResizeEnd\"],\n  OVERLAY_STACK = [],\n  DISABLED_STATE_CLASS = \"dx-state-disabled\",\n  PREVENT_SAFARI_SCROLLING_CLASS = \"dx-prevent-safari-scrolling\",\n  TAB_KEY = \"tab\",\n  POSITION_ALIASES = {\n    top: {\n      my: \"top center\",\n      at: \"top center\"\n    },\n    bottom: {\n      my: \"bottom center\",\n      at: \"bottom center\"\n    },\n    right: {\n      my: \"right center\",\n      at: \"right center\"\n    },\n    left: {\n      my: \"left center\",\n      at: \"left center\"\n    },\n    center: {\n      my: \"center\",\n      at: \"center\"\n    },\n    \"right bottom\": {\n      my: \"right bottom\",\n      at: \"right bottom\"\n    },\n    \"right top\": {\n      my: \"right top\",\n      at: \"right top\"\n    },\n    \"left bottom\": {\n      my: \"left bottom\",\n      at: \"left bottom\"\n    },\n    \"left top\": {\n      my: \"left top\",\n      at: \"left top\"\n    }\n  };\nvar realDevice = devices.real(),\n  realVersion = realDevice.version,\n  firefoxDesktop = browser.mozilla && \"desktop\" === realDevice.deviceType,\n  iOS = \"ios\" === realDevice.platform,\n  hasSafariAddressBar = browser.safari && \"desktop\" !== realDevice.deviceType,\n  android4_0nativeBrowser = \"android\" === realDevice.platform && 0 === compareVersions(realVersion, [4, 0], 2) && navigator.userAgent.indexOf(\"Chrome\") === -1;\nvar forceRepaint = function forceRepaint($element) {\n  if (firefoxDesktop) {\n    $element.width();\n  }\n  if (android4_0nativeBrowser) {\n    var $parents = $element.parents(),\n      inScrollView = $parents.is(\".dx-scrollable-native\");\n    if (!inScrollView) {\n      $parents.css(\"backfaceVisibility\", \"hidden\");\n      $parents.css(\"backfaceVisibility\");\n      $parents.css(\"backfaceVisibility\", \"visible\");\n    }\n  }\n};\nvar getElement = function getElement(value) {\n  return value && $(value.target || value);\n};\nready(function () {\n  eventsEngine.subscribeGlobal(domAdapter.getDocument(), pointerEvents.down, function (e) {\n    for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {\n      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {\n        return;\n      }\n    }\n  });\n});\nvar Overlay = Widget.inherit({\n  _supportedKeys: function _supportedKeys() {\n    var offsetSize = 5,\n      move = function move(top, left, e) {\n        if (!this.option(\"dragEnabled\")) {\n          return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        var allowedOffsets = this._allowedOffsets();\n        var offset = {\n          top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),\n          left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)\n        };\n        this._changePosition(offset);\n      };\n    return extend(this.callBase(), {\n      escape: function escape() {\n        this.hide();\n      },\n      upArrow: move.bind(this, -offsetSize, 0),\n      downArrow: move.bind(this, offsetSize, 0),\n      leftArrow: move.bind(this, 0, -offsetSize),\n      rightArrow: move.bind(this, 0, offsetSize)\n    });\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      activeStateEnabled: false,\n      visible: false,\n      deferRendering: true,\n      shading: true,\n      shadingColor: \"\",\n      position: {\n        my: \"center\",\n        at: \"center\"\n      },\n      width: function width() {\n        return .8 * $(window).width();\n      },\n      minWidth: null,\n      maxWidth: null,\n      height: function height() {\n        return .8 * $(window).height();\n      },\n      minHeight: null,\n      maxHeight: null,\n      animation: {\n        show: {\n          type: \"pop\",\n          duration: 300,\n          from: {\n            scale: .55\n          }\n        },\n        hide: {\n          type: \"pop\",\n          duration: 300,\n          to: {\n            opacity: 0,\n            scale: .55\n          },\n          from: {\n            opacity: 1,\n            scale: 1\n          }\n        }\n      },\n      closeOnOutsideClick: false,\n      closeOnBackButton: true,\n      onShowing: null,\n      onShown: null,\n      onHiding: null,\n      onHidden: null,\n      contentTemplate: \"content\",\n      dragEnabled: false,\n      resizeEnabled: false,\n      onResizeStart: null,\n      onResize: null,\n      onResizeEnd: null,\n      innerOverlay: false,\n      target: void 0,\n      container: void 0,\n      hideTopOverlayHandler: void 0,\n      closeOnTargetScroll: false,\n      onPositioned: null,\n      boundaryOffset: {\n        h: 0,\n        v: 0\n      },\n      propagateOutsideClick: false,\n      ignoreChildEvents: true,\n      _checkParentVisibility: true\n    });\n  },\n  _defaultOptionsRules: function _defaultOptionsRules() {\n    return this.callBase().concat([{\n      device: function device() {\n        var realDevice = devices.real(),\n          realPlatform = realDevice.platform,\n          realVersion = realDevice.version;\n        return \"android\" === realPlatform && compareVersions(realVersion, [4, 2]) < 0;\n      },\n      options: {\n        animation: {\n          show: {\n            type: \"fade\",\n            duration: 400\n          },\n          hide: {\n            type: \"fade\",\n            duration: 400,\n            to: {\n              opacity: 0\n            },\n            from: {\n              opacity: 1\n            }\n          }\n        }\n      }\n    }, {\n      device: function device() {\n        return !windowUtils.hasWindow();\n      },\n      options: {\n        width: null,\n        height: null,\n        animation: null,\n        _checkParentVisibility: false\n      }\n    }]);\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase();\n    extend(this._optionsByReference, {\n      animation: true\n    });\n  },\n  _getAnonymousTemplateName: function _getAnonymousTemplateName() {\n    return ANONYMOUS_TEMPLATE_NAME;\n  },\n  _wrapper: function _wrapper() {\n    return this._$wrapper;\n  },\n  _container: function _container() {\n    return this._$content;\n  },\n  _eventBindingTarget: function _eventBindingTarget() {\n    return this._$content;\n  },\n  _init: function _init() {\n    this.callBase();\n    this._initActions();\n    this._initCloseOnOutsideClickHandler();\n    this._initTabTerminatorHandler();\n    this._$wrapper = $(\"<div>\").addClass(OVERLAY_WRAPPER_CLASS);\n    this._$content = $(\"<div>\").addClass(OVERLAY_CONTENT_CLASS);\n    this._initInnerOverlayClass();\n    var $element = this.$element();\n    this._$wrapper.addClass($element.attr(\"class\"));\n    $element.addClass(OVERLAY_CLASS);\n    this._$wrapper.attr(\"data-bind\", \"dxControlsDescendantBindings: true\");\n    eventsEngine.on(this._$wrapper, \"MSPointerDown\", noop);\n    eventsEngine.on(this._$wrapper, \"focusin\", function (e) {\n      e.stopPropagation();\n    });\n    this._toggleViewPortSubscription(true);\n  },\n  _initOptions: function _initOptions(options) {\n    this._initTarget(options.target);\n    var container = void 0 === options.container ? this.option(\"container\") : options.container;\n    this._initContainer(container);\n    this._initHideTopOverlayHandler(options.hideTopOverlayHandler);\n    this.callBase(options);\n  },\n  _initInnerOverlayClass: function _initInnerOverlayClass() {\n    this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option(\"innerOverlay\"));\n  },\n  _initTarget: function _initTarget(target) {\n    if (!typeUtils.isDefined(target)) {\n      return;\n    }\n    var options = this.option();\n    each([\"position.of\", \"animation.show.from.position.of\", \"animation.show.to.position.of\", \"animation.hide.from.position.of\", \"animation.hide.to.position.of\"], function (_, path) {\n      var pathParts = path.split(\".\");\n      var option = options;\n      while (option) {\n        if (1 === pathParts.length) {\n          if (typeUtils.isPlainObject(option)) {\n            option[pathParts.shift()] = target;\n          }\n          break;\n        } else {\n          option = option[pathParts.shift()];\n        }\n      }\n    });\n  },\n  _initContainer: function _initContainer(container) {\n    container = void 0 === container ? viewPortUtils.value() : container;\n    var $element = this.$element();\n    var $container = $element.closest(container);\n    if (!$container.length) {\n      $container = $(container).first();\n    }\n    this._$container = $container.length ? $container : $element.parent();\n  },\n  _initHideTopOverlayHandler: function _initHideTopOverlayHandler(handler) {\n    this._hideTopOverlayHandler = void 0 !== handler ? handler : this._defaultHideTopOverlayHandler.bind(this);\n  },\n  _defaultHideTopOverlayHandler: function _defaultHideTopOverlayHandler() {\n    this.hide();\n  },\n  _initActions: function _initActions() {\n    this._actions = {};\n    each(ACTIONS, function (_, action) {\n      this._actions[action] = this._createActionByOption(action, {\n        excludeValidators: [\"disabled\", \"readOnly\"]\n      }) || noop;\n    }.bind(this));\n  },\n  _initCloseOnOutsideClickHandler: function _initCloseOnOutsideClickHandler() {\n    var that = this;\n    this._proxiedDocumentDownHandler = function () {\n      return that._documentDownHandler.apply(that, arguments);\n    };\n  },\n  _documentDownHandler: function _documentDownHandler(e) {\n    if (this._showAnimationProcessing) {\n      this._stopAnimation();\n    }\n    var closeOnOutsideClick = this.option(\"closeOnOutsideClick\");\n    if (typeUtils.isFunction(closeOnOutsideClick)) {\n      closeOnOutsideClick = closeOnOutsideClick(e);\n    }\n    var $container = this._$content,\n      isAttachedTarget = $(window.document).is(e.target) || domUtils.contains(window.document, e.target),\n      isInnerOverlay = $(e.target).closest(\".\" + INNER_OVERLAY_CLASS).length,\n      outsideClick = isAttachedTarget && !isInnerOverlay && !($container.is(e.target) || domUtils.contains($container.get(0), e.target));\n    if (outsideClick && closeOnOutsideClick) {\n      if (this.option(\"shading\")) {\n        e.preventDefault();\n      }\n      this.hide();\n    }\n    return this.option(\"propagateOutsideClick\");\n  },\n  _initTemplates: function _initTemplates() {\n    this.callBase();\n    this._defaultTemplates.content = new EmptyTemplate();\n  },\n  _isTopOverlay: function _isTopOverlay() {\n    var overlayStack = this._overlayStack();\n    for (var i = overlayStack.length - 1; i >= 0; i--) {\n      var tabbableElements = overlayStack[i]._findTabbableBounds();\n      if (tabbableElements.first || tabbableElements.last) {\n        return overlayStack[i] === this;\n      }\n    }\n    return false;\n  },\n  _overlayStack: function _overlayStack() {\n    return OVERLAY_STACK;\n  },\n  _zIndexInitValue: function _zIndexInitValue() {\n    return Overlay.baseZIndex();\n  },\n  _toggleViewPortSubscription: function _toggleViewPortSubscription(toggle) {\n    viewPortChanged.remove(this._viewPortChangeHandle);\n    if (toggle) {\n      this._viewPortChangeHandle = this._viewPortChangeHandler.bind(this);\n      viewPortChanged.add(this._viewPortChangeHandle);\n    }\n  },\n  _viewPortChangeHandler: function _viewPortChangeHandler() {\n    this._initContainer(this.option(\"container\"));\n    this._refresh();\n  },\n  _renderVisibilityAnimate: function _renderVisibilityAnimate(visible) {\n    this._stopAnimation();\n    return visible ? this._show() : this._hide();\n  },\n  _normalizePosition: function _normalizePosition() {\n    var position = this.option(\"position\");\n    this._position = \"function\" === typeof position ? position() : position;\n  },\n  _getAnimationConfig: function _getAnimationConfig() {\n    var animation = this.option(\"animation\");\n    if (typeUtils.isFunction(animation)) {\n      animation = animation.call(this);\n    }\n    return animation;\n  },\n  _show: function _show() {\n    var that = this,\n      deferred = new Deferred();\n    this._parentHidden = this._isParentHidden();\n    deferred.done(function () {\n      delete that._parentHidden;\n    });\n    if (this._parentHidden) {\n      this._isHidden = true;\n      return deferred.resolve();\n    }\n    if (this._currentVisible) {\n      return new Deferred().resolve().promise();\n    }\n    this._currentVisible = true;\n    this._normalizePosition();\n    var animation = that._getAnimationConfig() || {},\n      showAnimation = this._normalizeAnimation(animation.show, \"to\"),\n      startShowAnimation = showAnimation && showAnimation.start || noop,\n      completeShowAnimation = showAnimation && showAnimation.complete || noop;\n    if (this._isHidingActionCanceled) {\n      delete this._isHidingActionCanceled;\n      deferred.resolve();\n    } else {\n      var show = function () {\n        this._renderVisibility(true);\n        this._animate(showAnimation, function () {\n          if (that.option(\"focusStateEnabled\")) {\n            eventsEngine.trigger(that._focusTarget(), \"focus\");\n          }\n          completeShowAnimation.apply(this, arguments);\n          that._showAnimationProcessing = false;\n          that._actions.onShown();\n          that._toggleSafariScrolling(false);\n          deferred.resolve();\n        }, function () {\n          startShowAnimation.apply(this, arguments);\n          that._showAnimationProcessing = true;\n        });\n      }.bind(this);\n      if (this.option(\"templatesRenderAsynchronously\")) {\n        this._stopShowTimer();\n        this._asyncShowTimeout = setTimeout(show);\n      } else {\n        show();\n      }\n    }\n    return deferred.promise();\n  },\n  _normalizeAnimation: function _normalizeAnimation(animation, prop) {\n    if (animation) {\n      animation = extend({\n        type: \"slide\"\n      }, animation);\n      if (animation[prop] && \"object\" === _typeof(animation[prop])) {\n        extend(animation[prop], {\n          position: this._position\n        });\n      }\n    }\n    return animation;\n  },\n  _hide: function _hide() {\n    if (!this._currentVisible) {\n      return new Deferred().resolve().promise();\n    }\n    this._currentVisible = false;\n    var that = this,\n      deferred = new Deferred(),\n      animation = that._getAnimationConfig() || {},\n      hideAnimation = this._normalizeAnimation(animation.hide, \"from\"),\n      startHideAnimation = hideAnimation && hideAnimation.start || noop,\n      completeHideAnimation = hideAnimation && hideAnimation.complete || noop,\n      hidingArgs = {\n        cancel: false\n      };\n    this._actions.onHiding(hidingArgs);\n    that._toggleSafariScrolling(true);\n    if (hidingArgs.cancel) {\n      this._isHidingActionCanceled = true;\n      this.option(\"visible\", true);\n      deferred.resolve();\n    } else {\n      this._forceFocusLost();\n      this._toggleShading(false);\n      this._toggleSubscriptions(false);\n      this._stopShowTimer();\n      this._animate(hideAnimation, function () {\n        that._$content.css(\"pointerEvents\", \"\");\n        that._renderVisibility(false);\n        completeHideAnimation.apply(this, arguments);\n        that._actions.onHidden();\n        deferred.resolve();\n      }, function () {\n        that._$content.css(\"pointerEvents\", \"none\");\n        startHideAnimation.apply(this, arguments);\n      });\n    }\n    return deferred.promise();\n  },\n  _forceFocusLost: function _forceFocusLost() {\n    var activeElement = domAdapter.getActiveElement();\n    var shouldResetActiveElement = !!this._$content.find(activeElement).length;\n    if (shouldResetActiveElement) {\n      domUtils.resetActiveElement();\n    }\n  },\n  _animate: function _animate(animation, completeCallback, startCallback) {\n    if (animation) {\n      startCallback = startCallback || animation.start || noop;\n      fx.animate(this._$content, extend({}, animation, {\n        start: startCallback,\n        complete: completeCallback\n      }));\n    } else {\n      completeCallback();\n    }\n  },\n  _stopAnimation: function _stopAnimation() {\n    fx.stop(this._$content, true);\n  },\n  _renderVisibility: function _renderVisibility(visible) {\n    if (visible && this._isParentHidden()) {\n      return;\n    }\n    this._currentVisible = visible;\n    this._stopAnimation();\n    if (!visible) {\n      domUtils.triggerHidingEvent(this._$content);\n    }\n    this._toggleVisibility(visible);\n    this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);\n    this._updateZIndexStackPosition(visible);\n    if (visible) {\n      this._renderContent();\n      this._actions.onShowing();\n      this._moveToContainer();\n      this._renderGeometry();\n      domUtils.triggerShownEvent(this._$content);\n      domUtils.triggerResizeEvent(this._$content);\n    } else {\n      this._moveFromContainer();\n    }\n    this._toggleShading(visible);\n    this._toggleSubscriptions(visible);\n  },\n  _updateZIndexStackPosition: function _updateZIndexStackPosition(pushToStack) {\n    var overlayStack = this._overlayStack(),\n      index = inArray(this, overlayStack);\n    if (pushToStack) {\n      if (index === -1) {\n        this._zIndex = zIndexPool.create(this._zIndexInitValue());\n        overlayStack.push(this);\n      }\n      this._$wrapper.css(\"zIndex\", this._zIndex);\n      this._$content.css(\"zIndex\", this._zIndex);\n    } else {\n      if (index !== -1) {\n        overlayStack.splice(index, 1);\n        zIndexPool.remove(this._zIndex);\n      }\n    }\n  },\n  _toggleShading: function _toggleShading(visible) {\n    this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option(\"shading\") && !this.option(\"container\"));\n    this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option(\"shading\"));\n    this._$wrapper.css(\"backgroundColor\", this.option(\"shading\") ? this.option(\"shadingColor\") : \"\");\n    this._toggleTabTerminator(visible && this.option(\"shading\"));\n  },\n  _initTabTerminatorHandler: function _initTabTerminatorHandler() {\n    var that = this;\n    this._proxiedTabTerminatorHandler = function () {\n      that._tabKeyHandler.apply(that, arguments);\n    };\n  },\n  _toggleTabTerminator: function _toggleTabTerminator(enabled) {\n    var eventName = eventUtils.addNamespace(\"keydown\", this.NAME);\n    if (enabled) {\n      eventsEngine.on(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler);\n    } else {\n      eventsEngine.off(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler);\n    }\n  },\n  _findTabbableBounds: function _findTabbableBounds() {\n    var $elements = this._$wrapper.find(\"*\");\n    var elementsCount = $elements.length - 1;\n    var result = {\n      first: null,\n      last: null\n    };\n    for (var i = 0; i <= elementsCount; i++) {\n      if (!result.first && $elements.eq(i).is(selectors.tabbable)) {\n        result.first = $elements.eq(i);\n      }\n      if (!result.last && $elements.eq(elementsCount - i).is(selectors.tabbable)) {\n        result.last = $elements.eq(elementsCount - i);\n      }\n      if (result.first && result.last) {\n        break;\n      }\n    }\n    return result;\n  },\n  _tabKeyHandler: function _tabKeyHandler(e) {\n    if (eventUtils.normalizeKeyName(e) !== TAB_KEY || !this._isTopOverlay()) {\n      return;\n    }\n    var tabbableElements = this._findTabbableBounds(),\n      $firstTabbable = tabbableElements.first,\n      $lastTabbable = tabbableElements.last,\n      isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0),\n      isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0),\n      isEmptyTabList = 0 === tabbableElements.length,\n      isOutsideTarget = !domUtils.contains(this._$wrapper.get(0), e.target);\n    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {\n      e.preventDefault();\n      var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;\n      eventsEngine.trigger($focusElement, \"focusin\");\n      eventsEngine.trigger($focusElement, \"focus\");\n    }\n  },\n  _toggleSubscriptions: function _toggleSubscriptions(enabled) {\n    if (windowUtils.hasWindow()) {\n      this._toggleHideTopOverlayCallback(enabled);\n      this._toggleParentsScrollSubscription(enabled);\n    }\n  },\n  _toggleHideTopOverlayCallback: function _toggleHideTopOverlayCallback(subscribe) {\n    if (!this._hideTopOverlayHandler) {\n      return;\n    }\n    if (subscribe && this.option(\"closeOnBackButton\")) {\n      hideTopOverlayCallback.add(this._hideTopOverlayHandler);\n    } else {\n      hideTopOverlayCallback.remove(this._hideTopOverlayHandler);\n    }\n  },\n  _toggleParentsScrollSubscription: function _toggleParentsScrollSubscription(subscribe) {\n    if (!this._position) {\n      return;\n    }\n    var target = this._position.of || $(),\n      closeOnScroll = this.option(\"closeOnTargetScroll\"),\n      $parents = getElement(target).parents(),\n      scrollEvent = eventUtils.addNamespace(\"scroll\", this.NAME);\n    if (\"desktop\" === devices.real().deviceType) {\n      $parents = $parents.add(window);\n    }\n    this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function (e) {\n      this._targetParentsScrollHandler(e);\n    }.bind(this);\n    eventsEngine.off($().add(this._$prevTargetParents), scrollEvent, this._proxiedTargetParentsScrollHandler);\n    if (subscribe && closeOnScroll) {\n      eventsEngine.on($parents, scrollEvent, this._proxiedTargetParentsScrollHandler);\n      this._$prevTargetParents = $parents;\n    }\n  },\n  _targetParentsScrollHandler: function _targetParentsScrollHandler(e) {\n    var closeHandled = false,\n      closeOnScroll = this.option(\"closeOnTargetScroll\");\n    if (typeUtils.isFunction(closeOnScroll)) {\n      closeHandled = closeOnScroll(e);\n    }\n    if (!closeHandled && !this._showAnimationProcessing) {\n      this.hide();\n    }\n  },\n  _render: function _render() {\n    this.callBase();\n    this._appendContentToElement();\n    this._renderVisibilityAnimate(this.option(\"visible\"));\n  },\n  _appendContentToElement: function _appendContentToElement() {\n    if (!this._$content.parent().is(this.$element())) {\n      this._$content.appendTo(this.$element());\n    }\n  },\n  _renderContent: function _renderContent() {\n    var shouldDeferRendering = !this._currentVisible && this.option(\"deferRendering\");\n    var isParentHidden = this.option(\"visible\") && this._isParentHidden();\n    if (isParentHidden) {\n      this._isHidden = true;\n      return;\n    }\n    if (this._contentAlreadyRendered || shouldDeferRendering) {\n      return;\n    }\n    this._contentAlreadyRendered = true;\n    this._appendContentToElement();\n    this.callBase();\n  },\n  _isParentHidden: function _isParentHidden() {\n    if (!this.option(\"_checkParentVisibility\")) {\n      return false;\n    }\n    if (void 0 !== this._parentHidden) {\n      return this._parentHidden;\n    }\n    var $parent = this.$element().parent();\n    if ($parent.is(\":visible\")) {\n      return false;\n    }\n    var isHidden = false;\n    $parent.add($parent.parents()).each(function () {\n      var $element = $(this);\n      if (\"none\" === $element.css(\"display\")) {\n        isHidden = true;\n        return false;\n      }\n    });\n    return isHidden || !domAdapter.getBody().contains($parent.get(0));\n  },\n  _renderContentImpl: function _renderContentImpl() {\n    var _this = this;\n    var whenContentRendered = new Deferred();\n    var contentTemplateOption = this.option(\"contentTemplate\"),\n      contentTemplate = this._getTemplate(contentTemplateOption),\n      transclude = this._getAnonymousTemplateName() === contentTemplateOption;\n    contentTemplate && contentTemplate.render({\n      container: getPublicElement(this.$content()),\n      noModel: true,\n      transclude: transclude,\n      onRendered: function onRendered() {\n        whenContentRendered.resolve();\n      }\n    });\n    this._renderDrag();\n    this._renderResize();\n    this._renderScrollTerminator();\n    whenContentRendered.done(function () {\n      if (_this.option(\"visible\")) {\n        _this._moveToContainer();\n      }\n    });\n    return whenContentRendered.promise();\n  },\n  _renderDrag: function _renderDrag() {\n    var $dragTarget = this._getDragTarget();\n    if (!$dragTarget) {\n      return;\n    }\n    var startEventName = eventUtils.addNamespace(dragEvents.start, this.NAME),\n      updateEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);\n    eventsEngine.off($dragTarget, startEventName);\n    eventsEngine.off($dragTarget, updateEventName);\n    if (!this.option(\"dragEnabled\")) {\n      return;\n    }\n    eventsEngine.on($dragTarget, startEventName, this._dragStartHandler.bind(this));\n    eventsEngine.on($dragTarget, updateEventName, this._dragUpdateHandler.bind(this));\n  },\n  _renderResize: function _renderResize() {\n    this._resizable = this._createComponent(this._$content, Resizable, {\n      handles: this.option(\"resizeEnabled\") ? \"all\" : \"none\",\n      onResizeEnd: this._resizeEndHandler.bind(this),\n      onResize: this._actions.onResize.bind(this),\n      onResizeStart: this._actions.onResizeStart.bind(this),\n      minHeight: 100,\n      minWidth: 100,\n      area: this._getDragResizeContainer()\n    });\n  },\n  _resizeEndHandler: function _resizeEndHandler() {\n    this._positionChangeHandled = true;\n    var width = this._resizable.option(\"width\"),\n      height = this._resizable.option(\"height\");\n    width && this.option(\"width\", width);\n    height && this.option(\"height\", height);\n    this._actions.onResizeEnd();\n  },\n  _renderScrollTerminator: function _renderScrollTerminator() {\n    var $scrollTerminator = this._wrapper();\n    var terminatorEventName = eventUtils.addNamespace(dragEvents.move, this.NAME);\n    eventsEngine.off($scrollTerminator, terminatorEventName);\n    eventsEngine.on($scrollTerminator, terminatorEventName, {\n      validate: function validate() {\n        return true;\n      },\n      getDirection: function getDirection() {\n        return \"both\";\n      },\n      _toggleGestureCover: noop,\n      _clearSelection: noop,\n      isNative: true\n    }, function (e) {\n      var originalEvent = e.originalEvent.originalEvent;\n      e._cancelPreventDefault = true;\n      if (originalEvent && \"mousemove\" !== originalEvent.type) {\n        e.preventDefault();\n      }\n    });\n  },\n  _getDragTarget: function _getDragTarget() {\n    return this.$content();\n  },\n  _dragStartHandler: function _dragStartHandler(e) {\n    e.targetElements = [];\n    this._prevOffset = {\n      x: 0,\n      y: 0\n    };\n    var allowedOffsets = this._allowedOffsets();\n    e.maxTopOffset = allowedOffsets.top;\n    e.maxBottomOffset = allowedOffsets.bottom;\n    e.maxLeftOffset = allowedOffsets.left;\n    e.maxRightOffset = allowedOffsets.right;\n  },\n  _getDragResizeContainer: function _getDragResizeContainer() {\n    var isContainerDefined = viewPortUtils.originalViewPort().get(0) || this.option(\"container\"),\n      $container = !isContainerDefined ? $(window) : this._$container;\n    return $container;\n  },\n  _deltaSize: function _deltaSize() {\n    var $content = this._$content,\n      $container = this._getDragResizeContainer();\n    var contentWidth = $content.outerWidth(),\n      contentHeight = $content.outerHeight(),\n      containerWidth = $container.outerWidth(),\n      containerHeight = $container.outerHeight();\n    if (this._isWindow($container)) {\n      var document = domAdapter.getDocument(),\n        fullPageHeight = Math.max($(document).outerHeight(), containerHeight),\n        fullPageWidth = Math.max($(document).outerWidth(), containerWidth);\n      containerHeight = fullPageHeight;\n      containerWidth = fullPageWidth;\n    }\n    return {\n      width: containerWidth - contentWidth,\n      height: containerHeight - contentHeight\n    };\n  },\n  _dragUpdateHandler: function _dragUpdateHandler(e) {\n    var offset = e.offset,\n      prevOffset = this._prevOffset,\n      targetOffset = {\n        top: offset.y - prevOffset.y,\n        left: offset.x - prevOffset.x\n      };\n    this._changePosition(targetOffset);\n    this._prevOffset = offset;\n  },\n  _changePosition: function _changePosition(offset) {\n    var position = translator.locate(this._$content);\n    translator.move(this._$content, {\n      left: position.left + offset.left,\n      top: position.top + offset.top\n    });\n    this._positionChangeHandled = true;\n  },\n  _allowedOffsets: function _allowedOffsets() {\n    var position = translator.locate(this._$content),\n      deltaSize = this._deltaSize(),\n      isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0,\n      shaderOffset = this.option(\"shading\") && !this.option(\"container\") && !this._isWindow(this._getContainer()) ? translator.locate(this._$wrapper) : {\n        top: 0,\n        left: 0\n      },\n      boundaryOffset = this.option(\"boundaryOffset\");\n    return {\n      top: isAllowedDrag ? position.top + shaderOffset.top + boundaryOffset.v : 0,\n      bottom: isAllowedDrag ? -position.top - shaderOffset.top + deltaSize.height - boundaryOffset.v : 0,\n      left: isAllowedDrag ? position.left + shaderOffset.left + boundaryOffset.h : 0,\n      right: isAllowedDrag ? -position.left - shaderOffset.left + deltaSize.width - boundaryOffset.h : 0\n    };\n  },\n  _moveFromContainer: function _moveFromContainer() {\n    this._$content.appendTo(this.$element());\n    this._detachWrapperToContainer();\n  },\n  _detachWrapperToContainer: function _detachWrapperToContainer() {\n    this._$wrapper.detach();\n  },\n  _moveToContainer: function _moveToContainer() {\n    this._attachWrapperToContainer();\n    this._$content.appendTo(this._$wrapper);\n  },\n  _attachWrapperToContainer: function _attachWrapperToContainer() {\n    var $element = this.$element();\n    var containerDefined = void 0 !== this.option(\"container\");\n    var renderContainer = containerDefined ? this._$container : swatch.getSwatchContainer($element);\n    if (renderContainer && renderContainer[0] === $element.parent()[0]) {\n      renderContainer = $element;\n    }\n    this._$wrapper.appendTo(renderContainer);\n  },\n  _fixHeightAfterSafariAddressBarResizing: function _fixHeightAfterSafariAddressBarResizing() {\n    if (this._isWindow(this._getContainer()) && hasSafariAddressBar) {\n      this._$wrapper.css(\"minHeight\", window.innerHeight);\n    }\n  },\n  _renderGeometry: function _renderGeometry(isDimensionChanged) {\n    if (this.option(\"visible\") && windowUtils.hasWindow()) {\n      this._renderGeometryImpl(isDimensionChanged);\n    }\n  },\n  _renderGeometryImpl: function _renderGeometryImpl(isDimensionChanged) {\n    this._stopAnimation();\n    this._normalizePosition();\n    this._renderShading();\n    this._fixHeightAfterSafariAddressBarResizing();\n    this._renderDimensions();\n    var resultPosition = this._renderPosition();\n    this._actions.onPositioned({\n      position: resultPosition\n    });\n  },\n  _fixWrapperPosition: function _fixWrapperPosition() {\n    this._$wrapper.css(\"position\", this._useFixedPosition() ? \"fixed\" : \"absolute\");\n  },\n  _useFixedPosition: function _useFixedPosition() {\n    var $container = this._getContainer();\n    return this._isWindow($container) && (!iOS || void 0 !== this._bodyScrollTop);\n  },\n  _toggleSafariScrolling: function _toggleSafariScrolling(scrollingEnabled) {\n    if (iOS && this._useFixedPosition()) {\n      var body = domAdapter.getBody();\n      if (scrollingEnabled) {\n        $(body).removeClass(PREVENT_SAFARI_SCROLLING_CLASS);\n        window.scrollTo(0, this._bodyScrollTop);\n        this._bodyScrollTop = void 0;\n      } else {\n        if (this.option(\"visible\")) {\n          this._bodyScrollTop = window.pageYOffset;\n          $(body).addClass(PREVENT_SAFARI_SCROLLING_CLASS);\n        }\n      }\n    }\n  },\n  _renderShading: function _renderShading() {\n    this._fixWrapperPosition();\n    this._renderShadingPosition();\n  },\n  _renderShadingPosition: function _renderShadingPosition() {\n    if (this.option(\"shading\")) {\n      var $container = this._getContainer();\n      positionUtils.setup(this._$wrapper, {\n        my: \"top left\",\n        at: \"top left\",\n        of: $container\n      });\n    }\n  },\n  _isWindow: function _isWindow($element) {\n    return !!$element && typeUtils.isWindow($element.get(0));\n  },\n  _getContainer: function _getContainer() {\n    var position = this._position,\n      container = this.option(\"container\"),\n      positionOf = null;\n    if (!container && position) {\n      var isEvent = !!(position.of && position.of.preventDefault);\n      positionOf = isEvent ? window : position.of || window;\n    }\n    return getElement(container || positionOf);\n  },\n  _renderDimensions: function _renderDimensions() {\n    var content = this._$content.get(0);\n    this._$content.css({\n      minWidth: this._getOptionValue(\"minWidth\", content),\n      maxWidth: this._getOptionValue(\"maxWidth\", content),\n      minHeight: this._getOptionValue(\"minHeight\", content),\n      maxHeight: this._getOptionValue(\"maxHeight\", content),\n      width: this._getOptionValue(\"width\", content),\n      height: this._getOptionValue(\"height\", content)\n    });\n  },\n  _renderPosition: function _renderPosition() {\n    if (this._positionChangeHandled) {\n      var allowedOffsets = this._allowedOffsets();\n      this._changePosition({\n        top: fitIntoRange(0, -allowedOffsets.top, allowedOffsets.bottom),\n        left: fitIntoRange(0, -allowedOffsets.left, allowedOffsets.right)\n      });\n    } else {\n      this._renderOverlayBoundaryOffset();\n      translator.resetPosition(this._$content);\n      var position = this._transformStringPosition(this._position, POSITION_ALIASES),\n        resultPosition = positionUtils.setup(this._$content, position);\n      forceRepaint(this._$content);\n      this._actions.onPositioning();\n      return resultPosition;\n    }\n  },\n  _transformStringPosition: function _transformStringPosition(position, positionAliases) {\n    if (typeUtils.isString(position)) {\n      position = extend({}, positionAliases[position]);\n    }\n    return position;\n  },\n  _renderOverlayBoundaryOffset: function _renderOverlayBoundaryOffset() {\n    var boundaryOffset = this.option(\"boundaryOffset\");\n    this._$content.css(\"margin\", boundaryOffset.v + \"px \" + boundaryOffset.h + \"px\");\n  },\n  _focusTarget: function _focusTarget() {\n    return this._$content;\n  },\n  _attachKeyboardEvents: function _attachKeyboardEvents() {\n    this._keyboardProcessor = new KeyboardProcessor({\n      element: this._$content,\n      handler: this._keyboardHandler,\n      context: this\n    });\n  },\n  _keyboardHandler: function _keyboardHandler(options) {\n    var e = options.originalEvent,\n      $target = $(e.target);\n    if ($target.is(this._$content) || !this.option(\"ignoreChildEvents\")) {\n      this.callBase.apply(this, arguments);\n    }\n  },\n  _isVisible: function _isVisible() {\n    return this.option(\"visible\");\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible) {\n      if (this.option(\"visible\")) {\n        this._renderVisibilityAnimate(visible);\n      }\n    } else {\n      this._renderVisibilityAnimate(visible);\n    }\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    this._renderGeometry(true);\n  },\n  _clean: function _clean() {\n    if (!this._contentAlreadyRendered) {\n      this.$content().empty();\n    }\n    this._renderVisibility(false);\n    this._stopShowTimer();\n    this._cleanFocusState();\n  },\n  _stopShowTimer: function _stopShowTimer() {\n    if (this._asyncShowTimeout) {\n      clearTimeout(this._asyncShowTimeout);\n    }\n    this._asyncShowTimeout = null;\n  },\n  _dispose: function _dispose() {\n    fx.stop(this._$content, false);\n    clearTimeout(this._deferShowTimer);\n    this._toggleViewPortSubscription(false);\n    this._toggleSubscriptions(false);\n    this._updateZIndexStackPosition(false);\n    this._toggleTabTerminator(false);\n    this._toggleSafariScrolling(true);\n    this._actions = null;\n    this.callBase();\n    zIndexPool.remove(this._zIndex);\n    this._$wrapper.remove();\n    this._$content.remove();\n  },\n  _toggleDisabledState: function _toggleDisabledState(value) {\n    this.callBase.apply(this, arguments);\n    this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value));\n  },\n  _toggleRTLDirection: function _toggleRTLDirection(rtl) {\n    this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl);\n  },\n  _optionChanged: function _optionChanged(args) {\n    var value = args.value;\n    if (inArray(args.name, ACTIONS) > -1) {\n      this._initActions();\n      return;\n    }\n    switch (args.name) {\n      case \"dragEnabled\":\n        this._renderDrag();\n        this._renderGeometry();\n        break;\n      case \"resizeEnabled\":\n        this._renderResize();\n        this._renderGeometry();\n        break;\n      case \"shading\":\n      case \"shadingColor\":\n        this._toggleShading(this.option(\"visible\"));\n        break;\n      case \"width\":\n      case \"height\":\n      case \"minWidth\":\n      case \"maxWidth\":\n      case \"minHeight\":\n      case \"maxHeight\":\n      case \"boundaryOffset\":\n        this._renderGeometry();\n        break;\n      case \"position\":\n        this._positionChangeHandled = false;\n        this._renderGeometry();\n        break;\n      case \"visible\":\n        this._renderVisibilityAnimate(value).done(function () {\n          if (!this._animateDeferred) {\n            return;\n          }\n          this._animateDeferred.resolveWith(this);\n        }.bind(this));\n        break;\n      case \"target\":\n        this._initTarget(value);\n        this._invalidate();\n        break;\n      case \"container\":\n        this._initContainer(value);\n        this._invalidate();\n        break;\n      case \"innerOverlay\":\n        this._initInnerOverlayClass();\n        break;\n      case \"deferRendering\":\n      case \"contentTemplate\":\n        this._contentAlreadyRendered = false;\n        this._clean();\n        this._invalidate();\n        break;\n      case \"closeOnBackButton\":\n        this._toggleHideTopOverlayCallback(this.option(\"visible\"));\n        break;\n      case \"closeOnTargetScroll\":\n        this._toggleParentsScrollSubscription(this.option(\"visible\"));\n        break;\n      case \"closeOnOutsideClick\":\n      case \"animation\":\n      case \"propagateOutsideClick\":\n        break;\n      case \"rtlEnabled\":\n        this._contentAlreadyRendered = false;\n        this.option(\"visible\", false);\n        this.callBase(args);\n        break;\n      default:\n        this.callBase(args);\n    }\n  },\n  toggle: function toggle(showing) {\n    showing = void 0 === showing ? !this.option(\"visible\") : showing;\n    var result = new Deferred();\n    if (showing === this.option(\"visible\")) {\n      return result.resolveWith(this, [showing]).promise();\n    }\n    var animateDeferred = new Deferred();\n    this._animateDeferred = animateDeferred;\n    this.option(\"visible\", showing);\n    animateDeferred.promise().done(function () {\n      delete this._animateDeferred;\n      result.resolveWith(this, [showing]);\n    }.bind(this));\n    return result.promise();\n  },\n  $content: function $content() {\n    return this._$content;\n  },\n  show: function show() {\n    return this.toggle(true);\n  },\n  hide: function hide() {\n    return this.toggle(false);\n  },\n  content: function content() {\n    return getPublicElement(this._$content);\n  },\n  repaint: function repaint() {\n    this._renderGeometry();\n    domUtils.triggerResizeEvent(this._$content);\n  }\n});\nOverlay.baseZIndex = function (zIndex) {\n  return zIndexPool.base(zIndex);\n};\nregisterComponent(\"dxOverlay\", Overlay);\nmodule.exports = Overlay;","map":null,"metadata":{},"sourceType":"script"}