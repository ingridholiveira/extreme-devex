{"ast":null,"code":"/**\r\n * DevExtreme (data/array_query.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar Class = require(\"../core/class\"),\n  typeUtils = require(\"../core/utils/type\"),\n  iteratorUtils = require(\"../core/utils/iterator\"),\n  compileGetter = require(\"../core/utils/data\").compileGetter,\n  toComparable = require(\"../core/utils/data\").toComparable,\n  Deferred = require(\"../core/utils/deferred\").Deferred,\n  errorsModule = require(\"./errors\"),\n  dataUtils = require(\"./utils\");\nvar Iterator = Class.inherit({\n  toArray: function toArray() {\n    var result = [];\n    this.reset();\n    while (this.next()) {\n      result.push(this.current());\n    }\n    return result;\n  },\n  countable: function countable() {\n    return false;\n  }\n});\nvar ArrayIterator = Iterator.inherit({\n  ctor: function ctor(array) {\n    this.array = array;\n    this.index = -1;\n  },\n  next: function next() {\n    if (this.index + 1 < this.array.length) {\n      this.index++;\n      return true;\n    }\n    return false;\n  },\n  current: function current() {\n    return this.array[this.index];\n  },\n  reset: function reset() {\n    this.index = -1;\n  },\n  toArray: function toArray() {\n    return this.array.slice(0);\n  },\n  countable: function countable() {\n    return true;\n  },\n  count: function count() {\n    return this.array.length;\n  }\n});\nvar WrappedIterator = Iterator.inherit({\n  ctor: function ctor(iter) {\n    this.iter = iter;\n  },\n  next: function next() {\n    return this.iter.next();\n  },\n  current: function current() {\n    return this.iter.current();\n  },\n  reset: function reset() {\n    return this.iter.reset();\n  }\n});\nvar MapIterator = WrappedIterator.inherit({\n  ctor: function ctor(iter, mapper) {\n    this.callBase(iter);\n    this.index = -1;\n    this.mapper = mapper;\n  },\n  current: function current() {\n    return this.mapper(this.callBase(), this.index);\n  },\n  next: function next() {\n    var hasNext = this.callBase();\n    if (hasNext) {\n      this.index++;\n    }\n    return hasNext;\n  }\n});\nvar defaultCompare = function defaultCompare(xValue, yValue) {\n  xValue = toComparable(xValue);\n  yValue = toComparable(yValue);\n  if (null === xValue && null !== yValue) {\n    return -1;\n  }\n  if (null !== xValue && null === yValue) {\n    return 1;\n  }\n  if (void 0 === xValue && void 0 !== yValue) {\n    return 1;\n  }\n  if (void 0 !== xValue && void 0 === yValue) {\n    return -1;\n  }\n  if (xValue < yValue) {\n    return -1;\n  }\n  if (xValue > yValue) {\n    return 1;\n  }\n  return 0;\n};\nvar SortIterator = Iterator.inherit({\n  ctor: function ctor(iter, getter, desc, compare) {\n    if (!(iter instanceof MapIterator)) {\n      iter = new MapIterator(iter, this._wrap);\n    }\n    this.iter = iter;\n    this.rules = [{\n      getter: getter,\n      desc: desc,\n      compare: compare\n    }];\n  },\n  thenBy: function thenBy(getter, desc, compare) {\n    var result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);\n    if (!this.sortedIter) {\n      result.rules = this.rules.concat(result.rules);\n    }\n    return result;\n  },\n  next: function next() {\n    this._ensureSorted();\n    return this.sortedIter.next();\n  },\n  current: function current() {\n    this._ensureSorted();\n    return this.sortedIter.current();\n  },\n  reset: function reset() {\n    delete this.sortedIter;\n  },\n  countable: function countable() {\n    return this.sortedIter || this.iter.countable();\n  },\n  count: function count() {\n    if (this.sortedIter) {\n      return this.sortedIter.count();\n    }\n    return this.iter.count();\n  },\n  _ensureSorted: function _ensureSorted() {\n    var that = this;\n    if (that.sortedIter) {\n      return;\n    }\n    iteratorUtils.each(that.rules, function () {\n      this.getter = compileGetter(this.getter);\n    });\n    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function (x, y) {\n      return that._compare(x, y);\n    })), that._unwrap);\n  },\n  _wrap: function _wrap(record, index) {\n    return {\n      index: index,\n      value: record\n    };\n  },\n  _unwrap: function _unwrap(wrappedItem) {\n    return wrappedItem.value;\n  },\n  _compare: function _compare(x, y) {\n    var xIndex = x.index,\n      yIndex = y.index;\n    x = x.value;\n    y = y.value;\n    if (x === y) {\n      return xIndex - yIndex;\n    }\n    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {\n      var rule = this.rules[i],\n        xValue = rule.getter(x),\n        yValue = rule.getter(y),\n        compare = rule.compare || defaultCompare,\n        compareResult = compare(xValue, yValue);\n      if (compareResult) {\n        return rule.desc ? -compareResult : compareResult;\n      }\n    }\n    return xIndex - yIndex;\n  }\n});\nvar compileCriteria = function () {\n  var compileGroup = function compileGroup(crit) {\n    var ops = [];\n    var isConjunctiveOperator = false;\n    var isConjunctiveNextOperator = false;\n    iteratorUtils.each(crit, function () {\n      if (Array.isArray(this) || typeUtils.isFunction(this)) {\n        if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {\n          throw new errorsModule.errors.Error(\"E4019\");\n        }\n        ops.push(compileCriteria(this));\n        isConjunctiveOperator = isConjunctiveNextOperator;\n        isConjunctiveNextOperator = true;\n      } else {\n        isConjunctiveNextOperator = dataUtils.isConjunctiveOperator(this);\n      }\n    });\n    return function (d) {\n      var result = isConjunctiveOperator;\n      for (var i = 0; i < ops.length; i++) {\n        if (ops[i](d) !== isConjunctiveOperator) {\n          result = !isConjunctiveOperator;\n          break;\n        }\n      }\n      return result;\n    };\n  };\n  var toString = function toString(value) {\n    return typeUtils.isDefined(value) ? value.toString() : \"\";\n  };\n  var compileBinary = function compileBinary(crit) {\n    crit = dataUtils.normalizeBinaryCriterion(crit);\n    var getter = compileGetter(crit[0]),\n      op = crit[1],\n      value = crit[2];\n    value = toComparable(value);\n    switch (op.toLowerCase()) {\n      case \"=\":\n        return compileEquals(getter, value);\n      case \"<>\":\n        return compileEquals(getter, value, true);\n      case \">\":\n        return function (obj) {\n          return toComparable(getter(obj)) > value;\n        };\n      case \"<\":\n        return function (obj) {\n          return toComparable(getter(obj)) < value;\n        };\n      case \">=\":\n        return function (obj) {\n          return toComparable(getter(obj)) >= value;\n        };\n      case \"<=\":\n        return function (obj) {\n          return toComparable(getter(obj)) <= value;\n        };\n      case \"startswith\":\n        return function (obj) {\n          return 0 === toComparable(toString(getter(obj))).indexOf(value);\n        };\n      case \"endswith\":\n        return function (obj) {\n          var getterValue = toComparable(toString(getter(obj))),\n            searchValue = toString(value);\n          if (getterValue.length < searchValue.length) {\n            return false;\n          }\n          return getterValue.lastIndexOf(value) === getterValue.length - value.length;\n        };\n      case \"contains\":\n        return function (obj) {\n          return toComparable(toString(getter(obj))).indexOf(value) > -1;\n        };\n      case \"notcontains\":\n        return function (obj) {\n          return toComparable(toString(getter(obj))).indexOf(value) === -1;\n        };\n    }\n    throw errorsModule.errors.Error(\"E4003\", op);\n  };\n  function compileEquals(getter, value, negate) {\n    return function (obj) {\n      obj = toComparable(getter(obj));\n      var result = useStrictComparison(value) ? obj === value : obj == value;\n      if (negate) {\n        result = !result;\n      }\n      return result;\n    };\n  }\n  function useStrictComparison(value) {\n    return \"\" === value || 0 === value || false === value;\n  }\n  function compileUnary(crit) {\n    var op = crit[0],\n      criteria = compileCriteria(crit[1]);\n    if (\"!\" === op) {\n      return function (obj) {\n        return !criteria(obj);\n      };\n    }\n    throw errorsModule.errors.Error(\"E4003\", op);\n  }\n  return function (crit) {\n    if (typeUtils.isFunction(crit)) {\n      return crit;\n    }\n    if (dataUtils.isGroupCriterion(crit)) {\n      return compileGroup(crit);\n    }\n    if (dataUtils.isUnaryOperation(crit)) {\n      return compileUnary(crit);\n    }\n    return compileBinary(crit);\n  };\n}();\nvar FilterIterator = WrappedIterator.inherit({\n  ctor: function ctor(iter, criteria) {\n    this.callBase(iter);\n    this.criteria = compileCriteria(criteria);\n  },\n  next: function next() {\n    while (this.iter.next()) {\n      if (this.criteria(this.current())) {\n        return true;\n      }\n    }\n    return false;\n  }\n});\nvar GroupIterator = Iterator.inherit({\n  ctor: function ctor(iter, getter) {\n    this.iter = iter;\n    this.getter = getter;\n  },\n  next: function next() {\n    this._ensureGrouped();\n    return this.groupedIter.next();\n  },\n  current: function current() {\n    this._ensureGrouped();\n    return this.groupedIter.current();\n  },\n  reset: function reset() {\n    delete this.groupedIter;\n  },\n  countable: function countable() {\n    return !!this.groupedIter;\n  },\n  count: function count() {\n    return this.groupedIter.count();\n  },\n  _ensureGrouped: function _ensureGrouped() {\n    if (this.groupedIter) {\n      return;\n    }\n    var hash = {},\n      keys = [],\n      iter = this.iter,\n      getter = compileGetter(this.getter);\n    iter.reset();\n    while (iter.next()) {\n      var current = iter.current(),\n        key = getter(current);\n      if (key in hash) {\n        hash[key].push(current);\n      } else {\n        hash[key] = [current];\n        keys.push(key);\n      }\n    }\n    this.groupedIter = new ArrayIterator(iteratorUtils.map(keys, function (key) {\n      return {\n        key: key,\n        items: hash[key]\n      };\n    }));\n  }\n});\nvar SelectIterator = WrappedIterator.inherit({\n  ctor: function ctor(iter, getter) {\n    this.callBase(iter);\n    this.getter = compileGetter(getter);\n  },\n  current: function current() {\n    return this.getter(this.callBase());\n  },\n  countable: function countable() {\n    return this.iter.countable();\n  },\n  count: function count() {\n    return this.iter.count();\n  }\n});\nvar SliceIterator = WrappedIterator.inherit({\n  ctor: function ctor(iter, skip, take) {\n    this.callBase(iter);\n    this.skip = Math.max(0, skip);\n    this.take = Math.max(0, take);\n    this.pos = 0;\n  },\n  next: function next() {\n    if (this.pos >= this.skip + this.take) {\n      return false;\n    }\n    while (this.pos < this.skip && this.iter.next()) {\n      this.pos++;\n    }\n    this.pos++;\n    return this.iter.next();\n  },\n  reset: function reset() {\n    this.callBase();\n    this.pos = 0;\n  },\n  countable: function countable() {\n    return this.iter.countable();\n  },\n  count: function count() {\n    return Math.min(this.iter.count() - this.skip, this.take);\n  }\n});\nvar arrayQueryImpl = function arrayQueryImpl(iter, queryOptions) {\n  queryOptions = queryOptions || {};\n  if (!(iter instanceof Iterator)) {\n    iter = new ArrayIterator(iter);\n  }\n  var handleError = function handleError(error) {\n    var handler = queryOptions.errorHandler;\n    if (handler) {\n      handler(error);\n    }\n    errorsModule._errorHandler(error);\n  };\n  var aggregateCore = function aggregateCore(aggregator) {\n    var seed,\n      d = new Deferred().fail(handleError),\n      step = aggregator.step,\n      finalize = aggregator.finalize;\n    try {\n      iter.reset();\n      if (\"seed\" in aggregator) {\n        seed = aggregator.seed;\n      } else {\n        seed = iter.next() ? iter.current() : NaN;\n      }\n      var accumulator = seed;\n      while (iter.next()) {\n        accumulator = step(accumulator, iter.current());\n      }\n      d.resolve(finalize ? finalize(accumulator) : accumulator);\n    } catch (x) {\n      d.reject(x);\n    }\n    return d.promise();\n  };\n  var aggregate = function aggregate(seed, step, finalize) {\n    if (arguments.length < 2) {\n      return aggregateCore({\n        step: arguments[0]\n      });\n    }\n    return aggregateCore({\n      seed: seed,\n      step: step,\n      finalize: finalize\n    });\n  };\n  var standardAggregate = function standardAggregate(name) {\n    return aggregateCore(dataUtils.aggregators[name]);\n  };\n  var select = function select(getter) {\n    if (!typeUtils.isFunction(getter) && !Array.isArray(getter)) {\n      getter = [].slice.call(arguments);\n    }\n    return chainQuery(new SelectIterator(iter, getter));\n  };\n  var selectProp = function selectProp(name) {\n    return select(compileGetter(name));\n  };\n  var chainQuery = function chainQuery(iter) {\n    return arrayQueryImpl(iter, queryOptions);\n  };\n  return {\n    toArray: function toArray() {\n      return iter.toArray();\n    },\n    enumerate: function enumerate() {\n      var d = new Deferred().fail(handleError);\n      try {\n        d.resolve(iter.toArray());\n      } catch (x) {\n        d.reject(x);\n      }\n      return d.promise();\n    },\n    sortBy: function sortBy(getter, desc, compare) {\n      return chainQuery(new SortIterator(iter, getter, desc, compare));\n    },\n    thenBy: function thenBy(getter, desc, compare) {\n      if (iter instanceof SortIterator) {\n        return chainQuery(iter.thenBy(getter, desc, compare));\n      }\n      throw errorsModule.errors.Error(\"E4004\");\n    },\n    filter: function filter(criteria) {\n      if (!Array.isArray(criteria)) {\n        criteria = [].slice.call(arguments);\n      }\n      return chainQuery(new FilterIterator(iter, criteria));\n    },\n    slice: function slice(skip, take) {\n      if (void 0 === take) {\n        take = Number.MAX_VALUE;\n      }\n      return chainQuery(new SliceIterator(iter, skip, take));\n    },\n    select: select,\n    groupBy: function groupBy(getter) {\n      return chainQuery(new GroupIterator(iter, getter));\n    },\n    aggregate: aggregate,\n    count: function count() {\n      if (iter.countable()) {\n        var d = new Deferred().fail(handleError);\n        try {\n          d.resolve(iter.count());\n        } catch (x) {\n          d.reject(x);\n        }\n        return d.promise();\n      }\n      return standardAggregate(\"count\");\n    },\n    sum: function sum(getter) {\n      if (getter) {\n        return selectProp(getter).sum();\n      }\n      return standardAggregate(\"sum\");\n    },\n    min: function min(getter) {\n      if (getter) {\n        return selectProp(getter).min();\n      }\n      return standardAggregate(\"min\");\n    },\n    max: function max(getter) {\n      if (getter) {\n        return selectProp(getter).max();\n      }\n      return standardAggregate(\"max\");\n    },\n    avg: function avg(getter) {\n      if (getter) {\n        return selectProp(getter).avg();\n      }\n      return standardAggregate(\"avg\");\n    }\n  };\n};\nmodule.exports = arrayQueryImpl;","map":null,"metadata":{},"sourceType":"script"}