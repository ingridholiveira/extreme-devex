{"ast":null,"code":"/**\r\n * DevExtreme (core/utils/data.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar errors = require(\"../errors\"),\n  Class = require(\"../class\"),\n  objectUtils = require(\"./object\"),\n  typeUtils = require(\"./type\"),\n  each = require(\"./iterator\").each,\n  variableWrapper = require(\"./variable_wrapper\"),\n  unwrapVariable = variableWrapper.unwrap,\n  isWrapped = variableWrapper.isWrapped,\n  assign = variableWrapper.assign;\nvar bracketsToDots = function bracketsToDots(expr) {\n  return expr.replace(/\\[/g, \".\").replace(/\\]/g, \"\");\n};\nvar readPropValue = function readPropValue(obj, propName, options) {\n  options = options || {};\n  if (\"this\" === propName) {\n    return unwrap(obj, options);\n  }\n  return unwrap(obj[propName], options);\n};\nvar assignPropValue = function assignPropValue(obj, propName, value, options) {\n  if (\"this\" === propName) {\n    throw new errors.Error(\"E4016\");\n  }\n  var propValue = obj[propName];\n  if (options.unwrapObservables && isWrapped(propValue)) {\n    assign(propValue, value);\n  } else {\n    obj[propName] = value;\n  }\n};\nvar prepareOptions = function prepareOptions(options) {\n  options = options || {};\n  options.unwrapObservables = void 0 !== options.unwrapObservables ? options.unwrapObservables : true;\n  return options;\n};\nvar unwrap = function unwrap(value, options) {\n  return options.unwrapObservables ? unwrapVariable(value) : value;\n};\nvar compileGetter = function compileGetter(expr) {\n  if (arguments.length > 1) {\n    expr = [].slice.call(arguments);\n  }\n  if (!expr || \"this\" === expr) {\n    return function (obj) {\n      return obj;\n    };\n  }\n  if (\"string\" === typeof expr) {\n    expr = bracketsToDots(expr);\n    var path = expr.split(\".\");\n    return function (obj, options) {\n      options = prepareOptions(options);\n      var functionAsIs = options.functionsAsIs,\n        hasDefaultValue = (\"defaultValue\" in options),\n        current = unwrap(obj, options);\n      for (var i = 0; i < path.length; i++) {\n        if (!current) {\n          if (null == current && hasDefaultValue) {\n            return options.defaultValue;\n          }\n          break;\n        }\n        var pathPart = path[i];\n        if (hasDefaultValue && typeUtils.isObject(current) && !(pathPart in current)) {\n          return options.defaultValue;\n        }\n        var next = unwrap(current[pathPart], options);\n        if (!functionAsIs && typeUtils.isFunction(next)) {\n          next = next.call(current);\n        }\n        current = next;\n      }\n      return current;\n    };\n  }\n  if (Array.isArray(expr)) {\n    return combineGetters(expr);\n  }\n  if (typeUtils.isFunction(expr)) {\n    return expr;\n  }\n};\nvar combineGetters = function combineGetters(getters) {\n  var compiledGetters = {};\n  for (var i = 0, l = getters.length; i < l; i++) {\n    var getter = getters[i];\n    compiledGetters[getter] = compileGetter(getter);\n  }\n  return function (obj, options) {\n    var result;\n    each(compiledGetters, function (name) {\n      var current,\n        path,\n        pathItem,\n        last,\n        i,\n        value = this(obj, options);\n      if (void 0 === value) {\n        return;\n      }\n      current = result || (result = {});\n      path = name.split(\".\");\n      last = path.length - 1;\n      for (i = 0; i < last; i++) {\n        pathItem = path[i];\n        if (!(pathItem in current)) {\n          current[pathItem] = {};\n        }\n        current = current[pathItem];\n      }\n      current[path[last]] = value;\n    });\n    return result;\n  };\n};\nvar ensurePropValueDefined = function ensurePropValueDefined(obj, propName, value, options) {\n  if (typeUtils.isDefined(value)) {\n    return value;\n  }\n  var newValue = {};\n  assignPropValue(obj, propName, newValue, options);\n  return newValue;\n};\nvar compileSetter = function compileSetter(expr) {\n  expr = bracketsToDots(expr || \"this\").split(\".\");\n  var lastLevelIndex = expr.length - 1;\n  return function (obj, value, options) {\n    options = prepareOptions(options);\n    var currentValue = unwrap(obj, options);\n    expr.forEach(function (propertyName, levelIndex) {\n      var propertyValue = readPropValue(currentValue, propertyName, options),\n        isPropertyFunc = !options.functionsAsIs && typeUtils.isFunction(propertyValue) && !isWrapped(propertyValue);\n      if (levelIndex === lastLevelIndex) {\n        if (options.merge && typeUtils.isPlainObject(value) && (!typeUtils.isDefined(propertyValue) || typeUtils.isPlainObject(propertyValue))) {\n          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);\n          objectUtils.deepExtendArraySafe(propertyValue, value, false, true);\n        } else {\n          if (isPropertyFunc) {\n            currentValue[propertyName](value);\n          } else {\n            assignPropValue(currentValue, propertyName, value, options);\n          }\n        }\n      } else {\n        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);\n        if (isPropertyFunc) {\n          propertyValue = propertyValue.call(currentValue);\n        }\n        currentValue = propertyValue;\n      }\n    });\n  };\n};\nvar toComparable = function toComparable(value, caseSensitive) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n  if (value && value instanceof Class && value.valueOf) {\n    return value.valueOf();\n  }\n  if (!caseSensitive && \"string\" === typeof value) {\n    return value.toLowerCase();\n  }\n  return value;\n};\nexports.compileGetter = compileGetter;\nexports.compileSetter = compileSetter;\nexports.toComparable = toComparable;","map":null,"metadata":{},"sourceType":"script"}