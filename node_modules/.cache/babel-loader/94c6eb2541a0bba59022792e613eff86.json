{"ast":null,"code":"/**\r\n * DevExtreme (localization/number.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = void 0;\n    try {\n      for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) {\n          break;\n        }\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i.return) {\n          _i.return();\n        }\n      } finally {\n        if (_d) {\n          throw _e;\n        }\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else {\n      if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    }\n  };\n}();\nvar _dependency_injector = require(\"../core/utils/dependency_injector\");\nvar _dependency_injector2 = _interopRequireDefault(_dependency_injector);\nvar _array = require(\"../core/utils/array\");\nvar _common = require(\"../core/utils/common\");\nvar _iterator = require(\"../core/utils/iterator\");\nvar _type = require(\"../core/utils/type\");\nvar _number = require(\"./ldml/number\");\nvar _number2 = _interopRequireDefault(_number);\nvar _config = require(\"../core/config\");\nvar _config2 = _interopRequireDefault(_config);\nvar _errors = require(\"../core/errors\");\nvar _errors2 = _interopRequireDefault(_errors);\nvar _utils = require(\"./utils\");\nvar _currency = require(\"./currency\");\nvar _currency2 = _interopRequireDefault(_currency);\nvar _number3 = require(\"./intl/number\");\nvar _number4 = _interopRequireDefault(_number3);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar hasIntl = \"undefined\" !== typeof Intl;\nvar MAX_LARGE_NUMBER_POWER = 4;\nvar DECIMAL_BASE = 10;\nvar NUMERIC_FORMATS = [\"currency\", \"fixedpoint\", \"exponential\", \"percent\", \"decimal\"];\nvar LargeNumberFormatPostfixes = {\n  1: \"K\",\n  2: \"M\",\n  3: \"B\",\n  4: \"T\"\n};\nvar LargeNumberFormatPowers = {\n  largenumber: \"auto\",\n  thousands: 1,\n  millions: 2,\n  billions: 3,\n  trillions: 4\n};\nvar numberLocalization = (0, _dependency_injector2.default)({\n  engine: function engine() {\n    return \"base\";\n  },\n  numericFormats: NUMERIC_FORMATS,\n  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,\n  _parseNumberFormatString: function _parseNumberFormatString(formatType) {\n    var formatList = void 0;\n    var formatObject = {};\n    if (!formatType || \"string\" !== typeof formatType) {\n      return;\n    }\n    formatList = formatType.toLowerCase().split(\" \");\n    (0, _iterator.each)(formatList, function (index, value) {\n      if ((0, _array.inArray)(value, NUMERIC_FORMATS) > -1) {\n        formatObject.formatType = value;\n      } else {\n        if (value in LargeNumberFormatPowers) {\n          formatObject.power = LargeNumberFormatPowers[value];\n        }\n      }\n    });\n    if (formatObject.power && !formatObject.formatType) {\n      formatObject.formatType = \"fixedpoint\";\n    }\n    if (formatObject.formatType) {\n      return formatObject;\n    }\n  },\n  _calculateNumberPower: function _calculateNumberPower(value, base, minPower, maxPower) {\n    var number = Math.abs(value);\n    var power = 0;\n    if (number > 1) {\n      while (number && number >= base && (void 0 === maxPower || power < maxPower)) {\n        power++;\n        number /= base;\n      }\n    } else {\n      if (number > 0 && number < 1) {\n        while (number < 1 && (void 0 === minPower || power > minPower)) {\n          power--;\n          number *= base;\n        }\n      }\n    }\n    return power;\n  },\n  _getNumberByPower: function _getNumberByPower(number, power, base) {\n    var result = number;\n    while (power > 0) {\n      result /= base;\n      power--;\n    }\n    while (power < 0) {\n      result *= base;\n      power++;\n    }\n    return result;\n  },\n  _formatNumber: function _formatNumber(value, formatObject, formatConfig) {\n    var powerPostfix = void 0;\n    var result = void 0;\n    if (\"auto\" === formatObject.power) {\n      formatObject.power = this._calculateNumberPower(value, 1e3, 0, MAX_LARGE_NUMBER_POWER);\n    }\n    if (formatObject.power) {\n      value = this._getNumberByPower(value, formatObject.power, 1e3);\n    }\n    powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || \"\";\n    result = this._formatNumberCore(value, formatObject.formatType, formatConfig);\n    result = result.replace(/(\\d|.$)(\\D*)$/, \"$1\" + powerPostfix + \"$2\");\n    return result;\n  },\n  _formatNumberExponential: function _formatNumberExponential(value, formatConfig) {\n    var power = this._calculateNumberPower(value, DECIMAL_BASE);\n    var number = this._getNumberByPower(value, power, DECIMAL_BASE);\n    var powString = void 0;\n    if (void 0 === formatConfig.precision) {\n      formatConfig.precision = 1;\n    }\n    if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {\n      power++;\n      number /= DECIMAL_BASE;\n    }\n    powString = (power >= 0 ? \"+\" : \"\") + power.toString();\n    return this._formatNumberCore(number, \"fixedpoint\", formatConfig) + \"E\" + powString;\n  },\n  _addZeroes: function _addZeroes(value, precision) {\n    var multiplier = Math.pow(10, precision);\n    var sign = value < 0 ? \"-\" : \"\";\n    value = (Math.abs(value) * multiplier >>> 0) / multiplier;\n    var result = value.toString();\n    while (result.length < precision) {\n      result = \"0\" + result;\n    }\n    return sign + result;\n  },\n  _addGroupSeparators: function _addGroupSeparators(value) {\n    var parts = value.toString().split(\".\");\n    return parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, (0, _config2.default)().thousandsSeparator) + (parts[1] ? (0, _config2.default)().decimalSeparator + parts[1] : \"\");\n  },\n  _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {\n    if (\"exponential\" === format) {\n      return this._formatNumberExponential(value, formatConfig);\n    }\n    if (\"decimal\" !== format && null !== formatConfig.precision) {\n      formatConfig.precision = formatConfig.precision || 0;\n    }\n    if (\"percent\" === format) {\n      value = 100 * value;\n    }\n    if (void 0 !== formatConfig.precision) {\n      if (\"decimal\" === format) {\n        value = this._addZeroes(value, formatConfig.precision);\n      } else {\n        value = null === formatConfig.precision ? value.toPrecision() : (0, _utils.toFixed)(value, formatConfig.precision);\n      }\n    }\n    if (\"decimal\" !== format) {\n      value = this._addGroupSeparators(value);\n    } else {\n      value = value.toString().replace(\".\", (0, _config2.default)().decimalSeparator);\n    }\n    if (\"percent\" === format) {\n      value += \"%\";\n    }\n    return value;\n  },\n  _normalizeFormat: function _normalizeFormat(format) {\n    if (!format) {\n      return {};\n    }\n    if (\"function\" === typeof format) {\n      return format;\n    }\n    if (!(0, _type.isPlainObject)(format)) {\n      format = {\n        type: format\n      };\n    }\n    return format;\n  },\n  _getSeparators: function _getSeparators() {\n    return {\n      decimalSeparator: this.getDecimalSeparator(),\n      thousandsSeparator: this.getThousandsSeparator()\n    };\n  },\n  getThousandsSeparator: function getThousandsSeparator() {\n    return this.format(1e4, \"fixedPoint\")[2];\n  },\n  getDecimalSeparator: function getDecimalSeparator() {\n    return this.format(1.2, {\n      type: \"fixedPoint\",\n      precision: 1\n    })[1];\n  },\n  convertDigits: function convertDigits(value, toStandard) {\n    var digits = this.format(90, \"decimal\");\n    if (\"string\" !== typeof value || \"0\" === digits[1]) {\n      return value;\n    }\n    var fromFirstDigit = toStandard ? digits[1] : \"0\";\n    var toFirstDigit = toStandard ? \"0\" : digits[1];\n    var fromLastDigit = toStandard ? digits[0] : \"9\";\n    var regExp = new RegExp(\"[\" + fromFirstDigit + \"-\" + fromLastDigit + \"]\", \"g\");\n    return value.replace(regExp, function (char) {\n      return String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0)));\n    });\n  },\n  getSign: function getSign(text, format) {\n    if (\"-\" === text.replace(/[^0-9-]/g, \"\").charAt(0)) {\n      return -1;\n    }\n    if (!format) {\n      return 1;\n    }\n    var separators = this._getSeparators();\n    var regExp = new RegExp(\"[0-9\" + (0, _common.escapeRegExp)(separators.decimalSeparator + separators.thousandsSeparator) + \"]+\", \"g\");\n    var negativeEtalon = this.format(-1, format).replace(regExp, \"1\");\n    var cleanedText = text.replace(regExp, \"1\");\n    return cleanedText === negativeEtalon ? -1 : 1;\n  },\n  format: function format(value, _format) {\n    if (\"number\" !== typeof value) {\n      return value;\n    }\n    if (\"number\" === typeof _format) {\n      return value;\n    }\n    _format = _format && _format.formatter || _format;\n    if (\"function\" === typeof _format) {\n      return _format(value);\n    }\n    _format = this._normalizeFormat(_format);\n    if (!_format.type) {\n      _format.type = \"decimal\";\n    }\n    var numberConfig = this._parseNumberFormatString(_format.type);\n    if (!numberConfig) {\n      return this.convertDigits(_number2.default.getFormatter(_format.type, this._getSeparators())(value));\n    }\n    return this._formatNumber(value, numberConfig, _format);\n  },\n  parse: function parse(text, format) {\n    if (!text) {\n      return;\n    }\n    if (format && format.parser) {\n      return format.parser(text);\n    }\n    text = this.convertDigits(text, true);\n    if (format && \"string\" !== typeof format) {\n      _errors2.default.log(\"W0011\");\n    }\n    var decimalSeparator = this.getDecimalSeparator();\n    var regExp = new RegExp(\"[^0-9\" + (0, _common.escapeRegExp)(decimalSeparator) + \"]\", \"g\");\n    var cleanedText = text.replace(regExp, \"\").replace(decimalSeparator, \".\").replace(/\\.$/g, \"\");\n    if (\".\" === cleanedText || \"\" === cleanedText) {\n      return null;\n    }\n    if (this._calcSignificantDigits(cleanedText) > 15) {\n      return NaN;\n    }\n    var parsed = +cleanedText;\n    return parsed * this.getSign(text, format);\n  },\n  _calcSignificantDigits: function _calcSignificantDigits(text) {\n    var _text$split = text.split(\".\"),\n      _text$split2 = _slicedToArray(_text$split, 2),\n      integer = _text$split2[0],\n      fractional = _text$split2[1];\n    var calcDigitsAfterLeadingZeros = function calcDigitsAfterLeadingZeros(digits) {\n      var index = -1;\n      for (var i = 0; i < digits.length; i++) {\n        if (\"0\" !== digits[i]) {\n          index = i;\n          break;\n        }\n      }\n      return index > -1 ? digits.length - index : 0;\n    };\n    var result = 0;\n    if (integer) {\n      result += calcDigitsAfterLeadingZeros(integer.split(\"\"));\n    }\n    if (fractional) {\n      result += calcDigitsAfterLeadingZeros(fractional.split(\"\").reverse());\n    }\n    return result;\n  }\n});\nnumberLocalization.inject(_currency2.default);\nif (hasIntl) {\n  numberLocalization.inject(_number4.default);\n}\nmodule.exports = numberLocalization;","map":null,"metadata":{},"sourceType":"script"}