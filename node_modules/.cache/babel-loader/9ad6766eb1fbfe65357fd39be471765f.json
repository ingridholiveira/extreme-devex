{"ast":null,"code":"/**\r\n * DevExtreme (core/utils/deferred.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar typeUtils = require(\"../utils/type\");\nvar isPromise = typeUtils.isPromise;\nvar isDeferred = typeUtils.isDeferred;\nvar extend = require(\"../utils/extend\").extend;\nvar Callbacks = require(\"../utils/callbacks\");\nvar deferredConfig = [{\n  method: \"resolve\",\n  handler: \"done\",\n  state: \"resolved\"\n}, {\n  method: \"reject\",\n  handler: \"fail\",\n  state: \"rejected\"\n}, {\n  method: \"notify\",\n  handler: \"progress\"\n}];\nvar _Deferred2 = function _Deferred() {\n  var that = this;\n  this._state = \"pending\";\n  this._promise = {};\n  deferredConfig.forEach(function (config) {\n    var methodName = config.method;\n    this[methodName + \"Callbacks\"] = new Callbacks();\n    this[methodName] = function () {\n      return this[methodName + \"With\"](this._promise, arguments);\n    }.bind(this);\n    this._promise[config.handler] = function (handler) {\n      if (!handler) {\n        return this;\n      }\n      var callbacks = that[methodName + \"Callbacks\"];\n      if (callbacks.fired()) {\n        handler.apply(that[methodName + \"Context\"], that[methodName + \"Args\"]);\n      } else {\n        callbacks.add(function (context, args) {\n          handler.apply(context, args);\n        }.bind(this));\n      }\n      return this;\n    };\n  }.bind(this));\n  this._promise.always = function (handler) {\n    return this.done(handler).fail(handler);\n  };\n  this._promise.catch = function (handler) {\n    return this.then(null, handler);\n  };\n  this._promise.then = function (resolve, reject) {\n    var result = new _Deferred2();\n    [\"done\", \"fail\"].forEach(function (method) {\n      var callback = \"done\" === method ? resolve : reject;\n      this[method](function () {\n        if (!callback) {\n          result[\"done\" === method ? \"resolve\" : \"reject\"].apply(this, arguments);\n          return;\n        }\n        var callbackResult = callback && callback.apply(this, arguments);\n        if (isDeferred(callbackResult)) {\n          callbackResult.done(result.resolve).fail(result.reject);\n        } else {\n          if (isPromise(callbackResult)) {\n            callbackResult.then(result.resolve, result.reject);\n          } else {\n            result.resolve.apply(this, typeUtils.isDefined(callbackResult) ? [callbackResult] : arguments);\n          }\n        }\n      });\n    }.bind(this));\n    return result.promise();\n  };\n  this._promise.state = function () {\n    return that._state;\n  };\n  this._promise.promise = function (args) {\n    return args ? extend(args, that._promise) : that._promise;\n  };\n  this._promise.promise(this);\n};\ndeferredConfig.forEach(function (config) {\n  var methodName = config.method;\n  var state = config.state;\n  _Deferred2.prototype[methodName + \"With\"] = function (context, args) {\n    var callbacks = this[methodName + \"Callbacks\"];\n    if (\"pending\" === this.state()) {\n      this[methodName + \"Args\"] = args;\n      this[methodName + \"Context\"] = context;\n      if (state) {\n        this._state = state;\n      }\n      callbacks.fire(context, args);\n    }\n    return this;\n  };\n});\nexports.fromPromise = function (promise, context) {\n  if (isDeferred(promise)) {\n    return promise;\n  } else {\n    if (isPromise(promise)) {\n      var d = new _Deferred2();\n      promise.then(function () {\n        d.resolveWith.apply(d, [context].concat([[].slice.call(arguments)]));\n      }, function () {\n        d.rejectWith.apply(d, [context].concat([[].slice.call(arguments)]));\n      });\n      return d;\n    }\n  }\n  return new _Deferred2().resolveWith(context, [promise]);\n};\nvar when = function when() {\n  if (1 === arguments.length) {\n    return exports.fromPromise(arguments[0]);\n  }\n  var values = [].slice.call(arguments),\n    contexts = [],\n    resolvedCount = 0,\n    deferred = new _Deferred2();\n  var updateState = function updateState(i) {\n    return function (value) {\n      contexts[i] = this;\n      values[i] = arguments.length > 1 ? [].slice.call(arguments) : value;\n      resolvedCount++;\n      if (resolvedCount === values.length) {\n        deferred.resolveWith(contexts, values);\n      }\n    };\n  };\n  for (var i = 0; i < values.length; i++) {\n    if (isDeferred(values[i])) {\n      values[i].promise().done(updateState(i)).fail(deferred.reject);\n    } else {\n      resolvedCount++;\n    }\n  }\n  if (resolvedCount === values.length) {\n    deferred.resolveWith(contexts, values);\n  }\n  return deferred.promise();\n};\nexports.setStrategy = function (value) {\n  _Deferred2 = value.Deferred;\n  when = value.when;\n};\nexports.Deferred = function () {\n  return new _Deferred2();\n};\nexports.when = function () {\n  return when.apply(this, arguments);\n};","map":null,"metadata":{},"sourceType":"script"}