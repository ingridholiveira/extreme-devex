{"ast":null,"code":"/**\r\n * DevExtreme (ui/resizable.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../core/renderer\"),\n  eventsEngine = require(\"../events/core/events_engine\"),\n  registerComponent = require(\"../core/component_registrator\"),\n  commonUtils = require(\"../core/utils/common\"),\n  extend = require(\"../core/utils/extend\").extend,\n  inArray = require(\"../core/utils/array\").inArray,\n  each = require(\"../core/utils/iterator\").each,\n  typeUtils = require(\"../core/utils/type\"),\n  windowUtils = require(\"../core/utils/window\"),\n  translator = require(\"../animation/translator\"),\n  fitIntoRange = require(\"../core/utils/math\").fitIntoRange,\n  DOMComponent = require(\"../core/dom_component\"),\n  eventUtils = require(\"../events/utils\"),\n  dragEvents = require(\"../events/drag\"),\n  isPlainObject = typeUtils.isPlainObject,\n  isFunction = typeUtils.isFunction,\n  domUtils = require(\"../core/utils/dom\");\nvar RESIZABLE = \"dxResizable\",\n  RESIZABLE_CLASS = \"dx-resizable\",\n  RESIZABLE_RESIZING_CLASS = \"dx-resizable-resizing\",\n  RESIZABLE_HANDLE_CLASS = \"dx-resizable-handle\",\n  RESIZABLE_HANDLE_TOP_CLASS = \"dx-resizable-handle-top\",\n  RESIZABLE_HANDLE_BOTTOM_CLASS = \"dx-resizable-handle-bottom\",\n  RESIZABLE_HANDLE_LEFT_CLASS = \"dx-resizable-handle-left\",\n  RESIZABLE_HANDLE_RIGHT_CLASS = \"dx-resizable-handle-right\",\n  RESIZABLE_HANDLE_CORNER_CLASS = \"dx-resizable-handle-corner\",\n  DRAGSTART_START_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, RESIZABLE),\n  DRAGSTART_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, RESIZABLE),\n  DRAGSTART_END_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, RESIZABLE);\nvar SIDE_BORDER_WIDTH_STYLES = {\n  left: \"borderLeftWidth\",\n  top: \"borderTopWidth\",\n  right: \"borderRightWidth\",\n  bottom: \"borderBottomWidth\"\n};\nvar Resizable = DOMComponent.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      handles: \"all\",\n      step: \"1\",\n      stepPrecision: \"simple\",\n      area: void 0,\n      minWidth: 30,\n      maxWidth: 1 / 0,\n      minHeight: 30,\n      maxHeight: 1 / 0,\n      onResizeStart: null,\n      onResize: null,\n      onResizeEnd: null,\n      roundStepValue: true\n    });\n  },\n  _init: function _init() {\n    this.callBase();\n    this.$element().addClass(RESIZABLE_CLASS);\n  },\n  _initMarkup: function _initMarkup() {\n    this.callBase();\n    this._renderHandles();\n  },\n  _render: function _render() {\n    this.callBase();\n    this._renderActions();\n  },\n  _renderActions: function _renderActions() {\n    this._resizeStartAction = this._createActionByOption(\"onResizeStart\");\n    this._resizeEndAction = this._createActionByOption(\"onResizeEnd\");\n    this._resizeAction = this._createActionByOption(\"onResize\");\n  },\n  _renderHandles: function _renderHandles() {\n    var handles = this.option(\"handles\");\n    if (\"none\" === handles) {\n      return;\n    }\n    var directions = \"all\" === handles ? [\"top\", \"bottom\", \"left\", \"right\"] : handles.split(\" \");\n    each(directions, function (index, handleName) {\n      this._renderHandle(handleName);\n    }.bind(this));\n    inArray(\"bottom\", directions) + 1 && inArray(\"right\", directions) + 1 && this._renderHandle(\"corner-bottom-right\");\n    inArray(\"bottom\", directions) + 1 && inArray(\"left\", directions) + 1 && this._renderHandle(\"corner-bottom-left\");\n    inArray(\"top\", directions) + 1 && inArray(\"right\", directions) + 1 && this._renderHandle(\"corner-top-right\");\n    inArray(\"top\", directions) + 1 && inArray(\"left\", directions) + 1 && this._renderHandle(\"corner-top-left\");\n  },\n  _renderHandle: function _renderHandle(handleName) {\n    var $element = this.$element(),\n      $handle = $(\"<div>\");\n    $handle.addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + \"-\" + handleName).appendTo($element);\n    this._attachEventHandlers($handle);\n  },\n  _attachEventHandlers: function _attachEventHandlers($handle) {\n    if (this.option(\"disabled\")) {\n      return;\n    }\n    var handlers = {};\n    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);\n    handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);\n    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);\n    eventsEngine.on($handle, handlers, {\n      direction: \"both\",\n      immediate: true\n    });\n  },\n  _dragStartHandler: function _dragStartHandler(e) {\n    var $element = this.$element();\n    if ($element.is(\".dx-state-disabled, .dx-state-disabled *\")) {\n      e.cancel = true;\n      return;\n    }\n    this._toggleResizingClass(true);\n    this._movingSides = this._getMovingSides(e);\n    this._elementLocation = translator.locate($element);\n    var elementRect = $element.get(0).getBoundingClientRect();\n    this._elementSize = {\n      width: elementRect.width,\n      height: elementRect.height\n    };\n    this._renderDragOffsets(e);\n    this._resizeStartAction({\n      event: e,\n      width: this._elementSize.width,\n      height: this._elementSize.height,\n      handles: this._movingSides\n    });\n    e.targetElements = null;\n  },\n  _toggleResizingClass: function _toggleResizingClass(value) {\n    this.$element().toggleClass(RESIZABLE_RESIZING_CLASS, value);\n  },\n  _renderDragOffsets: function _renderDragOffsets(e) {\n    var area = this._getArea();\n    if (!area) {\n      return;\n    }\n    var $handle = $(e.target).closest(\".\" + RESIZABLE_HANDLE_CLASS),\n      handleWidth = $handle.outerWidth(),\n      handleHeight = $handle.outerHeight(),\n      handleOffset = $handle.offset(),\n      areaOffset = area.offset,\n      scrollOffset = this._getAreaScrollOffset();\n    e.maxLeftOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;\n    e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;\n    e.maxTopOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;\n    e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;\n  },\n  _getBorderWidth: function _getBorderWidth($element, direction) {\n    if (typeUtils.isWindow($element.get(0))) {\n      return 0;\n    }\n    var borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);\n    return parseInt(borderWidth) || 0;\n  },\n  _dragHandler: function _dragHandler(e) {\n    var $element = this.$element(),\n      sides = this._movingSides;\n    var location = this._elementLocation,\n      size = this._elementSize,\n      offset = this._getOffset(e);\n    var width = size.width + offset.x * (sides.left ? -1 : 1),\n      height = size.height + offset.y * (sides.top ? -1 : 1);\n    if (offset.x || \"strict\" === this.option(\"stepPrecision\")) {\n      this._renderWidth(width);\n    }\n    if (offset.y || \"strict\" === this.option(\"stepPrecision\")) {\n      this._renderHeight(height);\n    }\n    var elementRect = $element.get(0).getBoundingClientRect(),\n      offsetTop = offset.y - ((elementRect.height || height) - height),\n      offsetLeft = offset.x - ((elementRect.width || width) - width);\n    translator.move($element, {\n      top: location.top + (sides.top ? offsetTop : 0),\n      left: location.left + (sides.left ? offsetLeft : 0)\n    });\n    this._resizeAction({\n      event: e,\n      width: this.option(\"width\") || width,\n      height: this.option(\"height\") || height,\n      handles: this._movingSides\n    });\n    domUtils.triggerResizeEvent($element);\n  },\n  _getOffset: function _getOffset(e) {\n    var offset = e.offset,\n      steps = commonUtils.pairToObject(this.option(\"step\"), !this.option(\"roundStepValue\")),\n      sides = this._getMovingSides(e),\n      strictPrecision = \"strict\" === this.option(\"stepPrecision\");\n    if (!sides.left && !sides.right) {\n      offset.x = 0;\n    }\n    if (!sides.top && !sides.bottom) {\n      offset.y = 0;\n    }\n    return strictPrecision ? this._getStrictOffset(offset, steps, sides) : this._getSimpleOffset(offset, steps);\n  },\n  _getSimpleOffset: function _getSimpleOffset(offset, steps) {\n    return {\n      x: offset.x - offset.x % steps.h,\n      y: offset.y - offset.y % steps.v\n    };\n  },\n  _getStrictOffset: function _getStrictOffset(offset, steps, sides) {\n    var location = this._elementLocation,\n      size = this._elementSize,\n      xPos = sides.left ? location.left : location.left + size.width,\n      yPos = sides.top ? location.top : location.top + size.height,\n      newXShift = (xPos + offset.x) % steps.h,\n      newYShift = (yPos + offset.y) % steps.v,\n      sign = Math.sign || function (x) {\n        x = +x;\n        if (0 === x || isNaN(x)) {\n          return x;\n        }\n        return x > 0 ? 1 : -1;\n      },\n      separatorOffset = function separatorOffset(steps, offset) {\n        return (1 + .2 * sign(offset)) % 1 * steps;\n      },\n      isSmallOffset = function isSmallOffset(offset, steps) {\n        return Math.abs(offset) < .2 * steps;\n      };\n    var newOffsetX = offset.x - newXShift,\n      newOffsetY = offset.y - newYShift;\n    if (newXShift > separatorOffset(steps.h, offset.x)) {\n      newOffsetX += steps.h;\n    }\n    if (newYShift > separatorOffset(steps.v, offset.y)) {\n      newOffsetY += steps.v;\n    }\n    return {\n      x: (sides.left || sides.right) && !isSmallOffset(offset.x, steps.h) ? newOffsetX : 0,\n      y: (sides.top || sides.bottom) && !isSmallOffset(offset.y, steps.v) ? newOffsetY : 0\n    };\n  },\n  _getMovingSides: function _getMovingSides(e) {\n    var $target = $(e.target),\n      hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + \"-top-left\"),\n      hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + \"-top-right\"),\n      hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + \"-bottom-left\"),\n      hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + \"-bottom-right\");\n    return {\n      top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,\n      left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,\n      bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,\n      right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass\n    };\n  },\n  _getArea: function _getArea() {\n    var area = this.option(\"area\");\n    if (isFunction(area)) {\n      area = area.call(this);\n    }\n    if (isPlainObject(area)) {\n      return this._getAreaFromObject(area);\n    }\n    return this._getAreaFromElement(area);\n  },\n  _getAreaScrollOffset: function _getAreaScrollOffset() {\n    var area = this.option(\"area\");\n    var isElement = !isFunction(area) && !isPlainObject(area);\n    var scrollOffset = {\n      scrollY: 0,\n      scrollX: 0\n    };\n    if (isElement) {\n      var areaElement = $(area)[0];\n      if (typeUtils.isWindow(areaElement)) {\n        scrollOffset.scrollX = areaElement.pageXOffset;\n        scrollOffset.scrollY = areaElement.pageYOffset;\n      }\n    }\n    return scrollOffset;\n  },\n  _getAreaFromObject: function _getAreaFromObject(area) {\n    var result = {\n      width: area.right - area.left,\n      height: area.bottom - area.top,\n      offset: {\n        left: area.left,\n        top: area.top\n      }\n    };\n    this._correctAreaGeometry(result);\n    return result;\n  },\n  _getAreaFromElement: function _getAreaFromElement(area) {\n    var result,\n      $area = $(area);\n    if ($area.length) {\n      result = {\n        width: $area.innerWidth(),\n        height: $area.innerHeight(),\n        offset: extend({\n          top: 0,\n          left: 0\n        }, typeUtils.isWindow($area[0]) ? {} : $area.offset())\n      };\n      this._correctAreaGeometry(result, $area);\n    }\n    return result;\n  },\n  _correctAreaGeometry: function _correctAreaGeometry(result, $area) {\n    var areaBorderLeft = $area ? this._getBorderWidth($area, \"left\") : 0,\n      areaBorderTop = $area ? this._getBorderWidth($area, \"top\") : 0;\n    result.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), \"left\");\n    result.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), \"top\");\n    result.width -= this.$element().outerWidth() - this.$element().innerWidth();\n    result.height -= this.$element().outerHeight() - this.$element().innerHeight();\n  },\n  _dragEndHandler: function _dragEndHandler(e) {\n    var $element = this.$element();\n    this._resizeEndAction({\n      event: e,\n      width: $element.outerWidth(),\n      height: $element.outerHeight(),\n      handles: this._movingSides\n    });\n    this._toggleResizingClass(false);\n  },\n  _renderWidth: function _renderWidth(width) {\n    this.option(\"width\", fitIntoRange(width, this.option(\"minWidth\"), this.option(\"maxWidth\")));\n  },\n  _renderHeight: function _renderHeight(height) {\n    this.option(\"height\", fitIntoRange(height, this.option(\"minHeight\"), this.option(\"maxHeight\")));\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"disabled\":\n      case \"handles\":\n        this._invalidate();\n        break;\n      case \"minWidth\":\n      case \"maxWidth\":\n        windowUtils.hasWindow() && this._renderWidth(this.$element().outerWidth());\n        break;\n      case \"minHeight\":\n      case \"maxHeight\":\n        windowUtils.hasWindow() && this._renderHeight(this.$element().outerHeight());\n        break;\n      case \"onResize\":\n      case \"onResizeStart\":\n      case \"onResizeEnd\":\n        this._renderActions();\n        break;\n      case \"area\":\n      case \"stepPrecision\":\n      case \"step\":\n      case \"roundStepValue\":\n        break;\n      default:\n        this.callBase(args);\n    }\n  },\n  _clean: function _clean() {\n    this.$element().find(\".\" + RESIZABLE_HANDLE_CLASS).remove();\n  }\n});\nregisterComponent(RESIZABLE, Resizable);\nmodule.exports = Resizable;\nmodule.exports.default = module.exports;","map":null,"metadata":{},"sourceType":"script"}