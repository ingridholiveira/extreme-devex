{"ast":null,"code":"/**\r\n * DevExtreme (ui/number_box/number_box.caret.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar fitIntoRange = require(\"../../core/utils/math\").fitIntoRange,\n  escapeRegExp = require(\"../../core/utils/common\").escapeRegExp,\n  number = require(\"../../localization/number\");\nvar getCaretBoundaries = function getCaretBoundaries(text, format) {\n  var signParts = format.split(\";\");\n  var sign = number.getSign(text, format);\n  signParts[1] = signParts[1] || \"-\" + signParts[0];\n  format = signParts[sign < 0 ? 1 : 0];\n  var mockEscapedStubs = function mockEscapedStubs(str) {\n    return str.replace(/'([^']*)'/g, function (str) {\n      return str.split(\"\").map(function () {\n        return \" \";\n      }).join(\"\").substr(2);\n    });\n  };\n  format = mockEscapedStubs(format);\n  var prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\n  var postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\n  return {\n    start: prefixStubLength,\n    end: text.length - postfixStubLength\n  };\n};\nvar _getDigitCountBeforeIndex = function _getDigitCountBeforeIndex(index, text) {\n  var decimalSeparator = number.getDecimalSeparator(),\n    regExp = new RegExp(\"[^0-9\" + escapeRegExp(decimalSeparator) + \"]\", \"g\"),\n    textBeforePosition = text.slice(0, index);\n  return textBeforePosition.replace(regExp, \"\").length;\n};\nvar _reverseText = function _reverseText(text) {\n  return text.split(\"\").reverse().join(\"\");\n};\nvar _getDigitPositionByIndex = function _getDigitPositionByIndex(digitIndex, text) {\n  if (!digitIndex) {\n    return -1;\n  }\n  var regExp = /[0-9]/g,\n    counter = 1,\n    index = null,\n    result = regExp.exec(text);\n  while (result) {\n    index = result.index;\n    if (!digitIndex || counter >= digitIndex) {\n      return index;\n    }\n    counter++;\n    result = regExp.exec(text);\n  }\n  return null === index ? text.length : index;\n};\nvar getCaretWithOffset = function getCaretWithOffset(caret, offset) {\n  if (void 0 === caret.start) {\n    caret = {\n      start: caret,\n      end: caret\n    };\n  }\n  return {\n    start: caret.start + offset,\n    end: caret.end + offset\n  };\n};\nvar getCaretAfterFormat = function getCaretAfterFormat(text, formatted, caret, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var point = number.getDecimalSeparator();\n  var isSeparatorBasedText = isSeparatorBasedString(text);\n  var pointPosition = isSeparatorBasedText ? 0 : text.indexOf(point);\n  var newPointPosition = formatted.indexOf(point);\n  var textParts = isSeparatorBasedText ? text.split(text[pointPosition]) : text.split(point);\n  var formattedParts = formatted.split(point);\n  var isCaretOnFloat = pointPosition !== -1 && caret.start > pointPosition;\n  if (isCaretOnFloat) {\n    var relativeIndex = caret.start - pointPosition - 1,\n      digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]),\n      newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\n    return getCaretInBoundaries(newPosition, formatted, format);\n  } else {\n    var positionFromEnd = textParts[0].length - caret.start,\n      digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0])),\n      newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedParts[0])),\n      newPositionFromBegin = formattedParts[0].length - (newPositionFromEnd + 1);\n    return getCaretInBoundaries(newPositionFromBegin, formatted, format);\n  }\n};\nvar isSeparatorBasedString = function isSeparatorBasedString(text) {\n  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);\n};\nvar isCaretInBoundaries = function isCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretInBoundaries(caret, text, format);\n  return caret.start >= boundaries.start && caret.end <= boundaries.end;\n};\nvar getCaretInBoundaries = function getCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretBoundaries(text, format),\n    adjustedCaret = {\n      start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\n      end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\n    };\n  return adjustedCaret;\n};\nvar getCaretOffset = function getCaretOffset(previousText, newText, format) {\n  var previousBoundaries = getCaretBoundaries(previousText, format),\n    newBoundaries = getCaretBoundaries(newText, format);\n  return newBoundaries.start - previousBoundaries.start;\n};\nexports.getCaretBoundaries = getCaretBoundaries;\nexports.isCaretInBoundaries = isCaretInBoundaries;\nexports.getCaretWithOffset = getCaretWithOffset;\nexports.getCaretInBoundaries = getCaretInBoundaries;\nexports.getCaretAfterFormat = getCaretAfterFormat;\nexports.getCaretOffset = getCaretOffset;","map":null,"metadata":{},"sourceType":"script"}