{"ast":null,"code":"/**\r\n * DevExtreme (ui/draggable.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) {\n        descriptor.writable = true;\n      }\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) {\n      defineProperties(Constructor.prototype, protoProps);\n    }\n    if (staticProps) {\n      defineProperties(Constructor, staticProps);\n    }\n    return Constructor;\n  };\n}();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar $ = require(\"../core/renderer\"),\n  window = require(\"../core/utils/window\").getWindow(),\n  eventsEngine = require(\"../events/core/events_engine\"),\n  stringUtils = require(\"../core/utils/string\"),\n  registerComponent = require(\"../core/component_registrator\"),\n  translator = require(\"../animation/translator\"),\n  Animator = require(\"./scroll_view/animator\"),\n  browser = require(\"../core/utils/browser\"),\n  dasherize = require(\"../core/utils/inflector\").dasherize,\n  extend = require(\"../core/utils/extend\").extend,\n  DOMComponentWithTemplate = require(\"../core/dom_component_with_template\"),\n  getPublicElement = require(\"../core/utils/dom\").getPublicElement,\n  eventUtils = require(\"../events/utils\"),\n  pointerEvents = require(\"../events/pointer\"),\n  dragEvents = require(\"../events/drag\"),\n  positionUtils = require(\"../animation/position\"),\n  typeUtils = require(\"../core/utils/type\"),\n  noop = require(\"../core/utils/common\").noop,\n  viewPortUtils = require(\"../core/utils/view_port\"),\n  commonUtils = require(\"../core/utils/common\");\nvar DRAGGABLE = \"dxDraggable\",\n  DRAGSTART_EVENT_NAME = eventUtils.addNamespace(dragEvents.start, DRAGGABLE),\n  DRAG_EVENT_NAME = eventUtils.addNamespace(dragEvents.move, DRAGGABLE),\n  DRAGEND_EVENT_NAME = eventUtils.addNamespace(dragEvents.end, DRAGGABLE),\n  DRAG_ENTER_EVENT_NAME = eventUtils.addNamespace(dragEvents.enter, DRAGGABLE),\n  DRAGEND_LEAVE_EVENT_NAME = eventUtils.addNamespace(dragEvents.leave, DRAGGABLE),\n  POINTERDOWN_EVENT_NAME = eventUtils.addNamespace(pointerEvents.down, DRAGGABLE),\n  CLONE_CLASS = \"clone\";\nvar targetDraggable, sourceDraggable;\nvar ScrollHelper = function () {\n  function ScrollHelper(orientation, component) {\n    _classCallCheck(this, ScrollHelper);\n    this._preventScroll = true;\n    this._component = component;\n    if (\"vertical\" === orientation) {\n      this._scrollValue = \"scrollTop\";\n      this._overFlowAttr = \"overflowY\";\n      this._sizeAttr = \"height\";\n      this._scrollSizeProp = \"scrollHeight\";\n      this._limitProps = {\n        start: \"top\",\n        end: \"bottom\"\n      };\n    } else {\n      this._scrollValue = \"scrollLeft\";\n      this._overFlowAttr = \"overflowX\";\n      this._sizeAttr = \"width\";\n      this._scrollSizeProp = \"scrollWidth\";\n      this._limitProps = {\n        start: \"left\",\n        end: \"right\"\n      };\n    }\n  }\n  _createClass(ScrollHelper, [{\n    key: \"findScrollable\",\n    value: function value(elements, mousePosition) {\n      var that = this;\n      if (!elements.some(function (element) {\n        return that._trySetScrollable(element, mousePosition);\n      })) {\n        that._$scrollable = null;\n        that._scrollSpeed = 0;\n      }\n    }\n  }, {\n    key: \"_trySetScrollable\",\n    value: function value(element, mousePosition) {\n      var distanceToBorders,\n        that = this,\n        $element = $(element),\n        sensitivity = that._component.option(\"scrollSensitivity\"),\n        isScrollable = (\"auto\" === $element.css(that._overFlowAttr) || $element.hasClass(\"dx-scrollable-container\")) && $element.prop(that._scrollSizeProp) > $element[that._sizeAttr]();\n      if (isScrollable) {\n        distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);\n        if (sensitivity > distanceToBorders[that._limitProps.start]) {\n          if (!that._preventScroll) {\n            that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);\n            that._$scrollable = $element;\n          }\n        } else {\n          if (sensitivity > distanceToBorders[that._limitProps.end]) {\n            if (!that._preventScroll) {\n              that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);\n              that._$scrollable = $element;\n            }\n          } else {\n            isScrollable = false;\n            that._preventScroll = false;\n          }\n        }\n      }\n      return isScrollable;\n    }\n  }, {\n    key: \"_calculateDistanceToBorders\",\n    value: function value($area, mousePosition) {\n      var areaBoundingRect,\n        area = $area.get(0);\n      if (area) {\n        areaBoundingRect = area.getBoundingClientRect();\n        return {\n          left: mousePosition.x - areaBoundingRect.left,\n          top: mousePosition.y - areaBoundingRect.top,\n          right: areaBoundingRect.right - mousePosition.x,\n          bottom: areaBoundingRect.bottom - mousePosition.y\n        };\n      } else {\n        return {};\n      }\n    }\n  }, {\n    key: \"_calculateScrollSpeed\",\n    value: function value(distance) {\n      var component = this._component,\n        sensitivity = component.option(\"scrollSensitivity\"),\n        maxSpeed = component.option(\"scrollSpeed\");\n      return Math.round((sensitivity - distance) / sensitivity * maxSpeed);\n    }\n  }, {\n    key: \"scrollByStep\",\n    value: function value() {\n      var nextScrollPosition,\n        that = this;\n      if (that._$scrollable && that._scrollSpeed) {\n        if (that._$scrollable.hasClass(\"dx-scrollable-container\")) {\n          var $scrollable = that._$scrollable.closest(\".dx-scrollable\"),\n            scrollableInstance = $scrollable.data(\"dxScrollable\") || $scrollable.data(\"dxScrollView\");\n          if (scrollableInstance) {\n            nextScrollPosition = scrollableInstance.scrollOffset();\n            nextScrollPosition[that._limitProps.start] += that._scrollSpeed;\n            scrollableInstance.scrollTo(nextScrollPosition);\n          }\n        } else {\n          nextScrollPosition = that._$scrollable[that._scrollValue]() + that._scrollSpeed;\n          that._$scrollable[that._scrollValue](nextScrollPosition);\n        }\n        var dragMoveArgs = that._component._dragMoveArgs;\n        if (dragMoveArgs) {\n          that._component._dragMoveHandler(dragMoveArgs);\n        }\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function value() {\n      this._$scrollable = null;\n      this._scrollSpeed = 0;\n    }\n  }]);\n  return ScrollHelper;\n}();\nvar ScrollAnimator = Animator.inherit({\n  ctor: function ctor(strategy) {\n    this.callBase();\n    this._strategy = strategy;\n  },\n  _step: function _step() {\n    var horizontalScrollHelper = this._strategy.horizontalScrollHelper,\n      verticalScrollHelper = this._strategy.verticalScrollHelper;\n    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();\n    verticalScrollHelper && verticalScrollHelper.scrollByStep();\n  }\n});\nvar Draggable = DOMComponentWithTemplate.inherit({\n  reset: noop,\n  dragMove: noop,\n  dragEnter: noop,\n  dragLeave: noop,\n  dragEnd: noop,\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      onDragStart: null,\n      onDragMove: null,\n      onDragEnd: null,\n      onDrop: null,\n      immediate: true,\n      dragDirection: \"both\",\n      boundary: void 0,\n      boundOffset: 0,\n      allowMoveByClick: false,\n      itemData: null,\n      container: void 0,\n      template: void 0,\n      handle: \"\",\n      filter: \"\",\n      clone: false,\n      autoScroll: true,\n      scrollSpeed: 60,\n      scrollSensitivity: 60,\n      group: void 0,\n      data: void 0\n    });\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase.apply(this, arguments);\n    extend(this._optionsByReference, {\n      group: true,\n      itemData: true,\n      data: true\n    });\n  },\n  _init: function _init() {\n    this.callBase();\n    this._attachEventHandlers();\n    this._scrollAnimator = new ScrollAnimator(this);\n    this.horizontalScrollHelper = new ScrollHelper(\"horizontal\", this);\n    this.verticalScrollHelper = new ScrollHelper(\"vertical\", this);\n  },\n  _initTemplates: noop,\n  _normalizeCursorOffset: function _normalizeCursorOffset(offset, $sourceElement, $dragElement) {\n    if (typeUtils.isFunction(offset)) {\n      offset = offset.call(this, {\n        itemElement: $sourceElement,\n        dragElement: $dragElement\n      });\n    }\n    if (typeUtils.isObject(offset)) {\n      offset = {\n        h: offset.x,\n        v: offset.y\n      };\n    }\n    var result = commonUtils.pairToObject(offset);\n    return {\n      left: result.h,\n      top: result.v\n    };\n  },\n  _initPosition: function _initPosition($element, $dragElement) {\n    var elementOffset = void 0,\n      dragElementOffset = void 0,\n      isCloned = this._dragElementIsCloned(),\n      cursorOffset = this.option(\"cursorOffset\"),\n      normalizedCursorOffset = this._normalizeCursorOffset(cursorOffset, $element, $dragElement);\n    if (isCloned) {\n      elementOffset = $element.offset();\n      dragElementOffset = $dragElement.offset();\n      elementOffset.top -= dragElementOffset.top - normalizedCursorOffset.top;\n      elementOffset.left -= dragElementOffset.left - normalizedCursorOffset.left;\n    }\n    if (elementOffset || cursorOffset) {\n      this._move(elementOffset || normalizedCursorOffset, $dragElement);\n    }\n    this._startPosition = translator.locate($dragElement);\n  },\n  _startAnimator: function _startAnimator() {\n    if (!this._scrollAnimator.inProgress()) {\n      this._scrollAnimator.start();\n    }\n  },\n  _stopAnimator: function _stopAnimator() {\n    this._scrollAnimator.stop();\n  },\n  _addWidgetPrefix: function _addWidgetPrefix(className) {\n    var componentName = this.NAME;\n    return dasherize(componentName) + (className ? \"-\" + className : \"\");\n  },\n  _getItemsSelector: function _getItemsSelector() {\n    return this.option(\"filter\") || \"\";\n  },\n  _attachEventHandlers: function _attachEventHandlers() {\n    var _this = this;\n    if (this.option(\"disabled\")) {\n      return;\n    }\n    var $element = this.$element(),\n      itemsSelector = this._getItemsSelector(),\n      allowMoveByClick = this.option(\"allowMoveByClick\"),\n      data = {\n        direction: this.option(\"dragDirection\"),\n        immediate: this.option(\"immediate\"),\n        checkDropTarget: function checkDropTarget($target) {\n          var sourceGroup = _this.option(\"group\"),\n            targetComponent = $target.data(\"dxDraggable\") || $target.data(\"dxSortable\"),\n            targetGroup = targetComponent && targetComponent.option(\"group\");\n          return sourceGroup && sourceGroup === targetGroup;\n        }\n      };\n    if (allowMoveByClick) {\n      $element = this._getArea();\n      eventsEngine.on($element, POINTERDOWN_EVENT_NAME, data, this._pointerDownHandler.bind(this));\n    }\n    if (\">\" === itemsSelector[0]) {\n      itemsSelector = itemsSelector.slice(1);\n    }\n    eventsEngine.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data, this._dragStartHandler.bind(this));\n    eventsEngine.on($element, DRAG_EVENT_NAME, data, this._dragMoveHandler.bind(this));\n    eventsEngine.on($element, DRAGEND_EVENT_NAME, data, this._dragEndHandler.bind(this));\n    eventsEngine.on($element, DRAG_ENTER_EVENT_NAME, data, this._dragEnterHandler.bind(this));\n    eventsEngine.on($element, DRAGEND_LEAVE_EVENT_NAME, data, this._dragLeaveHandler.bind(this));\n  },\n  _dragElementIsCloned: function _dragElementIsCloned() {\n    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS));\n  },\n  _getDragTemplateArgs: function _getDragTemplateArgs($element) {\n    var container = this._getContainer();\n    return {\n      container: getPublicElement($(container)),\n      model: {\n        itemData: this.option(\"itemData\"),\n        itemElement: getPublicElement($element)\n      }\n    };\n  },\n  _createDragElement: function _createDragElement($element) {\n    var result = $element,\n      clone = this.option(\"clone\"),\n      container = this._getContainer(),\n      template = this.option(\"template\");\n    if (template) {\n      template = this._getTemplate(template);\n      result = $(template.render(this._getDragTemplateArgs($element)));\n    } else {\n      if (clone) {\n        result = $element.clone().appendTo(container);\n      }\n    }\n    return result.toggleClass(this._addWidgetPrefix(CLONE_CLASS), result.get(0) !== $element.get(0));\n  },\n  _resetDragElement: function _resetDragElement() {\n    if (this._dragElementIsCloned()) {\n      this._$dragElement.remove();\n    } else {\n      this._toggleDraggingClass(false);\n    }\n    this._$dragElement = null;\n  },\n  _resetSourceElement: function _resetSourceElement() {\n    this._toggleDragSourceClass(false);\n    this._$sourceElement = null;\n  },\n  _detachEventHandlers: function _detachEventHandlers() {\n    eventsEngine.off(this.$element(), \".\" + DRAGGABLE);\n    eventsEngine.off(this._getArea(), \".\" + DRAGGABLE);\n  },\n  _move: function _move(position, $element) {\n    translator.move($element || this._$dragElement, position);\n  },\n  _getDraggableElement: function _getDraggableElement(e) {\n    var $sourceElement = this._getSourceElement();\n    if ($sourceElement) {\n      return $sourceElement;\n    }\n    var allowMoveByClick = this.option(\"allowMoveByClick\");\n    if (allowMoveByClick) {\n      return this.$element();\n    }\n    var $target = $(e && e.target),\n      itemsSelector = this._getItemsSelector();\n    if (\">\" === itemsSelector[0]) {\n      var $items = this.$element().find(itemsSelector);\n      if (!$items.is($target)) {\n        $target = $target.closest($items);\n      }\n    }\n    return $target;\n  },\n  _getSourceElement: function _getSourceElement() {\n    var draggable = this._getSourceDraggable();\n    return draggable._$sourceElement;\n  },\n  _pointerDownHandler: function _pointerDownHandler(e) {\n    if (eventUtils.needSkipEvent(e)) {\n      return;\n    }\n    var position = {},\n      $element = this.$element(),\n      dragDirection = this.option(\"dragDirection\");\n    if (\"horizontal\" === dragDirection || \"both\" === dragDirection) {\n      position.left = e.pageX - $element.offset().left + translator.locate($element).left - $element.width() / 2;\n    }\n    if (\"vertical\" === dragDirection || \"both\" === dragDirection) {\n      position.top = e.pageY - $element.offset().top + translator.locate($element).top - $element.height() / 2;\n    }\n    this._move(position, $element);\n    this._getAction(\"onDragMove\")(this._getEventArgs(e));\n  },\n  _isValidElement: function _isValidElement(event, $element) {\n    var handle = this.option(\"handle\"),\n      $target = $(event.originalEvent && event.originalEvent.target);\n    if (handle && !$target.closest(handle).length) {\n      return false;\n    }\n    if (!$element.length) {\n      return false;\n    }\n    return !$element.is(\".dx-state-disabled, .dx-state-disabled *\");\n  },\n  _dragStartHandler: function _dragStartHandler(e) {\n    var $element = this._getDraggableElement(e);\n    if (this._$sourceElement) {\n      return;\n    }\n    if (!this._isValidElement(e, $element)) {\n      e.cancel = true;\n      return;\n    }\n    var dragStartArgs = this._getDragStartArgs(e, $element);\n    this._getAction(\"onDragStart\")(dragStartArgs);\n    if (dragStartArgs.cancel) {\n      e.cancel = true;\n      return;\n    }\n    this.option(\"itemData\", dragStartArgs.itemData);\n    this._setSourceDraggable();\n    this._$sourceElement = $element;\n    var $dragElement = this._$dragElement = this._createDragElement($element);\n    this._toggleDraggingClass(true);\n    this._toggleDragSourceClass(true);\n    this._initPosition($element, $dragElement);\n    var $area = this._getArea(),\n      areaOffset = this._getAreaOffset($area),\n      boundOffset = this._getBoundOffset(),\n      areaWidth = $area.outerWidth(),\n      areaHeight = $area.outerHeight(),\n      elementWidth = $dragElement.width(),\n      elementHeight = $dragElement.height();\n    var startOffset = {\n      left: $dragElement.offset().left - areaOffset.left,\n      top: $dragElement.offset().top - areaOffset.top\n    };\n    if ($area.length) {\n      e.maxLeftOffset = startOffset.left - boundOffset.left;\n      e.maxRightOffset = areaWidth - startOffset.left - elementWidth - boundOffset.right;\n      e.maxTopOffset = startOffset.top - boundOffset.top;\n      e.maxBottomOffset = areaHeight - startOffset.top - elementHeight - boundOffset.bottom;\n    }\n    if (this.option(\"autoScroll\")) {\n      this._startAnimator();\n    }\n  },\n  _getAreaOffset: function _getAreaOffset($area) {\n    var offset = $area && positionUtils.offset($area);\n    return offset ? offset : {\n      left: 0,\n      top: 0\n    };\n  },\n  _toggleDraggingClass: function _toggleDraggingClass(value) {\n    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix(\"dragging\"), value);\n  },\n  _toggleDragSourceClass: function _toggleDragSourceClass(value, $element) {\n    var $sourceElement = $element || this._$sourceElement;\n    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix(\"source\"), value);\n  },\n  _getBoundOffset: function _getBoundOffset() {\n    var boundOffset = this.option(\"boundOffset\");\n    if (typeUtils.isFunction(boundOffset)) {\n      boundOffset = boundOffset.call(this);\n    }\n    return stringUtils.quadToObject(boundOffset);\n  },\n  _getArea: function _getArea() {\n    var area = this.option(\"boundary\");\n    if (typeUtils.isFunction(area)) {\n      area = area.call(this);\n    }\n    return $(area);\n  },\n  _getContainer: function _getContainer() {\n    var container = this.option(\"container\");\n    if (void 0 === container) {\n      container = viewPortUtils.value();\n    }\n    return $(container);\n  },\n  _dragMoveHandler: function _dragMoveHandler(e) {\n    this._dragMoveArgs = e;\n    if (!this._$dragElement) {\n      e.cancel = true;\n      return;\n    }\n    var offset = e.offset,\n      startPosition = this._startPosition;\n    this._move({\n      left: startPosition.left + offset.x,\n      top: startPosition.top + offset.y\n    });\n    if (this.option(\"autoScroll\")) {\n      this._findScrollable(e);\n    }\n    var eventArgs = this._getEventArgs(e);\n    this._getAction(\"onDragMove\")(eventArgs);\n    if (true === eventArgs.cancel) {\n      return;\n    }\n    var targetDraggable = this._getTargetDraggable();\n    targetDraggable.dragMove(e);\n  },\n  _findScrollable: function _findScrollable(e) {\n    var allObjects,\n      that = this,\n      $dragElement = that._$dragElement,\n      ownerDocument = $dragElement.get(0).ownerDocument,\n      $window = $(window),\n      mousePosition = {\n        x: e.pageX - $window.scrollLeft(),\n        y: e.pageY - $window.scrollTop()\n      };\n    if (browser.msie) {\n      var msElements = ownerDocument.msElementsFromPoint(mousePosition.x, mousePosition.y);\n      if (msElements) {\n        allObjects = Array.prototype.slice.call(msElements);\n      } else {\n        allObjects = [];\n      }\n    } else {\n      allObjects = ownerDocument.elementsFromPoint(mousePosition.x, mousePosition.y);\n    }\n    that.verticalScrollHelper && that.verticalScrollHelper.findScrollable(allObjects, mousePosition);\n    that.horizontalScrollHelper && that.horizontalScrollHelper.findScrollable(allObjects, mousePosition);\n  },\n  _getEventArgs: function _getEventArgs(e) {\n    var sourceDraggable = this._getSourceDraggable(),\n      targetDraggable = this._getTargetDraggable();\n    return {\n      event: e,\n      itemData: sourceDraggable.option(\"itemData\"),\n      itemElement: getPublicElement(sourceDraggable._$sourceElement),\n      fromComponent: sourceDraggable,\n      toComponent: targetDraggable,\n      fromData: sourceDraggable.option(\"data\"),\n      toData: targetDraggable.option(\"data\")\n    };\n  },\n  _getDragEndAndDropArgs: function _getDragEndAndDropArgs(e) {\n    var targetDraggable = this._getTargetDraggable();\n    return extend(this._getEventArgs(e), {\n      fromComponent: this,\n      toComponent: targetDraggable,\n      toData: targetDraggable.option(\"data\")\n    });\n  },\n  _getDragStartArgs: function _getDragStartArgs(e, $itemElement) {\n    var args = this._getEventArgs(e);\n    return {\n      event: args.event,\n      itemData: args.itemData,\n      itemElement: $itemElement,\n      fromData: args.fromData\n    };\n  },\n  _revertItemToInitialPosition: function _revertItemToInitialPosition() {\n    !this._dragElementIsCloned() && this._move(this._startPosition, this._$sourceElement);\n  },\n  _dragEndHandler: function _dragEndHandler(e) {\n    var dragEndEventArgs = this._getDragEndAndDropArgs(e),\n      dropEventArgs = this._getDragEndAndDropArgs(e),\n      targetDraggable = this._getTargetDraggable(),\n      needRevertPosition = true;\n    this._getAction(\"onDragEnd\")(dragEndEventArgs);\n    if (!dragEndEventArgs.cancel) {\n      if (targetDraggable !== this) {\n        targetDraggable._getAction(\"onDrop\")(dropEventArgs);\n      }\n      if (!dropEventArgs.cancel) {\n        targetDraggable.dragEnd(dragEndEventArgs);\n        needRevertPosition = false;\n      }\n    }\n    if (needRevertPosition) {\n      this._revertItemToInitialPosition();\n    }\n    this.reset();\n    targetDraggable.reset();\n    this._stopAnimator();\n    this.horizontalScrollHelper.reset();\n    this.verticalScrollHelper.reset();\n    this._resetDragElement();\n    this._resetSourceElement();\n    this._resetTargetDraggable();\n    this._resetSourceDraggable();\n  },\n  _dragEnterHandler: function _dragEnterHandler(e) {\n    this._setTargetDraggable();\n    var sourceDraggable = this._getSourceDraggable();\n    sourceDraggable.dragEnter(e);\n  },\n  _dragLeaveHandler: function _dragLeaveHandler(e) {\n    this._resetTargetDraggable();\n    this.reset();\n    var sourceDraggable = this._getSourceDraggable();\n    sourceDraggable.dragLeave(e);\n  },\n  _getAction: function _getAction(name) {\n    return this[\"_\" + name + \"Action\"] || this._createActionByOption(name);\n  },\n  _render: function _render() {\n    this.callBase();\n    this.$element().addClass(this._addWidgetPrefix());\n  },\n  _optionChanged: function _optionChanged(args) {\n    var name = args.name;\n    switch (name) {\n      case \"onDragStart\":\n      case \"onDragMove\":\n      case \"onDragEnd\":\n      case \"onDrop\":\n        this[\"_\" + name + \"Action\"] = this._createActionByOption(name);\n        break;\n      case \"template\":\n      case \"container\":\n      case \"clone\":\n        this._resetDragElement();\n        break;\n      case \"allowMoveByClick\":\n      case \"dragDirection\":\n      case \"disabled\":\n      case \"boundary\":\n      case \"filter\":\n      case \"immediate\":\n        this._resetDragElement();\n        this._detachEventHandlers();\n        this._attachEventHandlers();\n        break;\n      case \"autoScroll\":\n        this.verticalScrollHelper.reset();\n        this.horizontalScrollHelper.reset();\n        break;\n      case \"scrollSensitivity\":\n      case \"scrollSpeed\":\n      case \"boundOffset\":\n      case \"handle\":\n      case \"group\":\n      case \"data\":\n      case \"itemData\":\n        break;\n      default:\n        this.callBase(args);\n    }\n  },\n  _getTargetDraggable: function _getTargetDraggable() {\n    return targetDraggable || this;\n  },\n  _getSourceDraggable: function _getSourceDraggable() {\n    return sourceDraggable || this;\n  },\n  _setTargetDraggable: function _setTargetDraggable() {\n    var currentGroup = this.option(\"group\"),\n      sourceDraggable = this._getSourceDraggable();\n    if (currentGroup && currentGroup === sourceDraggable.option(\"group\")) {\n      targetDraggable = this;\n    }\n  },\n  _setSourceDraggable: function _setSourceDraggable() {\n    sourceDraggable = this;\n  },\n  _resetSourceDraggable: function _resetSourceDraggable() {\n    sourceDraggable = null;\n  },\n  _resetTargetDraggable: function _resetTargetDraggable() {\n    targetDraggable = null;\n  },\n  _dispose: function _dispose() {\n    this.callBase();\n    this._detachEventHandlers();\n    this._resetDragElement();\n    this._resetTargetDraggable();\n    this._resetSourceDraggable();\n    this._$sourceElement = null;\n    this._stopAnimator();\n  }\n});\nregisterComponent(DRAGGABLE, Draggable);\nmodule.exports = Draggable;\nmodule.exports.default = module.exports;","map":null,"metadata":{},"sourceType":"script"}