{"ast":null,"code":"/**\r\n * DevExtreme (events/gesture/emitter.gesture.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\"),\n  eventsEngine = require(\"../../events/core/events_engine\"),\n  devices = require(\"../../core/devices\"),\n  styleUtils = require(\"../../core/utils/style\"),\n  callOnce = require(\"../../core/utils/call_once\"),\n  domUtils = require(\"../../core/utils/dom\"),\n  readyCallbacks = require(\"../../core/utils/ready_callbacks\"),\n  ready = readyCallbacks.add,\n  mathUtils = require(\"../../core/utils/math\"),\n  noop = require(\"../../core/utils/common\").noop,\n  isDefined = require(\"../../core/utils/type\").isDefined,\n  eventUtils = require(\"../utils\"),\n  Emitter = require(\"../core/emitter\"),\n  sign = mathUtils.sign,\n  abs = Math.abs;\nvar SLEEP = 0,\n  INITED = 1,\n  STARTED = 2,\n  TOUCH_BOUNDARY = 10,\n  IMMEDIATE_TOUCH_BOUNDARY = 0,\n  IMMEDIATE_TIMEOUT = 180;\nvar supportPointerEvents = function supportPointerEvents() {\n  return styleUtils.styleProp(\"pointer-events\");\n};\nvar setGestureCover = callOnce(function () {\n  var GESTURE_COVER_CLASS = \"dx-gesture-cover\";\n  var isDesktop = \"desktop\" === devices.real().deviceType;\n  if (!supportPointerEvents() || !isDesktop) {\n    return noop;\n  }\n  var $cover = $(\"<div>\").addClass(GESTURE_COVER_CLASS).css(\"pointerEvents\", \"none\");\n  eventsEngine.subscribeGlobal($cover, \"dxmousewheel\", function (e) {\n    e.preventDefault();\n  });\n  ready(function () {\n    $cover.appendTo(\"body\");\n  });\n  return function (toggle, cursor) {\n    $cover.css(\"pointerEvents\", toggle ? \"all\" : \"none\");\n    toggle && $cover.css(\"cursor\", cursor);\n  };\n});\nvar gestureCover = function gestureCover(toggle, cursor) {\n  var gestureCoverStrategy = setGestureCover();\n  gestureCoverStrategy(toggle, cursor);\n};\nvar GestureEmitter = Emitter.inherit({\n  gesture: true,\n  configure: function configure(data) {\n    this.getElement().css(\"msTouchAction\", data.immediate ? \"pinch-zoom\" : \"\");\n    this.callBase(data);\n  },\n  allowInterruptionByMouseWheel: function allowInterruptionByMouseWheel() {\n    return this._stage !== STARTED;\n  },\n  getDirection: function getDirection() {\n    return this.direction;\n  },\n  _cancel: function _cancel() {\n    this.callBase.apply(this, arguments);\n    this._toggleGestureCover(false);\n    this._stage = SLEEP;\n  },\n  start: function start(e) {\n    if (e._needSkipEvent || eventUtils.needSkipEvent(e)) {\n      this._cancel(e);\n      return;\n    }\n    this._startEvent = eventUtils.createEvent(e);\n    this._startEventData = eventUtils.eventData(e);\n    this._stage = INITED;\n    this._init(e);\n    this._setupImmediateTimer();\n  },\n  _setupImmediateTimer: function _setupImmediateTimer() {\n    clearTimeout(this._immediateTimer);\n    this._immediateAccepted = false;\n    if (!this.immediate) {\n      return;\n    }\n    this._immediateTimer = setTimeout(function () {\n      this._immediateAccepted = true;\n    }.bind(this), IMMEDIATE_TIMEOUT);\n  },\n  move: function move(e) {\n    if (this._stage === INITED && this._directionConfirmed(e)) {\n      this._stage = STARTED;\n      this._resetActiveElement();\n      this._toggleGestureCover(true);\n      this._clearSelection(e);\n      this._adjustStartEvent(e);\n      this._start(this._startEvent);\n      if (this._stage === SLEEP) {\n        return;\n      }\n      this._requestAccept(e);\n      this._move(e);\n      this._forgetAccept();\n    } else {\n      if (this._stage === STARTED) {\n        this._clearSelection(e);\n        this._move(e);\n      }\n    }\n  },\n  _directionConfirmed: function _directionConfirmed(e) {\n    var touchBoundary = this._getTouchBoundary(e),\n      delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e)),\n      deltaX = abs(delta.x),\n      deltaY = abs(delta.y);\n    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY),\n      verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);\n    var direction = this.getDirection(e),\n      bothAccepted = \"both\" === direction && (horizontalMove || verticalMove),\n      horizontalAccepted = \"horizontal\" === direction && horizontalMove,\n      verticalAccepted = \"vertical\" === direction && verticalMove;\n    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;\n  },\n  _validateMove: function _validateMove(touchBoundary, mainAxis, crossAxis) {\n    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);\n  },\n  _getTouchBoundary: function _getTouchBoundary(e) {\n    return this.immediate || eventUtils.isDxMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY;\n  },\n  _adjustStartEvent: function _adjustStartEvent(e) {\n    var touchBoundary = this._getTouchBoundary(e),\n      delta = eventUtils.eventDelta(this._startEventData, eventUtils.eventData(e));\n    this._startEvent.pageX += sign(delta.x) * touchBoundary;\n    this._startEvent.pageY += sign(delta.y) * touchBoundary;\n  },\n  _resetActiveElement: function _resetActiveElement() {\n    if (\"ios\" === devices.real().platform && this.getElement().find(\":focus\").length) {\n      domUtils.resetActiveElement();\n    }\n  },\n  _toggleGestureCover: function _toggleGestureCover(toggle) {\n    var isStarted = this._stage === STARTED;\n    if (isStarted) {\n      gestureCover(toggle, this.getElement().css(\"cursor\"));\n    }\n  },\n  _clearSelection: function _clearSelection(e) {\n    if (eventUtils.isDxMouseWheelEvent(e) || eventUtils.isTouchEvent(e)) {\n      return;\n    }\n    domUtils.clearSelection();\n  },\n  end: function end(e) {\n    this._toggleGestureCover(false);\n    if (this._stage === STARTED) {\n      this._end(e);\n    } else {\n      if (this._stage === INITED) {\n        this._stop(e);\n      }\n    }\n    this._stage = SLEEP;\n  },\n  dispose: function dispose() {\n    clearTimeout(this._immediateTimer);\n    this.callBase.apply(this, arguments);\n    this._toggleGestureCover(false);\n  },\n  _init: noop,\n  _start: noop,\n  _move: noop,\n  _stop: noop,\n  _end: noop\n});\nGestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;\nGestureEmitter.touchBoundary = function (newBoundary) {\n  if (isDefined(newBoundary)) {\n    TOUCH_BOUNDARY = newBoundary;\n    return;\n  }\n  return TOUCH_BOUNDARY;\n};\nmodule.exports = GestureEmitter;","map":null,"metadata":{},"sourceType":"script"}