{"ast":null,"code":"/**\r\n * DevExtreme (core/utils/common.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _typeof = \"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _config = require(\"../config\");\nvar _config2 = _interopRequireDefault(_config);\nvar _guid = require(\"../guid\");\nvar _guid2 = _interopRequireDefault(_guid);\nvar _deferred = require(\"../utils/deferred\");\nvar _iterator = require(\"./iterator\");\nvar _data = require(\"./data\");\nvar _type = require(\"./type\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar ensureDefined = function ensureDefined(value, defaultValue) {\n  return (0, _type.isDefined)(value) ? value : defaultValue;\n};\nvar executeAsync = function executeAsync(action, context) {\n  var deferred = new _deferred.Deferred();\n  var normalizedContext = context || this;\n  var timerId = void 0;\n  var task = {\n    promise: deferred.promise(),\n    abort: function abort() {\n      clearTimeout(timerId);\n      deferred.rejectWith(normalizedContext);\n    }\n  };\n  var callback = function callback() {\n    var result = action.call(normalizedContext);\n    if (result && result.done && (0, _type.isFunction)(result.done)) {\n      result.done(function () {\n        deferred.resolveWith(normalizedContext);\n      });\n    } else {\n      deferred.resolveWith(normalizedContext);\n    }\n  };\n  timerId = (arguments[2] || setTimeout)(callback, \"number\" === typeof context ? context : 0);\n  return task;\n};\nvar delayedFuncs = [];\nvar delayedNames = [];\nvar delayedDeferreds = [];\nvar executingName = void 0;\nvar deferExecute = function deferExecute(name, func, deferred) {\n  if (executingName && executingName !== name) {\n    delayedFuncs.push(func);\n    delayedNames.push(name);\n    deferred = deferred || new _deferred.Deferred();\n    delayedDeferreds.push(deferred);\n    return deferred;\n  } else {\n    var oldExecutingName = executingName;\n    var currentDelayedCount = delayedDeferreds.length;\n    executingName = name;\n    var result = func();\n    if (!result) {\n      if (delayedDeferreds.length > currentDelayedCount) {\n        result = _deferred.when.apply(this, delayedDeferreds.slice(currentDelayedCount));\n      } else {\n        if (deferred) {\n          deferred.resolve();\n        }\n      }\n    }\n    executingName = oldExecutingName;\n    if (deferred && result && result.done) {\n      result.done(deferred.resolve).fail(deferred.reject);\n    }\n    if (!executingName && delayedFuncs.length) {\n      (\"render\" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());\n    }\n    return result || (0, _deferred.when)();\n  }\n};\nvar deferRender = function deferRender(func, deferred) {\n  return deferExecute(\"render\", func, deferred);\n};\nvar deferUpdate = function deferUpdate(func, deferred) {\n  return deferExecute(\"update\", func, deferred);\n};\nvar deferRenderer = function deferRenderer(func) {\n  return function () {\n    var that = this;\n    return deferExecute(\"render\", function () {\n      return func.call(that);\n    });\n  };\n};\nvar deferUpdater = function deferUpdater(func) {\n  return function () {\n    var that = this;\n    return deferExecute(\"update\", function () {\n      return func.call(that);\n    });\n  };\n};\nvar findBestMatches = function findBestMatches(targetFilter, items, mapFn) {\n  var bestMatches = [];\n  var maxMatchCount = 0;\n  (0, _iterator.each)(items, function (index, itemSrc) {\n    var matchCount = 0;\n    var item = mapFn ? mapFn(itemSrc) : itemSrc;\n    (0, _iterator.each)(targetFilter, function (paramName, targetValue) {\n      var value = item[paramName];\n      if (void 0 === value) {\n        return;\n      }\n      if (match(value, targetValue)) {\n        matchCount++;\n        return;\n      }\n      matchCount = -1;\n      return false;\n    });\n    if (matchCount < maxMatchCount) {\n      return;\n    }\n    if (matchCount > maxMatchCount) {\n      bestMatches.length = 0;\n      maxMatchCount = matchCount;\n    }\n    bestMatches.push(itemSrc);\n  });\n  return bestMatches;\n};\nvar match = function match(value, targetValue) {\n  if (Array.isArray(value) && Array.isArray(targetValue)) {\n    var mismatch = false;\n    (0, _iterator.each)(value, function (index, valueItem) {\n      if (valueItem !== targetValue[index]) {\n        mismatch = true;\n        return false;\n      }\n    });\n    if (mismatch) {\n      return false;\n    }\n    return true;\n  }\n  if (value === targetValue) {\n    return true;\n  }\n  return false;\n};\nvar splitPair = function splitPair(raw) {\n  switch (\"undefined\" === typeof raw ? \"undefined\" : _typeof(raw)) {\n    case \"string\":\n      return raw.split(/\\s+/, 2);\n    case \"object\":\n      return [raw.x || raw.h, raw.y || raw.v];\n    case \"number\":\n      return [raw];\n    default:\n      return raw;\n  }\n};\nvar normalizeKey = function normalizeKey(id) {\n  var key = (0, _type.isString)(id) ? id : id.toString();\n  var arr = key.match(/[^a-zA-Z0-9_]/g);\n  arr && (0, _iterator.each)(arr, function (_, sign) {\n    key = key.replace(sign, \"__\" + sign.charCodeAt() + \"__\");\n  });\n  return key;\n};\nvar denormalizeKey = function denormalizeKey(key) {\n  var arr = key.match(/__\\d+__/g);\n  arr && arr.forEach(function (char) {\n    var charCode = parseInt(char.replace(\"__\", \"\"));\n    key = key.replace(char, String.fromCharCode(charCode));\n  });\n  return key;\n};\nvar isArraysEqualByValue = function isArraysEqualByValue(array1, array2, deep) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n  for (var i = 0; i < array1.length; i++) {\n    if (!equalByValue(array1[i], array2[i], deep + 1)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar isObjectsEqualByValue = function isObjectsEqualByValue(object1, object2, deep) {\n  for (var propertyName in object1) {\n    if (Object.prototype.hasOwnProperty.call(object1, propertyName) && !equalByValue(object1[propertyName], object2[propertyName], deep + 1)) {\n      return false;\n    }\n  }\n  for (var _propertyName in object2) {\n    if (!(_propertyName in object1)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar pairToObject = function pairToObject(raw, preventRound) {\n  var pair = splitPair(raw);\n  var h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);\n  var v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);\n  if (!isFinite(h)) {\n    h = 0;\n  }\n  if (!isFinite(v)) {\n    v = h;\n  }\n  return {\n    h: h,\n    v: v\n  };\n};\nvar maxEqualityDeep = 3;\nvar equalByValue = function equalByValue(object1, object2, deep) {\n  deep = deep || 0;\n  object1 = (0, _data.toComparable)(object1, true);\n  object2 = (0, _data.toComparable)(object2, true);\n  if (object1 === object2 || deep >= maxEqualityDeep) {\n    return true;\n  }\n  if ((0, _type.isObject)(object1) && (0, _type.isObject)(object2)) {\n    return isObjectsEqualByValue(object1, object2, deep);\n  } else {\n    if (Array.isArray(object1) && Array.isArray(object2)) {\n      return isArraysEqualByValue(object1, object2, deep);\n    }\n  }\n  return false;\n};\nvar getKeyHash = function getKeyHash(key) {\n  if (key instanceof _guid2.default) {\n    return key.toString();\n  } else {\n    if ((0, _type.isObject)(key) || Array.isArray(key)) {\n      try {\n        var keyHash = JSON.stringify(key);\n        return \"{}\" === keyHash ? key : keyHash;\n      } catch (e) {\n        return key;\n      }\n    }\n  }\n  return key;\n};\nvar escapeRegExp = function escapeRegExp(string) {\n  return string.replace(/[[\\]{}\\-()*+?.\\\\^$|\\s]/g, \"\\\\$&\");\n};\nvar applyServerDecimalSeparator = function applyServerDecimalSeparator(value) {\n  var separator = (0, _config2.default)().serverDecimalSeparator;\n  if ((0, _type.isDefined)(value)) {\n    value = value.toString().replace(\".\", separator);\n  }\n  return value;\n};\nvar noop = function noop() {};\nvar asyncNoop = function asyncNoop() {\n  return new _deferred.Deferred().resolve().promise();\n};\nvar grep = function grep(elements, checkFunction, invert) {\n  var result = [];\n  var check = void 0;\n  var expectedCheck = !invert;\n  for (var i = 0; i < elements.length; i++) {\n    check = !!checkFunction(elements[i], i);\n    if (check === expectedCheck) {\n      result.push(elements[i]);\n    }\n  }\n  return result;\n};\nexports.ensureDefined = ensureDefined;\nexports.executeAsync = executeAsync;\nexports.deferRender = deferRender;\nexports.deferRenderer = deferRenderer;\nexports.deferUpdate = deferUpdate;\nexports.deferUpdater = deferUpdater;\nexports.pairToObject = pairToObject;\nexports.splitPair = splitPair;\nexports.findBestMatches = findBestMatches;\nexports.normalizeKey = normalizeKey;\nexports.denormalizeKey = denormalizeKey;\nexports.equalByValue = equalByValue;\nexports.getKeyHash = getKeyHash;\nexports.escapeRegExp = escapeRegExp;\nexports.applyServerDecimalSeparator = applyServerDecimalSeparator;\nexports.noop = noop;\nexports.asyncNoop = asyncNoop;\nexports.grep = grep;","map":null,"metadata":{},"sourceType":"script"}