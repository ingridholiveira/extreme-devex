{"ast":null,"code":"/**\r\n * DevExtreme (localization/ldml/date.format.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar ARABIC_COMMA = \"\\u060C\",\n  FORMAT_SEPARATORS = \" .,:;/\\\\<>()-[]\" + ARABIC_COMMA,\n  ARABIC_ZERO_CODE = 1632;\nvar checkDigit = function checkDigit(char) {\n  var code = char && char.charCodeAt(0);\n  return char >= \"0\" && char <= \"9\" || code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10;\n};\nvar checkPatternContinue = function checkPatternContinue(text, index, isDigit) {\n  var char = text[index],\n    prevChar = text[index - 1],\n    nextChar = text[index + 1];\n  if (!isDigit) {\n    if (\".\" === char || \" \" === char && \".\" === prevChar) {\n      return true;\n    }\n    if (\"-\" === char && !checkDigit(nextChar)) {\n      return true;\n    }\n  }\n  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char);\n};\nvar getPatternStartIndex = function getPatternStartIndex(defaultPattern, index) {\n  if (!checkDigit(defaultPattern[index])) {\n    while (index > 0 && !checkDigit(defaultPattern[index - 1]) && (\".\" === defaultPattern[index - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index - 1]) < 0)) {\n      index--;\n    }\n  }\n  return index;\n};\nvar getDifference = function getDifference(defaultPattern, patterns, processedIndexes, isDigit) {\n  var i = 0,\n    result = [];\n  var patternsFilter = function patternsFilter(pattern) {\n    return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit);\n  };\n  if (!Array.isArray(patterns)) {\n    patterns = [patterns];\n  }\n  for (i = 0; i < defaultPattern.length; i++) {\n    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {\n      i = getPatternStartIndex(defaultPattern, i);\n      do {\n        isDigit = checkDigit(defaultPattern[i]);\n        if (!result.length && !isDigit && checkDigit(patterns[0][i])) {\n          break;\n        }\n        result.push(i);\n        processedIndexes.unshift(i);\n        i++;\n      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, i, isDigit));\n      break;\n    }\n  }\n  if (1 === result.length && (\"0\" === defaultPattern[processedIndexes[0] - 1] || \"\\u0660\" === defaultPattern[processedIndexes[0] - 1])) {\n    processedIndexes.unshift(processedIndexes[0] - 1);\n  }\n  return result;\n};\nvar replaceCharsCore = function replaceCharsCore(pattern, indexes, char, patternPositions) {\n  var baseCharIndex = indexes[0];\n  var patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;\n  indexes.forEach(function (_, index) {\n    pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1);\n  });\n  if (1 === indexes.length) {\n    pattern = pattern.replace(\"0\" + char, char + char);\n    pattern = pattern.replace(\"\\u0660\" + char, char + char);\n  }\n  return pattern;\n};\nvar replaceChars = function replaceChars(pattern, indexes, char, patternPositions) {\n  var i, index, patternIndex;\n  if (!checkDigit(pattern[indexes[0]] || \"0\")) {\n    var letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);\n    while (indexes.length > letterCount) {\n      index = indexes.pop();\n      patternIndex = patternPositions[index];\n      patternPositions[index] = -1;\n      for (i = index + 1; i < patternPositions.length; i++) {\n        patternPositions[i]--;\n      }\n      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);\n    }\n    index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;\n    while (indexes.length < letterCount) {\n      indexes.push(indexes[indexes.length - 1] + 1);\n      for (i = index; i < patternPositions.length; i++) {\n        patternPositions[i]++;\n      }\n      pattern = pattern.substr(0, patternIndex) + \" \" + pattern.substr(patternIndex);\n    }\n  }\n  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);\n  return pattern;\n};\nvar formatValue = function formatValue(value, formatter) {\n  if (Array.isArray(value)) {\n    return value.map(function (value) {\n      return (formatter(value) || \"\").toString();\n    });\n  }\n  return (formatter(value) || \"\").toString();\n};\nvar ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;\nvar escapeChars = function escapeChars(pattern, defaultPattern, processedIndexes, patternPositions) {\n  var escapeIndexes = defaultPattern.split(\"\").map(function (char, index) {\n    if (processedIndexes.indexOf(index) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || \"'\" === char)) {\n      return patternPositions[index];\n    }\n    return -1;\n  });\n  pattern = pattern.split(\"\").map(function (char, index) {\n    var result = char,\n      isCurrentCharEscaped = escapeIndexes.indexOf(index) >= 0,\n      isPrevCharEscaped = index > 0 && escapeIndexes.indexOf(index - 1) >= 0,\n      isNextCharEscaped = escapeIndexes.indexOf(index + 1) >= 0;\n    if (isCurrentCharEscaped) {\n      if (!isPrevCharEscaped) {\n        result = \"'\" + result;\n      }\n      if (!isNextCharEscaped) {\n        result += \"'\";\n      }\n    }\n    return result;\n  }).join(\"\");\n  return pattern;\n};\nvar getFormat = function getFormat(formatter) {\n  var processedIndexes = [],\n    defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter),\n    patternPositions = defaultPattern.split(\"\").map(function (_, index) {\n      return index;\n    }),\n    result = defaultPattern,\n    replacedPatterns = {},\n    datePatterns = [{\n      date: new Date(2009, 8, 8, 6, 5, 4, 100),\n      pattern: \"S\"\n    }, {\n      date: new Date(2009, 8, 8, 6, 5, 2),\n      pattern: \"s\"\n    }, {\n      date: new Date(2009, 8, 8, 6, 2, 4),\n      pattern: \"m\"\n    }, {\n      date: new Date(2009, 8, 8, 18, 5, 4),\n      pattern: \"H\",\n      isDigit: true\n    }, {\n      date: new Date(2009, 8, 8, 2, 5, 4),\n      pattern: \"h\",\n      isDigit: true\n    }, {\n      date: new Date(2009, 8, 8, 18, 5, 4),\n      pattern: \"a\",\n      isDigit: false\n    }, {\n      date: new Date(2009, 8, 1, 6, 5, 4),\n      pattern: \"d\"\n    }, {\n      date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],\n      pattern: \"E\"\n    }, {\n      date: new Date(2009, 9, 6, 6, 5, 4),\n      pattern: \"M\"\n    }, {\n      date: new Date(1998, 8, 8, 6, 5, 4),\n      pattern: \"y\"\n    }];\n  if (!result) {\n    return;\n  }\n  datePatterns.forEach(function (test) {\n    var diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit),\n      pattern = \"M\" === test.pattern && !replacedPatterns.d ? \"L\" : test.pattern;\n    result = replaceChars(result, diff, pattern, patternPositions);\n    replacedPatterns[pattern] = diff.length;\n  });\n  result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);\n  if (processedIndexes.length) {\n    return result;\n  }\n};\nexports.getFormat = getFormat;","map":null,"metadata":{},"sourceType":"script"}