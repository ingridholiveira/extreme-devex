{"ast":null,"code":"/**\r\n * DevExtreme (ui/popover.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _typeof = \"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar $ = require(\"../core/renderer\"),\n  windowUtils = require(\"../core/utils/window\"),\n  window = windowUtils.getWindow(),\n  domAdapter = require(\"../core/dom_adapter\"),\n  eventsEngine = require(\"../events/core/events_engine\"),\n  registerComponent = require(\"../core/component_registrator\"),\n  commonUtils = require(\"../core/utils/common\"),\n  extend = require(\"../core/utils/extend\").extend,\n  translator = require(\"../animation/translator\"),\n  positionUtils = require(\"../animation/position\"),\n  typeUtils = require(\"../core/utils/type\"),\n  mathUtils = require(\"../core/utils/math\"),\n  eventUtils = require(\"../events/utils\"),\n  Popup = require(\"./popup\");\nvar POPOVER_CLASS = \"dx-popover\",\n  POPOVER_WRAPPER_CLASS = \"dx-popover-wrapper\",\n  POPOVER_ARROW_CLASS = \"dx-popover-arrow\",\n  POPOVER_WITHOUT_TITLE_CLASS = \"dx-popover-without-title\",\n  POSITION_FLIP_MAP = {\n    left: \"right\",\n    top: \"bottom\",\n    right: \"left\",\n    bottom: \"top\",\n    center: \"center\"\n  },\n  WEIGHT_OF_SIDES = {\n    left: -1,\n    top: -1,\n    center: 0,\n    right: 1,\n    bottom: 1\n  },\n  POSITION_ALIASES = {\n    top: {\n      my: \"bottom center\",\n      at: \"top center\",\n      collision: \"fit flip\"\n    },\n    bottom: {\n      my: \"top center\",\n      at: \"bottom center\",\n      collision: \"fit flip\"\n    },\n    right: {\n      my: \"left center\",\n      at: \"right center\",\n      collision: \"flip fit\"\n    },\n    left: {\n      my: \"right center\",\n      at: \"left center\",\n      collision: \"flip fit\"\n    }\n  },\n  SIDE_BORDER_WIDTH_STYLES = {\n    left: \"borderLeftWidth\",\n    top: \"borderTopWidth\",\n    right: \"borderRightWidth\",\n    bottom: \"borderBottomWidth\"\n  },\n  getEventName = function getEventName(that, optionName) {\n    var optionValue = that.option(optionName);\n    return getEventNameByOption(optionValue);\n  },\n  getEventNameByOption = function getEventNameByOption(optionValue) {\n    return typeUtils.isObject(optionValue) ? optionValue.name : optionValue;\n  },\n  getEventDelay = function getEventDelay(that, optionName) {\n    var optionValue = that.option(optionName);\n    return typeUtils.isObject(optionValue) && optionValue.delay;\n  },\n  attachEvent = function attachEvent(that, name) {\n    var delay,\n      action,\n      handler,\n      eventName,\n      target = that.option(\"target\"),\n      event = getEventName(that, name + \"Event\");\n    if (!event || that.option(\"disabled\")) {\n      return;\n    }\n    eventName = eventUtils.addNamespace(event, that.NAME);\n    action = that._createAction(function () {\n      delay = getEventDelay(that, name + \"Event\");\n      this._clearEventTimeout(\"hide\" === name);\n      if (delay) {\n        this._timeouts[name] = setTimeout(function () {\n          that[name]();\n        }, delay);\n      } else {\n        that[name]();\n      }\n    }.bind(that), {\n      validatingTargetName: \"target\"\n    });\n    handler = function handler(e) {\n      action({\n        event: e,\n        target: $(e.currentTarget)\n      });\n    };\n    if (target.jquery || target.nodeType || typeUtils.isWindow(target)) {\n      that[\"_\" + name + \"EventHandler\"] = void 0;\n      eventsEngine.on(target, eventName, handler);\n    } else {\n      that[\"_\" + name + \"EventHandler\"] = handler;\n      eventsEngine.on(domAdapter.getDocument(), eventName, target, handler);\n    }\n  },\n  detachEvent = function detachEvent(that, target, name, event) {\n    var eventName = event || getEventName(that, name + \"Event\");\n    if (!eventName) {\n      return;\n    }\n    eventName = eventUtils.addNamespace(eventName, that.NAME);\n    if (that[\"_\" + name + \"EventHandler\"]) {\n      eventsEngine.off(domAdapter.getDocument(), eventName, target, that[\"_\" + name + \"EventHandler\"]);\n    } else {\n      eventsEngine.off($(target), eventName);\n    }\n  };\nvar Popover = Popup.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      target: window,\n      shading: false,\n      position: \"bottom\",\n      closeOnOutsideClick: true,\n      animation: {\n        show: {\n          type: \"fade\",\n          from: 0,\n          to: 1\n        },\n        hide: {\n          type: \"fade\",\n          to: 0\n        }\n      },\n      showTitle: false,\n      width: \"auto\",\n      height: \"auto\",\n      dragEnabled: false,\n      resizeEnabled: false,\n      fullScreen: false,\n      closeOnTargetScroll: true,\n      arrowPosition: \"\",\n      arrowOffset: 0,\n      boundaryOffset: {\n        h: 10,\n        v: 10\n      }\n    });\n  },\n  _defaultOptionsRules: function _defaultOptionsRules() {\n    return [{\n      device: {\n        platform: \"ios\"\n      },\n      options: {\n        arrowPosition: {\n          boundaryOffset: {\n            h: 20,\n            v: -10\n          },\n          collision: \"fit\"\n        }\n      }\n    }, {\n      device: function device() {\n        return !windowUtils.hasWindow();\n      },\n      options: {\n        animation: null\n      }\n    }];\n  },\n  _init: function _init() {\n    this.callBase();\n    this._renderArrow();\n    this._timeouts = {};\n    this.$element().addClass(POPOVER_CLASS);\n    this._wrapper().addClass(POPOVER_WRAPPER_CLASS);\n  },\n  _render: function _render() {\n    this.callBase.apply(this, arguments);\n    this._detachEvents(this.option(\"target\"));\n    this._attachEvents();\n  },\n  _detachEvents: function _detachEvents(target) {\n    detachEvent(this, target, \"show\");\n    detachEvent(this, target, \"hide\");\n  },\n  _attachEvents: function _attachEvents() {\n    attachEvent(this, \"show\");\n    attachEvent(this, \"hide\");\n  },\n  _renderArrow: function _renderArrow() {\n    this._$arrow = $(\"<div>\").addClass(POPOVER_ARROW_CLASS).prependTo(this.overlayContent());\n  },\n  _documentDownHandler: function _documentDownHandler(e) {\n    if (this._isOutsideClick(e)) {\n      return this.callBase(e);\n    }\n    return true;\n  },\n  _isOutsideClick: function _isOutsideClick(e) {\n    return !$(e.target).closest(this.option(\"target\")).length;\n  },\n  _animate: function _animate(animation) {\n    if (animation && animation.to && \"object\" === _typeof(animation.to)) {\n      extend(animation.to, {\n        position: this._getContainerPosition()\n      });\n    }\n    this.callBase.apply(this, arguments);\n  },\n  _stopAnimation: function _stopAnimation() {\n    this.callBase.apply(this, arguments);\n  },\n  _renderTitle: function _renderTitle() {\n    this._wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option(\"showTitle\"));\n    this.callBase();\n  },\n  _renderPosition: function _renderPosition() {\n    this.callBase();\n    this._renderOverlayPosition();\n  },\n  _renderOverlayBoundaryOffset: commonUtils.noop,\n  _renderOverlayPosition: function _renderOverlayPosition() {\n    this._resetOverlayPosition();\n    this._updateContentSize();\n    var contentPosition = this._getContainerPosition();\n    var resultLocation = positionUtils.setup(this._$content, contentPosition);\n    var positionSide = this._getSideByLocation(resultLocation);\n    this._togglePositionClass(\"dx-position-\" + positionSide);\n    this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);\n    var isArrowVisible = this._isHorizontalSide() || this._isVerticalSide();\n    if (isArrowVisible) {\n      this._renderArrowPosition(positionSide);\n    }\n  },\n  _resetOverlayPosition: function _resetOverlayPosition() {\n    this._setContentHeight(true);\n    this._togglePositionClass(\"dx-position-\" + this._positionSide);\n    translator.move(this._$content, {\n      left: 0,\n      top: 0\n    });\n    this._$arrow.css({\n      top: \"auto\",\n      right: \"auto\",\n      bottom: \"auto\",\n      left: \"auto\"\n    });\n  },\n  _updateContentSize: function _updateContentSize() {\n    if (!this._$popupContent) {\n      return;\n    }\n    var containerLocation = positionUtils.calculate(this._$content, this._getContainerPosition());\n    if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {\n      var newContainerWidth = this._$content.width() - containerLocation.h.oversize;\n      this._$content.width(newContainerWidth);\n    }\n    if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {\n      var newOverlayContentHeight = this._$content.height() - containerLocation.v.oversize,\n        newPopupContentHeight = this._$popupContent.height() - containerLocation.v.oversize;\n      this._$content.height(newOverlayContentHeight);\n      this._$popupContent.height(newPopupContentHeight);\n    }\n  },\n  _getContainerPosition: function _getContainerPosition() {\n    var offset = commonUtils.pairToObject(this._position.offset || \"\");\n    var hOffset = offset.h;\n    var vOffset = offset.v;\n    var isVerticalSide = this._isVerticalSide();\n    var isHorizontalSide = this._isHorizontalSide();\n    if (isVerticalSide || isHorizontalSide) {\n      var isPopoverInside = this._isPopoverInside();\n      var sign = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];\n      var arrowSize = isVerticalSide ? this._$arrow.height() : this._$arrow.width();\n      var arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);\n      var arrowOffset = sign * (arrowSize - arrowSizeCorrection);\n      isVerticalSide ? vOffset += arrowOffset : hOffset += arrowOffset;\n    }\n    return extend({}, this._position, {\n      offset: hOffset + \" \" + vOffset\n    });\n  },\n  _getContentBorderWidth: function _getContentBorderWidth(side) {\n    var borderWidth = this._$content.css(SIDE_BORDER_WIDTH_STYLES[side]);\n    return parseInt(borderWidth) || 0;\n  },\n  _getSideByLocation: function _getSideByLocation(location) {\n    var isFlippedByVertical = location.v.flip;\n    var isFlippedByHorizontal = location.h.flip;\n    return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionSide] : this._positionSide;\n  },\n  _togglePositionClass: function _togglePositionClass(positionClass) {\n    this._$wrapper.removeClass(\"dx-position-left dx-position-right dx-position-top dx-position-bottom\").addClass(positionClass);\n  },\n  _toggleFlippedClass: function _toggleFlippedClass(isFlippedHorizontal, isFlippedVertical) {\n    this._$wrapper.toggleClass(\"dx-popover-flipped-horizontal\", isFlippedHorizontal).toggleClass(\"dx-popover-flipped-vertical\", isFlippedVertical);\n  },\n  _renderArrowPosition: function _renderArrowPosition(side) {\n    this._$arrow.css(POSITION_FLIP_MAP[side], -(this._isVerticalSide(side) ? this._$arrow.height() : this._$arrow.width()));\n    var axis = this._isVerticalSide(side) ? \"left\" : \"top\";\n    var sizeProperty = this._isVerticalSide(side) ? \"outerWidth\" : \"outerHeight\";\n    var $target = $(this._position.of);\n    var targetOffset = positionUtils.offset($target) || {\n      top: 0,\n      left: 0\n    };\n    var contentOffset = positionUtils.offset(this._$content);\n    var arrowSize = this._$arrow[sizeProperty]();\n    var contentLocation = contentOffset[axis];\n    var contentSize = this._$content[sizeProperty]();\n    var targetLocation = targetOffset[axis];\n    var targetSize = $target.get(0).preventDefault ? 0 : $target[sizeProperty]();\n    var min = Math.max(contentLocation, targetLocation);\n    var max = Math.min(contentLocation + contentSize, targetLocation + targetSize);\n    var arrowLocation;\n    if (\"start\" === this.option(\"arrowPosition\")) {\n      arrowLocation = min - contentLocation;\n    } else {\n      if (\"end\" === this.option(\"arrowPosition\")) {\n        arrowLocation = max - contentLocation - arrowSize;\n      } else {\n        arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2;\n      }\n    }\n    var borderWidth = this._getContentBorderWidth(side);\n    var finalArrowLocation = mathUtils.fitIntoRange(arrowLocation - borderWidth + this.option(\"arrowOffset\"), borderWidth, contentSize - arrowSize - 2 * borderWidth);\n    this._$arrow.css(axis, finalArrowLocation);\n  },\n  _isPopoverInside: function _isPopoverInside() {\n    var position = this._transformStringPosition(this.option(\"position\"), POSITION_ALIASES);\n    var my = positionUtils.setup.normalizeAlign(position.my);\n    var at = positionUtils.setup.normalizeAlign(position.at);\n    return my.h === at.h && my.v === at.v;\n  },\n  _setContentHeight: function _setContentHeight(fullUpdate) {\n    if (fullUpdate) {\n      this.callBase();\n    }\n  },\n  _renderShadingPosition: function _renderShadingPosition() {\n    if (this.option(\"shading\")) {\n      this._$wrapper.css({\n        top: 0,\n        left: 0\n      });\n    }\n  },\n  _normalizePosition: function _normalizePosition() {\n    var position = extend({}, this._transformStringPosition(this.option(\"position\"), POSITION_ALIASES));\n    if (!position.of) {\n      position.of = this.option(\"target\");\n    }\n    if (!position.collision) {\n      position.collision = \"flip\";\n    }\n    if (!position.boundaryOffset) {\n      position.boundaryOffset = this.option(\"boundaryOffset\");\n    }\n    this._positionSide = this._getDisplaySide(position);\n    this._position = position;\n  },\n  _getDisplaySide: function _getDisplaySide(position) {\n    var my = positionUtils.setup.normalizeAlign(position.my),\n      at = positionUtils.setup.normalizeAlign(position.at);\n    var weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1,\n      horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]),\n      verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);\n    return horizontalWeight > verticalWeight ? at.h : at.v;\n  },\n  _isVerticalSide: function _isVerticalSide(side) {\n    side = side || this._positionSide;\n    return \"top\" === side || \"bottom\" === side;\n  },\n  _isHorizontalSide: function _isHorizontalSide(side) {\n    side = side || this._positionSide;\n    return \"left\" === side || \"right\" === side;\n  },\n  _clearEventTimeout: function _clearEventTimeout(visibility) {\n    clearTimeout(this._timeouts[visibility ? \"show\" : \"hide\"]);\n  },\n  _clean: function _clean() {\n    this._detachEvents(this.option(\"target\"));\n    this.callBase.apply(this, arguments);\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"boundaryOffset\":\n      case \"arrowPosition\":\n      case \"arrowOffset\":\n        this._renderGeometry();\n        break;\n      case \"fullScreen\":\n        if (args.value) {\n          this.option(\"fullScreen\", false);\n        }\n        break;\n      case \"target\":\n        args.previousValue && this._detachEvents(args.previousValue);\n        this.callBase(args);\n        break;\n      case \"showEvent\":\n      case \"hideEvent\":\n        var name = args.name.substring(0, 4),\n          event = getEventNameByOption(args.previousValue);\n        this.hide();\n        detachEvent(this, this.option(\"target\"), name, event);\n        attachEvent(this, name);\n        break;\n      case \"visible\":\n        this._clearEventTimeout(args.value);\n        this.callBase(args);\n        break;\n      default:\n        this.callBase(args);\n    }\n  },\n  show: function show(target) {\n    if (target) {\n      this.option(\"target\", target);\n    }\n    return this.callBase();\n  }\n});\nregisterComponent(\"dxPopover\", Popover);\nmodule.exports = Popover;\nmodule.exports.default = module.exports;","map":null,"metadata":{},"sourceType":"script"}