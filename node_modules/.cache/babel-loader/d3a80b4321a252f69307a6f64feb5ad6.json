{"ast":null,"code":"/**\r\n * DevExtreme (core/utils/callbacks.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar Callback = function Callback(options) {\n  this._options = options || {};\n  this._list = [];\n  this._queue = [];\n  this._firing = false;\n  this._fired = false;\n  this._firingIndexes = [];\n};\nCallback.prototype._fireCore = function (context, args) {\n  var firingIndexes = this._firingIndexes,\n    list = this._list,\n    stopOnFalse = this._options.stopOnFalse,\n    step = firingIndexes.length;\n  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {\n    var result = list[firingIndexes[step]].apply(context, args);\n    if (false === result && stopOnFalse) {\n      break;\n    }\n  }\n  firingIndexes.pop();\n};\nCallback.prototype.add = function (fn) {\n  if (\"function\" === typeof fn && (!this._options.unique || !this.has(fn))) {\n    this._list.push(fn);\n  }\n  return this;\n};\nCallback.prototype.remove = function (fn) {\n  var list = this._list,\n    firingIndexes = this._firingIndexes,\n    index = list.indexOf(fn);\n  if (index > -1) {\n    list.splice(index, 1);\n    if (this._firing && firingIndexes.length) {\n      for (var step = 0; step < firingIndexes.length; step++) {\n        if (index <= firingIndexes[step]) {\n          firingIndexes[step]--;\n        }\n      }\n    }\n  }\n  return this;\n};\nCallback.prototype.has = function (fn) {\n  var list = this._list;\n  return fn ? list.indexOf(fn) > -1 : !!list.length;\n};\nCallback.prototype.empty = function (fn) {\n  this._list = [];\n  return this;\n};\nCallback.prototype.fireWith = function (context, args) {\n  var queue = this._queue;\n  args = args || [];\n  args = args.slice ? args.slice() : args;\n  if (this._options.syncStrategy) {\n    this._firing = true;\n    this._fireCore(context, args);\n  } else {\n    queue.push([context, args]);\n    if (this._firing) {\n      return;\n    }\n    this._firing = true;\n    while (queue.length) {\n      var memory = queue.shift();\n      this._fireCore(memory[0], memory[1]);\n    }\n  }\n  this._firing = false;\n  this._fired = true;\n  return this;\n};\nCallback.prototype.fire = function () {\n  this.fireWith(this, arguments);\n};\nCallback.prototype.fired = function () {\n  return this._fired;\n};\nvar Callbacks = function Callbacks(options) {\n  return new Callback(options);\n};\nmodule.exports = Callbacks;","map":null,"metadata":{},"sourceType":"script"}