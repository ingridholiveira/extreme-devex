{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.events.emitter.gesture.scroll.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar eventsEngine = require(\"../../events/core/events_engine\"),\n  Class = require(\"../../core/class\"),\n  abstract = Class.abstract,\n  eventUtils = require(\"../../events/utils\"),\n  GestureEmitter = require(\"../../events/gesture/emitter.gesture\"),\n  registerEmitter = require(\"../../events/core/emitter_registrator\"),\n  animationFrame = require(\"../../animation/frame\"),\n  realDevice = require(\"../../core/devices\").real(),\n  compareVersions = require(\"../../core/utils/version\").compare;\nvar SCROLL_INIT_EVENT = \"dxscrollinit\",\n  SCROLL_START_EVENT = \"dxscrollstart\",\n  SCROLL_MOVE_EVENT = \"dxscroll\",\n  SCROLL_END_EVENT = \"dxscrollend\",\n  SCROLL_STOP_EVENT = \"dxscrollstop\",\n  SCROLL_CANCEL_EVENT = \"dxscrollcancel\";\nvar Locker = Class.inherit(function () {\n  var NAMESPACED_SCROLL_EVENT = eventUtils.addNamespace(\"scroll\", \"dxScrollEmitter\");\n  return {\n    ctor: function ctor(element) {\n      this._element = element;\n      this._locked = false;\n      var that = this;\n      this._proxiedScroll = function (e) {\n        that._scroll(e);\n      };\n      eventsEngine.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);\n    },\n    _scroll: abstract,\n    check: function check(e, callback) {\n      if (this._locked) {\n        callback();\n      }\n    },\n    dispose: function dispose() {\n      eventsEngine.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);\n    }\n  };\n}());\nvar TimeoutLocker = Locker.inherit(function () {\n  return {\n    ctor: function ctor(element, timeout) {\n      this.callBase(element);\n      this._timeout = timeout;\n    },\n    _scroll: function _scroll() {\n      this._prepare();\n      this._forget();\n    },\n    _prepare: function _prepare() {\n      if (this._timer) {\n        this._clearTimer();\n      }\n      this._locked = true;\n    },\n    _clearTimer: function _clearTimer() {\n      clearTimeout(this._timer);\n      this._locked = false;\n      this._timer = null;\n    },\n    _forget: function _forget() {\n      var that = this;\n      this._timer = setTimeout(function () {\n        that._clearTimer();\n      }, this._timeout);\n    },\n    dispose: function dispose() {\n      this.callBase();\n      this._clearTimer();\n    }\n  };\n}());\nvar WheelLocker = TimeoutLocker.inherit(function () {\n  var WHEEL_UNLOCK_TIMEOUT = 400;\n  return {\n    ctor: function ctor(element) {\n      this.callBase(element, WHEEL_UNLOCK_TIMEOUT);\n      this._lastWheelDirection = null;\n    },\n    check: function check(e, callback) {\n      this._checkDirectionChanged(e);\n      this.callBase(e, callback);\n    },\n    _checkDirectionChanged: function _checkDirectionChanged(e) {\n      if (!eventUtils.isDxMouseWheelEvent(e)) {\n        this._lastWheelDirection = null;\n        return;\n      }\n      var direction = e.shiftKey || false,\n        directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;\n      this._lastWheelDirection = direction;\n      this._locked = this._locked && !directionChange;\n    }\n  };\n}());\nvar PointerLocker = TimeoutLocker.inherit(function () {\n  var POINTER_UNLOCK_TIMEOUT = 400;\n  return {\n    ctor: function ctor(element) {\n      this.callBase(element, POINTER_UNLOCK_TIMEOUT);\n    }\n  };\n}());\n!function () {\n  var ios8_greater = realDevice.ios && compareVersions(realDevice.version, [8]) >= 0,\n    android5_greater = realDevice.android && compareVersions(realDevice.version, [5]) >= 0;\n  if (!(ios8_greater || android5_greater)) {\n    return;\n  }\n  PointerLocker = Locker.inherit(function () {\n    return {\n      _scroll: function _scroll() {\n        this._locked = true;\n        var that = this;\n        animationFrame.cancelAnimationFrame(this._scrollFrame);\n        this._scrollFrame = animationFrame.requestAnimationFrame(function () {\n          that._locked = false;\n        });\n      },\n      check: function check(e, callback) {\n        animationFrame.cancelAnimationFrame(this._scrollFrame);\n        animationFrame.cancelAnimationFrame(this._checkFrame);\n        var that = this,\n          callBase = this.callBase;\n        this._checkFrame = animationFrame.requestAnimationFrame(function () {\n          callBase.call(that, e, callback);\n          that._locked = false;\n        });\n      },\n      dispose: function dispose() {\n        this.callBase();\n        animationFrame.cancelAnimationFrame(this._scrollFrame);\n        animationFrame.cancelAnimationFrame(this._checkFrame);\n      }\n    };\n  }());\n}();\nvar ScrollEmitter = GestureEmitter.inherit(function () {\n  var INERTIA_TIMEOUT = 100,\n    VELOCITY_CALC_TIMEOUT = 200,\n    FRAME_DURATION = Math.round(1e3 / 60);\n  return {\n    ctor: function ctor(element) {\n      this.callBase.apply(this, arguments);\n      this.direction = \"both\";\n      this._pointerLocker = new PointerLocker(element);\n      this._wheelLocker = new WheelLocker(element);\n    },\n    validate: function validate() {\n      return true;\n    },\n    configure: function configure(data) {\n      if (data.scrollTarget) {\n        this._pointerLocker.dispose();\n        this._wheelLocker.dispose();\n        this._pointerLocker = new PointerLocker(data.scrollTarget);\n        this._wheelLocker = new WheelLocker(data.scrollTarget);\n      }\n      this.callBase(data);\n    },\n    _init: function _init(e) {\n      this._wheelLocker.check(e, function () {\n        if (eventUtils.isDxMouseWheelEvent(e)) {\n          this._accept(e);\n        }\n      }.bind(this));\n      this._pointerLocker.check(e, function () {\n        var skipCheck = this.isNative && eventUtils.isMouseEvent(e);\n        if (!eventUtils.isDxMouseWheelEvent(e) && !skipCheck) {\n          this._accept(e);\n        }\n      }.bind(this));\n      this._fireEvent(SCROLL_INIT_EVENT, e);\n      this._prevEventData = eventUtils.eventData(e);\n    },\n    move: function move(e) {\n      this.callBase.apply(this, arguments);\n      e.isScrollingEvent = this.isNative || e.isScrollingEvent;\n    },\n    _start: function _start(e) {\n      this._savedEventData = eventUtils.eventData(e);\n      this._fireEvent(SCROLL_START_EVENT, e);\n      this._prevEventData = eventUtils.eventData(e);\n    },\n    _move: function _move(e) {\n      var currentEventData = eventUtils.eventData(e);\n      this._fireEvent(SCROLL_MOVE_EVENT, e, {\n        delta: eventUtils.eventDelta(this._prevEventData, currentEventData)\n      });\n      var eventDelta = eventUtils.eventDelta(this._savedEventData, currentEventData);\n      if (eventDelta.time > VELOCITY_CALC_TIMEOUT) {\n        this._savedEventData = this._prevEventData;\n      }\n      this._prevEventData = eventUtils.eventData(e);\n    },\n    _end: function _end(e) {\n      var endEventDelta = eventUtils.eventDelta(this._prevEventData, eventUtils.eventData(e));\n      var velocity = {\n        x: 0,\n        y: 0\n      };\n      if (!eventUtils.isDxMouseWheelEvent(e) && endEventDelta.time < INERTIA_TIMEOUT) {\n        var eventDelta = eventUtils.eventDelta(this._savedEventData, this._prevEventData),\n          velocityMultiplier = FRAME_DURATION / eventDelta.time;\n        velocity = {\n          x: eventDelta.x * velocityMultiplier,\n          y: eventDelta.y * velocityMultiplier\n        };\n      }\n      this._fireEvent(SCROLL_END_EVENT, e, {\n        velocity: velocity\n      });\n    },\n    _stop: function _stop(e) {\n      this._fireEvent(SCROLL_STOP_EVENT, e);\n    },\n    cancel: function cancel(e) {\n      this.callBase.apply(this, arguments);\n      this._fireEvent(SCROLL_CANCEL_EVENT, e);\n    },\n    dispose: function dispose() {\n      this.callBase.apply(this, arguments);\n      this._pointerLocker.dispose();\n      this._wheelLocker.dispose();\n    },\n    _clearSelection: function _clearSelection() {\n      if (this.isNative) {\n        return;\n      }\n      return this.callBase.apply(this, arguments);\n    },\n    _toggleGestureCover: function _toggleGestureCover() {\n      if (this.isNative) {\n        return;\n      }\n      return this.callBase.apply(this, arguments);\n    }\n  };\n}());\nregisterEmitter({\n  emitter: ScrollEmitter,\n  events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]\n});\nmodule.exports = {\n  init: SCROLL_INIT_EVENT,\n  start: SCROLL_START_EVENT,\n  move: SCROLL_MOVE_EVENT,\n  end: SCROLL_END_EVENT,\n  stop: SCROLL_STOP_EVENT,\n  cancel: SCROLL_CANCEL_EVENT\n};","map":null,"metadata":{},"sourceType":"script"}