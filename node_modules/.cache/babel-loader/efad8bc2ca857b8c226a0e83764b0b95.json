{"ast":null,"code":"/**\r\n * DevExtreme (data/custom_store.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../core/renderer\"),\n  dataUtils = require(\"./utils\"),\n  arrayUtils = require(\"./array_utils\"),\n  isFunction = require(\"../core/utils/type\").isFunction,\n  config = require(\"../core/config\"),\n  errors = require(\"./errors\").errors,\n  Store = require(\"./abstract_store\"),\n  arrayQuery = require(\"./array_query\"),\n  queryByOptions = require(\"./store_helper\").queryByOptions,\n  deferredUtils = require(\"../core/utils/deferred\"),\n  Deferred = deferredUtils.Deferred,\n  when = deferredUtils.when,\n  fromPromise = deferredUtils.fromPromise;\nvar TOTAL_COUNT = \"totalCount\",\n  LOAD = \"load\",\n  BY_KEY = \"byKey\",\n  INSERT = \"insert\",\n  UPDATE = \"update\",\n  REMOVE = \"remove\";\nfunction isPromise(obj) {\n  return obj && isFunction(obj.then);\n}\nfunction trivialPromise(value) {\n  return new Deferred().resolve(value).promise();\n}\nfunction ensureRequiredFuncOption(name, obj) {\n  if (!isFunction(obj)) {\n    throw errors.Error(\"E4011\", name);\n  }\n}\nfunction throwInvalidUserFuncResult(name) {\n  throw errors.Error(\"E4012\", name);\n}\nfunction createUserFuncFailureHandler(pendingDeferred) {\n  function errorMessageFromXhr(promiseArguments) {\n    var xhr = promiseArguments[0],\n      textStatus = promiseArguments[1];\n    if (!xhr || !xhr.getResponseHeader) {\n      return null;\n    }\n    return dataUtils.errorMessageFromXhr(xhr, textStatus);\n  }\n  return function (arg) {\n    var error;\n    if (arg instanceof Error) {\n      error = arg;\n    } else {\n      error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || \"Unknown error\");\n    }\n    if (error.message !== dataUtils.XHR_ERROR_UNLOAD) {\n      pendingDeferred.reject(error);\n    }\n  };\n}\nfunction invokeUserLoad(store, options) {\n  var userResult,\n    userFunc = store._loadFunc;\n  ensureRequiredFuncOption(LOAD, userFunc);\n  userResult = userFunc.apply(store, [options]);\n  if (Array.isArray(userResult)) {\n    userResult = trivialPromise(userResult);\n  } else {\n    if (null === userResult || void 0 === userResult) {\n      userResult = trivialPromise([]);\n    } else {\n      if (!isPromise(userResult)) {\n        throwInvalidUserFuncResult(LOAD);\n      }\n    }\n  }\n  return fromPromise(userResult);\n}\nfunction invokeUserTotalCountFunc(store, options) {\n  var userResult,\n    userFunc = store._totalCountFunc;\n  if (!isFunction(userFunc)) {\n    throw errors.Error(\"E4021\");\n  }\n  userResult = userFunc.apply(store, [options]);\n  if (!isPromise(userResult)) {\n    userResult = Number(userResult);\n    if (!isFinite(userResult)) {\n      throwInvalidUserFuncResult(TOTAL_COUNT);\n    }\n    userResult = trivialPromise(userResult);\n  }\n  return fromPromise(userResult);\n}\nfunction invokeUserByKeyFunc(store, key, extraOptions) {\n  var userResult,\n    userFunc = store._byKeyFunc;\n  ensureRequiredFuncOption(BY_KEY, userFunc);\n  userResult = userFunc.apply(store, [key, extraOptions]);\n  if (!isPromise(userResult)) {\n    userResult = trivialPromise(userResult);\n  }\n  return fromPromise(userResult);\n}\nfunction runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {\n  if (store.__rawData) {\n    continuation(store.__rawData);\n  } else {\n    var loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);\n    if (store._cacheRawData) {\n      store.__rawDataPromise = loadPromise;\n    }\n    loadPromise.always(function () {\n      delete store.__rawDataPromise;\n    }).done(function (rawData) {\n      if (store._cacheRawData) {\n        store.__rawData = rawData;\n      }\n      continuation(rawData);\n    }).fail(createUserFuncFailureHandler(pendingDeferred));\n  }\n}\nfunction runRawLoadWithQuery(pendingDeferred, store, options, countOnly) {\n  options = options || {};\n  var userFuncOptions = {};\n  if (\"userData\" in options) {\n    userFuncOptions.userData = options.userData;\n  }\n  runRawLoad(pendingDeferred, store, userFuncOptions, function (rawData) {\n    var itemsQuery,\n      totalCountQuery,\n      rawDataQuery = arrayQuery(rawData, {\n        errorHandler: store._errorHandler\n      }),\n      waitList = [];\n    var items, totalCount;\n    if (!countOnly) {\n      itemsQuery = queryByOptions(rawDataQuery, options);\n      if (itemsQuery === rawDataQuery) {\n        items = rawData.slice(0);\n      } else {\n        waitList.push(itemsQuery.enumerate().done(function (asyncResult) {\n          items = asyncResult;\n        }));\n      }\n    }\n    if (options.requireTotalCount || countOnly) {\n      totalCountQuery = queryByOptions(rawDataQuery, options, true);\n      if (totalCountQuery === rawDataQuery) {\n        totalCount = rawData.length;\n      } else {\n        waitList.push(totalCountQuery.count().done(function (asyncResult) {\n          totalCount = asyncResult;\n        }));\n      }\n    }\n    when.apply($, waitList).done(function () {\n      if (countOnly) {\n        pendingDeferred.resolve(totalCount);\n      } else {\n        if (options.requireTotalCount) {\n          pendingDeferred.resolve(items, {\n            totalCount: totalCount\n          });\n        } else {\n          pendingDeferred.resolve(items);\n        }\n      }\n    }).fail(function (x) {\n      pendingDeferred.reject(x);\n    });\n  });\n}\nfunction runRawLoadWithKey(pendingDeferred, store, key) {\n  runRawLoad(pendingDeferred, store, {}, function (rawData) {\n    var item,\n      keyExpr = store.key();\n    for (var i = 0, len = rawData.length; i < len; i++) {\n      item = rawData[i];\n      if (dataUtils.keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {\n        pendingDeferred.resolve(item);\n        return;\n      }\n    }\n    pendingDeferred.reject(errors.Error(\"E4009\"));\n  });\n}\nvar CustomStore = Store.inherit({\n  ctor: function ctor(options) {\n    options = options || {};\n    this.callBase(options);\n    this._useDefaultSearch = !!options.useDefaultSearch || \"raw\" === options.loadMode;\n    this._loadMode = options.loadMode;\n    this._cacheRawData = false !== options.cacheRawData;\n    this._loadFunc = options[LOAD];\n    this._totalCountFunc = options[TOTAL_COUNT];\n    this._byKeyFunc = options[BY_KEY];\n    this._insertFunc = options[INSERT];\n    this._updateFunc = options[UPDATE];\n    this._removeFunc = options[REMOVE];\n  },\n  createQuery: function createQuery() {\n    throw errors.Error(\"E4010\");\n  },\n  clearRawDataCache: function clearRawDataCache() {\n    delete this.__rawData;\n  },\n  _totalCountImpl: function _totalCountImpl(options) {\n    var d = new Deferred();\n    if (\"raw\" === this._loadMode && !this._totalCountFunc) {\n      runRawLoadWithQuery(d, this, options, true);\n    } else {\n      invokeUserTotalCountFunc(this, options).done(function (count) {\n        d.resolve(Number(count));\n      }).fail(createUserFuncFailureHandler(d));\n      d = this._addFailHandlers(d);\n    }\n    return d.promise();\n  },\n  _pushImpl: function _pushImpl(changes) {\n    if (this.__rawData) {\n      arrayUtils.applyBatch(this, this.__rawData, changes);\n    }\n  },\n  _loadImpl: function _loadImpl(options) {\n    var d = new Deferred();\n    if (\"raw\" === this._loadMode) {\n      runRawLoadWithQuery(d, this, options, false);\n    } else {\n      invokeUserLoad(this, options).done(function (data, extra) {\n        d.resolve(data, extra);\n      }).fail(createUserFuncFailureHandler(d));\n      d = this._addFailHandlers(d);\n    }\n    return d.promise();\n  },\n  _byKeyImpl: function _byKeyImpl(key, extraOptions) {\n    var d = new Deferred();\n    if (this._byKeyViaLoad()) {\n      this._requireKey();\n      runRawLoadWithKey(d, this, key);\n    } else {\n      invokeUserByKeyFunc(this, key, extraOptions).done(function (obj) {\n        d.resolve(obj);\n      }).fail(createUserFuncFailureHandler(d));\n    }\n    return d.promise();\n  },\n  _byKeyViaLoad: function _byKeyViaLoad() {\n    return \"raw\" === this._loadMode && !this._byKeyFunc;\n  },\n  _insertImpl: function _insertImpl(values) {\n    var userResult,\n      that = this,\n      userFunc = that._insertFunc,\n      d = new Deferred();\n    ensureRequiredFuncOption(INSERT, userFunc);\n    userResult = userFunc.apply(that, [values]);\n    if (!isPromise(userResult)) {\n      userResult = trivialPromise(userResult);\n    }\n    fromPromise(userResult).done(function (serverResponse) {\n      if (config().useLegacyStoreResult) {\n        d.resolve(values, serverResponse);\n      } else {\n        d.resolve(serverResponse || values, that.keyOf(serverResponse));\n      }\n    }).fail(createUserFuncFailureHandler(d));\n    return d.promise();\n  },\n  _updateImpl: function _updateImpl(key, values) {\n    var userResult,\n      userFunc = this._updateFunc,\n      d = new Deferred();\n    ensureRequiredFuncOption(UPDATE, userFunc);\n    userResult = userFunc.apply(this, [key, values]);\n    if (!isPromise(userResult)) {\n      userResult = trivialPromise(userResult);\n    }\n    fromPromise(userResult).done(function (serverResponse) {\n      if (config().useLegacyStoreResult) {\n        d.resolve(key, values);\n      } else {\n        d.resolve(serverResponse || values, key);\n      }\n    }).fail(createUserFuncFailureHandler(d));\n    return d.promise();\n  },\n  _removeImpl: function _removeImpl(key) {\n    var userResult,\n      userFunc = this._removeFunc,\n      d = new Deferred();\n    ensureRequiredFuncOption(REMOVE, userFunc);\n    userResult = userFunc.apply(this, [key]);\n    if (!isPromise(userResult)) {\n      userResult = trivialPromise();\n    }\n    fromPromise(userResult).done(function () {\n      d.resolve(key);\n    }).fail(createUserFuncFailureHandler(d));\n    return d.promise();\n  }\n});\nmodule.exports = CustomStore;\nmodule.exports.default = module.exports;","map":null,"metadata":{},"sourceType":"script"}