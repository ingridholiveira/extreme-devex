{"ast":null,"code":"/**\r\n * DevExtreme (ui/scroll_view/ui.scrollable.native.js)\r\n * Version: 19.2.2\r\n * Build date: Tue Oct 01 2019\r\n *\r\n * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\nvar _renderer2 = _interopRequireDefault(_renderer);\nvar _events_engine = require(\"../../events/core/events_engine\");\nvar _events_engine2 = _interopRequireDefault(_events_engine);\nvar _utils = require(\"../../events/utils\");\nvar _utils2 = _interopRequireDefault(_utils);\nvar _common = require(\"../../core/utils/common\");\nvar _iterator = require(\"../../core/utils/iterator\");\nvar _devices = require(\"../../core/devices\");\nvar _devices2 = _interopRequireDefault(_devices);\nvar _class = require(\"../../core/class\");\nvar _class2 = _interopRequireDefault(_class);\nvar _ui = require(\"./ui.scrollbar\");\nvar _ui2 = _interopRequireDefault(_ui);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar SCROLLABLE_NATIVE = \"dxNativeScrollable\";\nvar SCROLLABLE_NATIVE_CLASS = \"dx-scrollable-native\";\nvar SCROLLABLE_SCROLLBAR_SIMULATED = \"dx-scrollable-scrollbar-simulated\";\nvar SCROLLABLE_SCROLLBARS_HIDDEN = \"dx-scrollable-scrollbars-hidden\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar HIDE_SCROLLBAR_TIMEOUT = 500;\nvar NativeStrategy = _class2.default.inherit({\n  ctor: function ctor(scrollable) {\n    this._init(scrollable);\n  },\n  _init: function _init(scrollable) {\n    this._component = scrollable;\n    this._$element = scrollable.$element();\n    this._$container = scrollable._$container;\n    this._$content = scrollable._$content;\n    this._direction = scrollable.option(\"direction\");\n    this._useSimulatedScrollbar = scrollable.option(\"useSimulatedScrollbar\");\n    this._showScrollbar = scrollable.option(\"showScrollbar\");\n    this.option = scrollable.option.bind(scrollable);\n    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);\n    this._isLocked = scrollable._isLocked.bind(scrollable);\n    this._isDirection = scrollable._isDirection.bind(scrollable);\n    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);\n  },\n  render: function render() {\n    this._renderPushBackOffset();\n    var device = _devices2.default.real(),\n      deviceType = device.platform;\n    this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + \"-\" + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._showScrollbar);\n    if (this._showScrollbar && this._useSimulatedScrollbar) {\n      this._renderScrollbars();\n    }\n  },\n  updateBounds: _common.noop,\n  _renderPushBackOffset: function _renderPushBackOffset() {\n    var pushBackValue = this.option(\"pushBackValue\");\n    if (!pushBackValue && !this._component._lastPushBackValue) {\n      return;\n    }\n    this._$content.css({\n      paddingTop: pushBackValue,\n      paddingBottom: pushBackValue\n    });\n    this._component._lastPushBackValue = pushBackValue;\n  },\n  _renderScrollbars: function _renderScrollbars() {\n    this._scrollbars = {};\n    this._hideScrollbarTimeout = 0;\n    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);\n    this._renderScrollbar(VERTICAL);\n    this._renderScrollbar(HORIZONTAL);\n  },\n  _renderScrollbar: function _renderScrollbar(direction) {\n    if (!this._isDirection(direction)) {\n      return;\n    }\n    this._scrollbars[direction] = new _ui2.default((0, _renderer2.default)(\"<div>\").appendTo(this._$element), {\n      direction: direction,\n      expandable: this._component.option(\"scrollByThumb\")\n    });\n  },\n  handleInit: _common.noop,\n  handleStart: function handleStart() {\n    this._disablePushBack = true;\n  },\n  handleMove: function handleMove(e) {\n    if (this._isLocked()) {\n      e.cancel = true;\n      return;\n    }\n    if (this._allowedDirection()) {\n      e.originalEvent.isScrollingEvent = true;\n    }\n  },\n  handleEnd: function handleEnd() {\n    this._disablePushBack = false;\n  },\n  handleCancel: _common.noop,\n  handleStop: _common.noop,\n  _eachScrollbar: function _eachScrollbar(callback) {\n    callback = callback.bind(this);\n    (0, _iterator.each)(this._scrollbars || {}, function (direction, scrollbar) {\n      callback(scrollbar, direction);\n    });\n  },\n  createActions: function createActions() {\n    this._scrollAction = this._createActionByOption(\"onScroll\");\n    this._updateAction = this._createActionByOption(\"onUpdated\");\n  },\n  _createActionArgs: function _createActionArgs() {\n    var location = this.location();\n    return {\n      event: this._eventForUserAction,\n      scrollOffset: {\n        top: -location.top,\n        left: -location.left\n      },\n      reachedLeft: this._isDirection(HORIZONTAL) ? location.left >= 0 : void 0,\n      reachedRight: this._isDirection(HORIZONTAL) ? location.left <= this._containerSize.width - this._componentContentSize.width : void 0,\n      reachedTop: this._isDirection(VERTICAL) ? location.top >= 0 : void 0,\n      reachedBottom: this._isDirection(VERTICAL) ? location.top <= this._containerSize.height - this._componentContentSize.height : void 0\n    };\n  },\n  handleScroll: function handleScroll(e) {\n    if (!this._isScrollLocationChanged()) {\n      e.stopImmediatePropagation();\n      return;\n    }\n    this._eventForUserAction = e;\n    this._moveScrollbars();\n    this._scrollAction(this._createActionArgs());\n    this._lastLocation = this.location();\n    this._pushBackFromBoundary();\n  },\n  _pushBackFromBoundary: function _pushBackFromBoundary() {\n    var pushBackValue = this.option(\"pushBackValue\");\n    if (!pushBackValue || this._disablePushBack) {\n      return;\n    }\n    var scrollOffset = this._containerSize.height - this._contentSize.height,\n      scrollTopPos = this._$container.scrollTop(),\n      scrollBottomPos = scrollOffset + scrollTopPos - 2 * pushBackValue;\n    if (!scrollTopPos) {\n      this._$container.scrollTop(pushBackValue);\n    } else {\n      if (!scrollBottomPos) {\n        this._$container.scrollTop(pushBackValue - scrollOffset);\n      }\n    }\n  },\n  _isScrollLocationChanged: function _isScrollLocationChanged() {\n    var currentLocation = this.location(),\n      lastLocation = this._lastLocation || {},\n      isTopChanged = lastLocation.top !== currentLocation.top,\n      isLeftChanged = lastLocation.left !== currentLocation.left;\n    return isTopChanged || isLeftChanged;\n  },\n  _moveScrollbars: function _moveScrollbars() {\n    this._eachScrollbar(function (scrollbar) {\n      scrollbar.moveTo(this.location());\n      scrollbar.option(\"visible\", true);\n    });\n    this._hideScrollbars();\n  },\n  _hideScrollbars: function _hideScrollbars() {\n    clearTimeout(this._hideScrollbarTimeout);\n    this._hideScrollbarTimeout = setTimeout(function () {\n      this._eachScrollbar(function (scrollbar) {\n        scrollbar.option(\"visible\", false);\n      });\n    }.bind(this), HIDE_SCROLLBAR_TIMEOUT);\n  },\n  location: function location() {\n    return {\n      left: -this._$container.scrollLeft(),\n      top: this.option(\"pushBackValue\") - this._$container.scrollTop()\n    };\n  },\n  disabledChanged: _common.noop,\n  update: function update() {\n    this._update();\n    this._updateAction(this._createActionArgs());\n  },\n  _update: function _update() {\n    this._updateDimensions();\n    this._updateScrollbars();\n  },\n  _updateDimensions: function _updateDimensions() {\n    this._containerSize = {\n      height: this._$container.height(),\n      width: this._$container.width()\n    };\n    this._componentContentSize = {\n      height: this._component.$content().height(),\n      width: this._component.$content().width()\n    };\n    this._contentSize = {\n      height: this._$content.height(),\n      width: this._$content.width()\n    };\n    this._pushBackFromBoundary();\n  },\n  _updateScrollbars: function _updateScrollbars() {\n    this._eachScrollbar(function (scrollbar, direction) {\n      var dimension = direction === VERTICAL ? \"height\" : \"width\";\n      scrollbar.option({\n        containerSize: this._containerSize[dimension],\n        contentSize: this._componentContentSize[dimension]\n      });\n      scrollbar.update();\n    });\n  },\n  _allowedDirections: function _allowedDirections() {\n    return {\n      vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,\n      horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width\n    };\n  },\n  dispose: function dispose() {\n    var className = this._$element.get(0).className;\n    var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + \"\\\\S*\", \"g\");\n    if (scrollableNativeRegexp.test(className)) {\n      this._$element.removeClass(className.match(scrollableNativeRegexp).join(\" \"));\n    }\n    _events_engine2.default.off(this._$element, \".\" + SCROLLABLE_NATIVE);\n    _events_engine2.default.off(this._$container, \".\" + SCROLLABLE_NATIVE);\n    this._removeScrollbars();\n    clearTimeout(this._hideScrollbarTimeout);\n  },\n  _removeScrollbars: function _removeScrollbars() {\n    this._eachScrollbar(function (scrollbar) {\n      scrollbar.$element().remove();\n    });\n  },\n  scrollBy: function scrollBy(distance) {\n    var location = this.location();\n    this._$container.scrollTop(Math.round(-location.top - distance.top + this.option(\"pushBackValue\")));\n    this._$container.scrollLeft(Math.round(-location.left - distance.left));\n  },\n  validate: function validate(e) {\n    if (this.option(\"disabled\")) {\n      return false;\n    }\n    if (_utils2.default.isDxMouseWheelEvent(e) && this._isScrolledInMaxDirection(e)) {\n      return false;\n    }\n    return !!this._allowedDirection();\n  },\n  _isScrolledInMaxDirection: function _isScrolledInMaxDirection(e) {\n    var container = this._$container.get(0);\n    var result = void 0;\n    if (e.delta > 0) {\n      result = e.shiftKey ? !container.scrollLeft : !container.scrollTop;\n    } else {\n      if (e.shiftKey) {\n        result = container.clientWidth + container.scrollLeft >= container.scrollWidth;\n      } else {\n        result = container.clientHeight + container.scrollTop >= container.scrollHeight;\n      }\n    }\n    return result;\n  },\n  getDirection: function getDirection() {\n    return this._allowedDirection();\n  },\n  verticalOffset: function verticalOffset() {\n    return this.option(\"pushBackValue\");\n  }\n});\nmodule.exports = NativeStrategy;","map":null,"metadata":{},"sourceType":"script"}